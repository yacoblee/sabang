package or.sabang.utl;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.Point;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Field;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import javax.annotation.Resource;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartUtils;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.TickUnitSource;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.xy.XYDataset;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import org.json.JSONObject;
import org.json.simple.JSONArray;
import org.json.simple.parser.JSONParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.context.annotation.Scope;
import org.springframework.context.annotation.ScopedProxyMode;
import org.springframework.stereotype.Component;

import com.supermap.analyst.spatialanalyst.BufferAnalyst;
import com.supermap.analyst.spatialanalyst.BufferAnalystParameter;
import com.supermap.analyst.spatialanalyst.BufferEndType;
import com.supermap.analyst.spatialanalyst.BufferRadiusUnit;
import com.supermap.analyst.spatialanalyst.ConversionAnalyst;
import com.supermap.analyst.spatialanalyst.ConversionAnalystParameter;
import com.supermap.analyst.spatialanalyst.GridStatisticsMode;
import com.supermap.analyst.spatialanalyst.OverlayAnalyst;
import com.supermap.analyst.spatialanalyst.OverlayAnalystParameter;
import com.supermap.analyst.spatialanalyst.RasterClip;
import com.supermap.analyst.spatialanalyst.SmoothMethod;
import com.supermap.analyst.spatialanalyst.StatisticsAnalyst;
import com.supermap.analyst.spatialanalyst.VectorClip;
import com.supermap.analyst.spatialanalyst.ZonalStatisticsAnalystParameter;
import com.supermap.analyst.spatialanalyst.ZonalStatisticsAnalystResult;
import com.supermap.analyst.terrainanalyst.HydrologyAnalyst;
import com.supermap.analyst.terrainanalyst.StreamOrderType;
import com.supermap.data.BlockSizeOption;
import com.supermap.data.Charset;
import com.supermap.data.ColorDictionary;
import com.supermap.data.CoordSysTransMethod;
import com.supermap.data.CoordSysTransParameter;
import com.supermap.data.CoordSysTranslator;
import com.supermap.data.CursorType;
import com.supermap.data.Dataset;
import com.supermap.data.DatasetGrid;
import com.supermap.data.DatasetGridInfo;
import com.supermap.data.DatasetImage;
import com.supermap.data.DatasetImageInfo;
import com.supermap.data.DatasetType;
import com.supermap.data.DatasetVector;
import com.supermap.data.DatasetVectorInfo;
import com.supermap.data.Datasets;
import com.supermap.data.Datasource;
import com.supermap.data.DatasourceConnectionInfo;
import com.supermap.data.Datasources;
import com.supermap.data.EncodeType;
import com.supermap.data.EngineType;
import com.supermap.data.Feature;
import com.supermap.data.FieldInfo;
import com.supermap.data.FieldInfos;
import com.supermap.data.FieldType;
import com.supermap.data.GeoCompound;
import com.supermap.data.GeoCoordSys;
import com.supermap.data.GeoLegend;
import com.supermap.data.GeoLine;
import com.supermap.data.GeoMap;
import com.supermap.data.GeoPoint;
import com.supermap.data.GeoRectangle;
import com.supermap.data.GeoRegion;
import com.supermap.data.GeoStyle;
import com.supermap.data.GeoText;
import com.supermap.data.Geometry;
import com.supermap.data.GeometryType;
import com.supermap.data.PixelFormat;
import com.supermap.data.Point2D;
import com.supermap.data.Point2Ds;
import com.supermap.data.PrjCoordSys;
import com.supermap.data.PrjParameter;
import com.supermap.data.Recordset;
import com.supermap.data.Rectangle2D;
import com.supermap.data.Size2D;
import com.supermap.data.StatisticsResult;
import com.supermap.data.TextAlignment;
import com.supermap.data.TextPart;
import com.supermap.data.TextStyle;
import com.supermap.data.Workspace;
import com.supermap.data.WorkspaceConnectionInfo;
import com.supermap.data.WorkspaceType;
import com.supermap.data.conversion.DataExport;
import com.supermap.data.conversion.DataImport;
import com.supermap.data.conversion.ExportResult;
import com.supermap.data.conversion.ExportSetting;
import com.supermap.data.conversion.FileType;
import com.supermap.data.conversion.ImportMode;
import com.supermap.data.conversion.ImportResult;
import com.supermap.data.conversion.ImportSettingSHP;
import com.supermap.layout.LayoutElements;
import com.supermap.layout.PrintFileType;
import com.supermap.mapping.LabelBackShape;
import com.supermap.mapping.Layer;
import com.supermap.mapping.LayerSettingGrid;
import com.supermap.mapping.LayerSettingImage;
import com.supermap.mapping.LayerSettingVector;
import com.supermap.mapping.ThemeGridRange;
import com.supermap.mapping.ThemeGridRangeItem;
import com.supermap.mapping.ThemeLabel;
import com.supermap.mapping.ThemeUnique;
import com.supermap.mapping.ThemeUniqueItem;
import com.supermap.ui.Action;
import com.supermap.ui.MapLayoutControl;

import egovframework.com.cmm.EgovWebUtil;
import egovframework.com.cmm.service.EgovProperties;
import egovframework.com.utl.fcc.service.EgovFileUploadUtil;
import egovframework.rte.fdl.cryptography.EgovEnvCryptoService;
import egovframework.rte.fdl.property.EgovPropertyService;
import egovframework.rte.psl.dataaccess.util.EgovMap;
import or.sabang.sys.gis.service.AnalFileVO;
import or.sabang.sys.service.SysComptVO;
import or.sabang.sys.service.SysFieldInfoVO;
import or.sabang.sys.service.ZonalStatisticVO;

@Component("superMapUtils")
@Scope(scopeName = "prototype", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class SuperMapUtils_231122 {
	
	public static final Logger LOGGER = LoggerFactory.getLogger(SuperMapUtils.class);
	
	/** 암호화서비스 */
	@Resource(name = "egovEnvCryptoService")
	EgovEnvCryptoService cryptoService;
	/** 프러퍼티서비스 */
	@Resource(name="propertiesService")
    protected EgovPropertyService propertyService;
	
	private Workspace workspace = null;
	private Datasources datasources = null;
	
	//database
	private Datasource datasource = null;
	private Datasets datasets = null;
	private DatasetVector dataset = null;
	private Recordset recordset = null;
	
	//udb
	private Datasource uDatasource = null;
	private Datasets uDatasets = null;
	private DatasetVector uDataset = null;
	private Recordset uRecordset = null;
	
	//vworld
	private Datasource vDatasource = null;
	private Datasets vDatasets = null;
	private Dataset vDataset = null;
	private Recordset vRecordset = null;
	
	//memory udb
	private Datasource mDatasource = null;
	private Datasets mDatasets = null;
	
	private MapLayoutControl mapLayoutcontrol = null;
	
	private Map<String, Object> attributes = null;
	private JSONObject returnLog = null;
	private int epsg = 0;
	
	private boolean deleted = true;
	
	/** 첨부파일 위치 지정  => globals.properties */
	private final String fileStoragePath = EgovProperties.getProperty("Globals.fileStorePath");
	private final String superMapStoragePath = EgovProperties.getProperty("Globals.fileStorePath.superMap");
    private final String downloadMidDir = "analysis";
    private final String shpMidDir = "shpDown";
    private final String superMapMidDir = "superMap";
	private final String smwuFileNm = "feis.smwu";
//	private final String pGisAlias = "feis2023";
	//개발
	private final String pGisAlias = "sabang";
	//운영
//	private final String pGisAlias = "feisdb";

	/**
	 * 슈퍼맵 연결정보 생성
	 * @return
	 * @throws Exception
	 */
	private void getConnectionInfo() throws Exception{
		workspace = new Workspace();
		LOGGER.info("워크스페이스 생성");
		WorkspaceConnectionInfo conn = new WorkspaceConnectionInfo();
		//String path = "";//SphUtil.getFilePath(this.item.getFileDefaultLocPath(), "smwu", this.item.getServerInfohash());
		conn.setType(WorkspaceType.SMWU);
		conn.setName("feis");
		conn.setServer(superMapStoragePath + superMapMidDir + File.separator + smwuFileNm);

		workspace.open(conn);
		
		//작업공간을 열고 데이터소스 가져오기
		datasources = workspace.getDatasources();
		
		if(datasources.contains(pGisAlias)) {
			datasource = datasources.get(pGisAlias);
			datasets = datasource.getDatasets();
		}
		
		if(datasources.contains("feis")) {
			uDatasource = datasources.get("feis");
			uDatasets = uDatasource.getDatasets();
		}
		
		if(datasources.contains("api.vworld.kr")) {
			vDatasource = datasources.get("api.vworld.kr");
			vDatasets = vDatasource.getDatasets();
		}
	}
	
	private void getConnectionInfo(String uniqId) throws Exception{
		workspace = new Workspace();
		LOGGER.info("워크스페이스 생성 : ".concat(uniqId));
		WorkspaceConnectionInfo conn = new WorkspaceConnectionInfo();
		//String path = "";//SphUtil.getFilePath(this.item.getFileDefaultLocPath(), "smwu", this.item.getServerInfohash());
		conn.setType(WorkspaceType.SMWU);
		conn.setName("feis");
		conn.setServer(superMapStoragePath + superMapMidDir + File.separator + smwuFileNm);

		workspace.open(conn);
		LOGGER.debug("SMWU 파일 연결 : ".concat(uniqId));
		//작업공간을 열고 데이터소스 가져오기
		datasources = workspace.getDatasources();
		
		DatasourceConnectionInfo connectionInfo = null;
		
		if(datasources.contains(pGisAlias)) {
			datasource = datasources.get(pGisAlias);
			datasets = datasource.getDatasets();
			LOGGER.debug("(OLD)"+pGisAlias+" 연결 : ".concat(uniqId));
		}else {
			connectionInfo = new DatasourceConnectionInfo();
			
			String server = propertyService.getString("supermap.postgres.server");
			//String driver = propertyService.getString("Globals.postgres.DriverClassName");
			String database = propertyService.getString("supermap.postgres.database");
			//String alias = propertyService.getString("supermap.postgres.alias");
			
			//연결정보 입력하기
			connectionInfo.setEngineType(EngineType.PGGIS);
			connectionInfo.setServer(server);
			connectionInfo.setDatabase(database);
			connectionInfo.setUser(cryptoService.getUsername());
			connectionInfo.setPassword(cryptoService.getPassword());
			connectionInfo.setAlias(database);
			
			datasource = datasources.open(connectionInfo);
			datasets = datasource.getDatasets();
			LOGGER.debug("(NEW)"+pGisAlias+" 연결 : ".concat(uniqId));
		}
		
		if(datasources.contains("feis")) {
			uDatasource = datasources.get("feis");
			uDatasets = uDatasource.getDatasets();
			LOGGER.debug("feis udb 연결 : ".concat(uniqId));
		}
		
		if(datasources.contains("api.vworld.kr")) {
			vDatasource = datasources.get("api.vworld.kr");
			vDatasets = vDatasource.getDatasets();
			LOGGER.debug("(OLD)vworld 연결 : ".concat(uniqId));
		}else {
			connectionInfo = new DatasourceConnectionInfo();
			//연결정보 입력하기
			connectionInfo.setEngineType(EngineType.OGC);
			connectionInfo.setServer("http://api.vworld.kr/req/wmts/1.0.0/199ECDF7-42EA-300D-B487-B7001CC9C0E6/WMTSCapabilities.xml");
			connectionInfo.setDriver("WMTS");
			connectionInfo.setAlias("api.vworld.kr");
			
			vDatasource = datasources.open(connectionInfo);
			vDatasets = vDatasource.getDatasets();
			LOGGER.debug("(NEW)vworld 연결 : ".concat(uniqId));
		}
		
		
		if(uniqId != null) {
			connectionInfo = new DatasourceConnectionInfo();
			connectionInfo.setServer(":memory:");
			connectionInfo.setEngineType(EngineType.MEMORY);
			//connInfo.setReadOnly(readOnly);
			connectionInfo.setAlias("m".concat(uniqId));
			mDatasource = datasources.create(connectionInfo);
			mDatasets = mDatasource.getDatasets();
			LOGGER.debug("memory udb 연결 : ".concat(uniqId));
		}
	}
	
	/**
	 * 쉐이프파일 업로드 저장
	 * @param url 파일경로
	 * @param vectorName 테이블명
	 * @param delAll 전체삭제여무
	 * @return
	 * @throws Exception
	 */
	public JSONObject uploadInsertShape(String url, String vectorName, boolean delAll) throws Exception{
		returnLog = new JSONObject();
		boolean processed = true;
		
		try {
			getConnectionInfo();
			//테이블 존재여부 확인
			if(datasets.contains(vectorName)) {
				//datasets.delete(dataSetVectorNmae); //테이블 삭제
				dataset = (DatasetVector) datasets.get(vectorName);
				
				if(delAll) {
					LOGGER.info("dataset truncate start...");
					processed = dataset.truncate();//데이터셋 레코드 전체 삭제
					LOGGER.info("dataset truncate end...");
				}
				
				if(processed) {
					ImportResult result = importShpToDb(url,vectorName);
					
	                if(result.getFailedSettings().length == 0) {
	                	LOGGER.info("등록완료.");
	                	returnLog.put("status", "success");
			        	returnLog.put("message", "등록완료.");
	                }else {
	                	LOGGER.info("저장실패.");
	                	returnLog.put("status", "fail");
			        	returnLog.put("message", "등록실패.");
	                }
				}else {
					returnLog.put("status", "fail");
					returnLog.put("message", "랭크 데이터를 삭제하지 못했습니다.\n관리자에게 문의하세요.");
				}
			}else {
				returnLog.put("status", "fail");
				returnLog.put("message", "테이블을 찾을 수 없습니다\n관리자에게 문의하세요.");
			}
		} catch (Exception e) {
			returnLog.put("error", e.getLocalizedMessage());
			LOGGER.error(e.getLocalizedMessage());
		} finally {
			closeConnection();
		}
		
		return returnLog;
	}
	
	/**
	 * udbx 데이터셋 삭제
	 * @param datasetName
	 * @param query
	 * @return
	 * @throws Exception
	 */
	public void deleteUdbxDataSet(String datasetName) throws Exception{
		try {
			getConnectionInfo();
			
			if(uDatasets.contains(datasetName)) {
				boolean complate = uDatasets.delete(datasetName);
				if(!complate) {
					LOGGER.error(datasetName.concat(" 데이터셋 삭제를 실패하였습니다."));
				}
			}else {
				LOGGER.error(datasetName.concat(" 데이터셋이 존재하지 않습니다."));
			}
			
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		
	}
	/**
	 * 데이터셋 복사
	 * @param vectorName
	 * @param copyName
	 * @param query
	 * @return
	 * @throws Exception
	 */
	public JSONObject copyDataSet(String vectorName, String copyName, String query) throws Exception{
		returnLog = new JSONObject();
		try {
			//getDatasourceConnectionInfo();
			
			//getUdbxConnectionInfo();
			getConnectionInfo();
			
			
			if(datasets.contains(vectorName)) {
				dataset = (DatasetVector) datasets.get(vectorName);
				recordset = dataset.query(query,CursorType.STATIC);
				
				DatasetVector datasetVector = (DatasetVector) uDatasets.createFromTemplate(uDatasets.getAvailableDatasetName(copyName),dataset);
				
				datasetVector.append(recordset);
				datasetVector.close();
				
				returnLog.put("status", "success");
			}
		}catch(Exception e) {
			returnLog.put("status", "fail");
			returnLog.put("message", "레코드셋 복사를 실패하였습니다.");
		}finally {
			//closeDbmsAll();
			//closeUdbxAll();
			//closeWorkspace();
			closeConnection();
		}
		return returnLog;
	}
	
	/**
	 * 구역통계 분석(Zonal Statistics)
	 * @param zonalName 구역데이터명(vector)
	 * @param valueName 추출데이터명(raster)
	 * @param outputDatasetName 결과데이터명
	 * @param outputTableName 결과테이블 명
	 * @return
	 * @throws Exception
	 */
	public List<ZonalStatisticVO> zonalStatisticsProcessing(String zonalName,String valueName,String outputDatasetName, String outputTableName, String zonalFieldName) throws Exception{
		List<ZonalStatisticVO> resultList = null;
		
		try {
			getConnectionInfo();
			
			Dataset zonalDataset = null;
			DatasetGrid valueDataset = null;
			
			if(uDatasets.contains(zonalName)) {
				zonalDataset = (Dataset) uDatasets.get(zonalName);
			}else {
				LOGGER.error("구역통계(Zonal Statistics)의 Zonal Data가 존재하지 않습니다.");
				return null;
			}
			
			if(datasets.contains(valueName)) {
				valueDataset = (DatasetGrid) datasets.get(valueName);
			}else {
				LOGGER.error("구역통계(Zonal Statistics)의 Value Data가 존재하지 않습니다.");
				return null;
			}
			
			if (uDatasets.contains(outputDatasetName))
			{
				uDatasets.delete(outputDatasetName);
			}
		
			if (uDatasets.contains(outputTableName))
			{
				uDatasets.delete(outputTableName);
			}
		
			ZonalStatisticsAnalystParameter parameter = new ZonalStatisticsAnalystParameter();
			parameter.setTargetDatasource(uDatasource);
			parameter.setTargetDatasetName(outputDatasetName);
			parameter.setTargetTableName(outputTableName);
			parameter.setZonalFieldName(zonalFieldName);
			parameter.setIgnoreNoValue(true);
			parameter.setStatisticsMode(GridStatisticsMode.MEAN);
			//parameter.setPixelFormat(PixelFormat.DOUBLE);
			parameter.setValueDataset(valueDataset);
			parameter.setZonalDataset(zonalDataset);
			
			ZonalStatisticsAnalystResult zonalStatisticResult = StatisticsAnalyst.zonalStatisticsOnRasterValue(parameter);
			DatasetVector resultDatasetVector = zonalStatisticResult.getResultTable();
			
			DatasetVector zonalDatasetVector = (DatasetVector) uDatasets.get(zonalName);
			Recordset zonalRecordSet = null;
			
			Map<Integer, Feature> list = resultDatasetVector.getAllFeatures();
			
			resultList = new ArrayList<ZonalStatisticVO>();
			
			for(Map.Entry<Integer, Feature> item : list.entrySet()) {
				Feature feature = item.getValue();
				
				String zonalId = feature.getValue("ZonalID").toString();
				double minValue = Double.valueOf(feature.getValue("Minimum").toString());
				double maxValue = Double.valueOf(feature.getValue("Maximum").toString());
				double meanValue = Double.valueOf(feature.getValue("Mean").toString());
				
				zonalRecordSet = zonalDatasetVector.query("SmID = ".concat(zonalId),CursorType.STATIC);
				
				String uniqId = (String) zonalRecordSet.getFieldValue("uniq_id");
				int zonalMin = (int) Math.round(minValue);
				int zonalMax = (int) Math.round(maxValue);
				int zonalMean = (int) Math.round(meanValue);
				
				ZonalStatisticVO resultVo = new ZonalStatisticVO();
				resultVo.setUniqId(uniqId);
				resultVo.setZonalMin(zonalMin);
				resultVo.setZonalMax(zonalMax);
				resultVo.setZonalMean(zonalMean);
				
				resultList.add(resultVo);
				
//				LOGGER.info("-------------------------------------------------------");
//				LOGGER.info("ZonalID : "+feature.getValue("ZonalID").toString());
//				LOGGER.info("Minimum : "+feature.getValue("Minimum").toString());
//				LOGGER.info("Maximum : "+feature.getValue("Maximum").toString());
//				LOGGER.info("Mean : "+feature.getValue("Mean").toString());
//				LOGGER.info("-------------------------------------------------------");
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		return resultList;
	}
	
	//---------------------------------------------------------------------------------------------------------------------
	//----------------------------------------------전자야장 위치도 생성 --------------------------------------------------------
	//---------------------------------------------------------------------------------------------------------------------
	/**
	 * 땅밀림 실태조사 위치도
	 * @param schMap
	 * @throws Exception
	 */
	public AnalFileVO creatLcpLocLgstrMap(HashMap<String, Object> schMap,String analId) throws Exception{
		//List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		
		String mstId = schMap.get("mstId").toString();
		String svyLabel = schMap.get("sldId").toString();
		//String saveImgNm = null;
		String mapId = "Map_".concat(analId);
		String ctrlnDatasetNm = "tf_feis_ctrln";//등고선
		String lgstrDatasetNm = "tf_feis_lgstr";//지적
		String roadDatasetNm = "tf_feis_road";//도로중심선
		String rankDatasetNm = "tf_feis_lcp_fieldinfo";//랭크대상지
		
		String rankCopydatasetNm = "rank_".concat(analId);//랭크대상지 클립 데이터셋명
		String ctrlnCopyDatasetNm = "lcp_ctrln_".concat(analId);//등고선 클립 데이터셋명
		String lgstrCopyDatasetNm = "lgstr_".concat(analId);//지적 클립 데이터셋명
		String roadCopyDatasetNm = "road_".concat(analId);//도로중심선 클립 데이터셋명
		
		DatasetVector rankCopyDatasetVector = null;
		DatasetVector ctrlnClipDatasetVector = null;
		DatasetVector lgstrClipDatasetVector = null;
		DatasetVector roadClipDatasetVector = null;
		
		String stripLandQuery = "mst_id = ".concat(mstId).concat(" and svy_label = '").concat(svyLabel).concat("'");
		
		Rectangle2D newBound = null;
		
		try {
			//슈퍼맵 연결
			LOGGER.info("슈퍼맵 연결 시작 : ".concat(analId));
			getConnectionInfo(analId);
			LOGGER.info("슈퍼맵 연결 완료 : ".concat(analId));
			//smwu프로젝트에 Map 생성하기
			LOGGER.info("Map 생성 시작 : ".concat(analId));
			createNewMap(mapId,5186);
			LOGGER.info("Map 생성 완료 : ".concat(analId));
			//랭크대상지 데이터 DB에서 UDB로 복사
			LOGGER.info(rankDatasetNm+"데이터셋을 udb에 "+stripLandQuery+" 조건의 "+rankCopydatasetNm+" 데이터셋으로 복사 : ".concat(analId));
			copyPggisToMemoryUdb(rankDatasetNm,rankCopydatasetNm,stripLandQuery);
			//copyPggisToUdb(rankDatasetNm,rankCopydatasetNm,stripLandQuery);
			LOGGER.info("데이터셋 복사 완료 : ".concat(analId));
			//지적데이터셋 자르기
			if(mDatasets.contains(rankCopydatasetNm)) {
				LOGGER.info("데이터셋 Clip 시작");
				rankCopyDatasetVector = (DatasetVector) mDatasets.get(rankCopydatasetNm);
				Recordset mRecordset = rankCopyDatasetVector.query("",CursorType.STATIC);
				
				Rectangle2D bound = mRecordset.getGeometry().getBounds();
				double wd = bound.getWidth();
				
				newBound = new Rectangle2D();
				//클립할 영역 설정(이미지 영역보다 조금 더 많이 자름)
				newBound.setTop(bound.getTop()+(wd*10));
				newBound.setBottom(bound.getBottom()-(wd*10));
				newBound.setLeft(bound.getLeft()-(wd*10));
				newBound.setRight(bound.getRight()+(wd*10));
				
				GeoRectangle geoRect = new GeoRectangle(newBound, 0);
				GeoRegion region = geoRect.convertToRegion();

				mRecordset.dispose();
				
				ctrlnClipDatasetVector = VectorClip.clipDatasetVector((DatasetVector)datasource.getDatasets().get(ctrlnDatasetNm), region, true, false, mDatasource, ctrlnCopyDatasetNm);
				if(ctrlnClipDatasetVector.getRecordCount() > 0) {
					LOGGER.info("등고 데이터셋 Clip 완료");
				}else {
					LOGGER.info("등고 데이터셋 Clip 실패");
				}
				
				lgstrClipDatasetVector = VectorClip.clipDatasetVector((DatasetVector)datasource.getDatasets().get(lgstrDatasetNm), region, true, false, mDatasource, lgstrCopyDatasetNm);
				if(lgstrClipDatasetVector.getRecordCount() > 0) {
					LOGGER.info("지적 데이터셋 Clip 완료");
				}else {
					LOGGER.info("지적 데이터셋 Clip 실패");
				}
				roadClipDatasetVector = VectorClip.clipDatasetVector((DatasetVector)datasource.getDatasets().get(roadDatasetNm), region, true, false, mDatasource, roadCopyDatasetNm);
				if(roadClipDatasetVector.getRecordCount() > 0) {
					LOGGER.info("도로 데이터셋 Clip 완료");
				}else {
					LOGGER.info("도로 데이터셋 Clip 실패");
				}
				//이미지 영역설정
				newBound.setTop(bound.getTop()+(wd*2));
				newBound.setBottom(bound.getBottom()-(wd*2));
				newBound.setLeft(bound.getLeft()-(wd*2));
				newBound.setRight(bound.getRight()+(wd*2));
			}
			LOGGER.info("Map에 데이터셋 추가 시작");
			addLayerSingleBandVector(ctrlnClipDatasetVector,mapId,ctrlnCopyDatasetNm);
			addLayerSingleBandVector(lgstrClipDatasetVector,mapId,lgstrCopyDatasetNm);
			addLayerThemeLabelVector(lgstrClipDatasetVector,mapId,lgstrCopyDatasetNm);
			addLayerSingleBandVector(roadClipDatasetVector,mapId,roadCopyDatasetNm);
			addLayerSingleBandVector(rankCopyDatasetVector,mapId,rankCopydatasetNm);
			LOGGER.info("Map에 데이터셋 추가 완료");
			vo = getSavePath(analId,downloadMidDir);
			vo.setOrignlFileNm("위치도");
			vo.setAnalType("위치도");
			vo.setMstId(Integer.valueOf(mstId));
			vo.setSldId(svyLabel);
			
			if(setMapLayoutControl("lcpVectorLocTemplate",mapId,newBound)) {
				//saveImgNm = saveMapImage();
				//AnalFileVO vo = saveMapImage(analId);
				vo = saveMapImage(vo);
				//list.add(imgVo);
				if(deleted) {
					deleteMap(mapId);
				}
			}
			ctrlnClipDatasetVector.close();
			lgstrClipDatasetVector.close();
			roadClipDatasetVector.close();
			rankCopyDatasetVector.close();
			
//			if(deleted) {
//				uDatasets.delete(ctrlnCopyDatasetNm);
//				uDatasets.delete(lgstrCopyDatasetNm);
//				uDatasets.delete(roadCopyDatasetNm);
//				uDatasets.delete(rankCopydatasetNm);
//			}
			//exportUdbToFile(ctrlnCopyDatasetNm, vo, "shp");
			//exportUdbToFile(lgstrCopyDatasetNm, vo, "shp");
			//exportUdbToFile(roadCopyDatasetNm, vo, "shp");
			//exportUdbToFile(rankCopydatasetNm, vo, "shp");
			
			//vo.setFileExtsn("zip");
			//list.add(vo);
			
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		return vo;
		
		
	}

	/**
	 * 땅밀림 실태조사 위성영상 위치도
	 * @param schMap
	 * @param processId
	 * @return
	 * @throws Exception
	 */
	public AnalFileVO creatLcpLocSatMap(HashMap<String, Object> schMap,String analId) throws Exception{
		//List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		
		String mstId = schMap.get("mstId").toString();
		String svyLabel = schMap.get("sldId").toString();
		//String saveImgNm = null;
		String mapId = "Map_".concat(analId);
		String rankDatasetNm = "tf_feis_lcp_fieldinfo";//랭크대상지
		
		String rankCopydatasetNm = "rank_".concat(analId);;//랭크대상지 클립 데이터셋명
		
		DatasetVector rankCopyDatasetVector = null;
		
		String stripLandQuery = "mst_id = ".concat(mstId).concat(" and svy_label = '").concat(svyLabel).concat("'");
		
		Rectangle2D newBound = null;
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapId,3857);
			
			//랭크대상지 데이터 DB에서 UDB로 복사
			copyPggisToMemoryUdb(rankDatasetNm,rankCopydatasetNm,stripLandQuery);
			//copyPggisToUdb(rankDatasetNm,rankCopydatasetNm,stripLandQuery);
			
			if(mDatasets.contains(rankCopydatasetNm)) {
				rankCopyDatasetVector = (DatasetVector) mDatasets.get(rankCopydatasetNm);
				
				if(coordSysTranslator(rankCopyDatasetVector,3857)) {
					Recordset mRecordset = rankCopyDatasetVector.query("",CursorType.STATIC);
					
					Rectangle2D bound = mRecordset.getGeometry().getBounds();
					
					double wd = bound.getWidth()*2;
					
					newBound = new Rectangle2D();
					
					newBound.setTop(bound.getTop()+wd);
					newBound.setBottom(bound.getBottom()-wd);
					newBound.setLeft(bound.getLeft()-wd);
					newBound.setRight(bound.getRight()+wd);
					
					vDataset = vDatasets.get("VworldSatellite");
					
					addLayerImage(vDataset,mapId,"vworld");
					addLayerSingleBandVector(rankCopyDatasetVector,mapId,rankCopydatasetNm);
					addLayerThemeLabelVector(rankCopyDatasetVector,mapId,rankCopydatasetNm);
					
					vo = getSavePath(analId,downloadMidDir);
					vo.setOrignlFileNm("위치도(영상)");
					vo.setAnalType("위치도(영상)");
					vo.setMstId(Integer.valueOf(mstId));
					vo.setSldId(svyLabel);
					
					if(setMapLayoutControl("lcpSatelliteLocTemplate",mapId,newBound)) {
						//saveImgNm = saveMapImage();
						vo = saveMapImage(vo);
						//list.add(imgVo);
						if(deleted) {
							deleteMap(mapId);
					
//							if(uDatasets.contains(rankCopydatasetNm)) {
//								uDatasets.delete(rankCopydatasetNm);
//							}
						}
					}
					
					rankCopyDatasetVector.close();
					
//					if(deleted) {
//						uDatasets.delete(rankCopydatasetNm);
//					}
					
					//exportUdbToFile(rankCopydatasetNm, vo, "shp");
					
					//vo.setFileExtsn("zip");
					//list.add(vo);
				}else {
					LOGGER.error("좌표변환에 실패하였습니다.");
				}
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		return vo;
	}
	
	/**
	 * 취약지역 위치도
	 * @param schMap
	 * @param analId
	 * @return
	 * @throws Exception
	 */
	public AnalFileVO creatWkaLocLgstrMap(HashMap<String, Object> schMap,String analId) throws Exception{
		AnalFileVO vo = null;
		
		String gId = schMap.get("gid").toString();
		String mstId = schMap.get("mstId").toString();
		String svyLabel = schMap.get("sldId").toString();
		String mapId = "Map_".concat(analId);
		
		String vnaraPntDatasetNm = "tf_feis_wka_vnarapnt";//포인트(유출구)
		String vnaraPlgnDatasetNm = "tf_feis_wka_vnaraplgn";//폴리곤(사방댐,계류보전,유역면적,산지사방)
		String lgstrDatasetNm = "tf_feis_lgstr";//지적
		
		String vnaraPntCopyDatasetNm = "wpnt_".concat(analId);//포인트(유출구) 조회 데이터셋명
		String vnaraPlgnCopyDatasetNm = "wplgn_".concat(analId);//폴리곤(사방댐,계류보전,유역면적,산지사방) 조회 데이터셋명
		String lgstrCopyDatasetNm = "wlgstr_".concat(analId);//지적 클립 데이터셋명
		
		DatasetVector vnaraPntCopyDatasetVector = null;
		DatasetVector vnaraPlgnCopyDatasetVector = null;
		DatasetVector lgstrClipDatasetVector = null;
		
		String vnaraQuery = "gid = ".concat(gId);
		
		Rectangle2D newBound = null;
		
		try {
			//슈퍼맵 연결
			LOGGER.info("슈퍼맵 연결 시작 : ".concat(analId));
			getConnectionInfo(analId);
			LOGGER.info("슈퍼맵 연결 완료 : ".concat(analId));
			//smwu프로젝트에 Map 생성하기
			LOGGER.info("Map 생성 시작 : ".concat(analId));
			createNewMap(mapId,5186);
			LOGGER.info("Map 생성 완료 : ".concat(analId));
			
			//포인트 데이터셋에서 vnara_exmnn_id로 대상 조회
			LOGGER.info(vnaraPntDatasetNm+"데이터셋을 memory udb에 "+vnaraQuery+" 조건의 "+vnaraPntCopyDatasetNm+" 데이터셋으로 복사 : ".concat(analId));
			copyPggisToMemoryUdb(vnaraPntDatasetNm,vnaraPntCopyDatasetNm,vnaraQuery);
			LOGGER.info("데이터셋 복사 완료 : ".concat(analId));
			
			//폴리곤 데이터셋에서 vnara_exmnn_id로 대상 조회
			LOGGER.info(vnaraPlgnDatasetNm+"데이터셋을 memory udb에 "+vnaraQuery+" 조건의 "+vnaraPlgnCopyDatasetNm+" 데이터셋으로 복사 : ".concat(analId));
			copyPggisToMemoryUdb(vnaraPlgnDatasetNm,vnaraPlgnCopyDatasetNm,vnaraQuery);
			LOGGER.info("데이터셋 복사 완료 : ".concat(analId));
			
			//지적데이터셋 자르기
			if(mDatasets.contains(vnaraPlgnCopyDatasetNm)) {
				LOGGER.info("데이터셋 Clip 시작");
				vnaraPlgnCopyDatasetVector = (DatasetVector) mDatasets.get(vnaraPlgnCopyDatasetNm);
				Recordset mRecordset = vnaraPlgnCopyDatasetVector.query("",CursorType.STATIC);
				if(mRecordset.getGeometry() != null) {
					Rectangle2D bound = mRecordset.getGeometry().getBounds();
					double wd = bound.getWidth();
					
					newBound = new Rectangle2D();
					//클립할 영역 설정(이미지 영역보다 조금 더 많이 자름)
					newBound.setTop(bound.getTop()+(wd*10));
					newBound.setBottom(bound.getBottom()-(wd*10));
					newBound.setLeft(bound.getLeft()-(wd*10));
					newBound.setRight(bound.getRight()+(wd*10));
					
					GeoRectangle geoRect = new GeoRectangle(newBound, 0);
					GeoRegion region = geoRect.convertToRegion();

					mRecordset.dispose();
					lgstrClipDatasetVector = VectorClip.clipDatasetVector((DatasetVector)datasource.getDatasets().get(lgstrDatasetNm), region, true, false, mDatasource, lgstrCopyDatasetNm);
					if(lgstrClipDatasetVector.getRecordCount() > 0) {
						LOGGER.info("지적 데이터셋 Clip 완료");
					}else {
						LOGGER.info("지적 데이터셋 Clip 실패");
					}
					
					//이미지 영역설정
					newBound.setTop(bound.getTop()+(wd*1.5));
					newBound.setBottom(bound.getBottom()-(wd*1.5));
					newBound.setLeft(bound.getLeft()-(wd*1.5));
					newBound.setRight(bound.getRight()+(wd*1.5));
					
					vnaraPntCopyDatasetVector = (DatasetVector) mDatasets.get(vnaraPntCopyDatasetNm);
					
					LOGGER.info("Map에 데이터셋 추가 시작");
					addLayerSingleBandVector(lgstrClipDatasetVector,mapId,lgstrCopyDatasetNm);
					addLayerThemeLabelVector(lgstrClipDatasetVector,mapId,lgstrCopyDatasetNm);
					addLayerThemeUniqueVector(vnaraPlgnCopyDatasetVector, mapId, vnaraPlgnCopyDatasetNm);
					addLayerSingleBandVector(vnaraPntCopyDatasetVector,mapId,vnaraPntCopyDatasetNm);
					LOGGER.info("Map에 데이터셋 추가 완료");
					vo = getSavePath(analId,downloadMidDir);
					vo.setOrignlFileNm("위치도");
					vo.setAnalType("위치도");
					vo.setMstId(Integer.valueOf(mstId));
					vo.setSldId(svyLabel);
					
					if(setMapLayoutControl("wkaVectorLocTemplate",mapId,newBound)) {
						vo = saveMapImage(vo);
						if(deleted) {
							deleteMap(mapId);
						}
					}
					lgstrClipDatasetVector.close();
				}else {
					LOGGER.error("레코드셋 정보가 없습니다.");
				}
				
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		return vo;
	}
	
	/**
	 * 취약지역 현황도
	 * @param schMap 조건값
	 * @param analId 분석ID
	 * @param statMap 현황도정보
	 * @return
	 * @throws Exception
	 */
	public AnalFileVO creatWkaLocStatMap(HashMap<String, Object> schMap,String analId,String statMap) throws Exception{
		//List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		
		String gId = schMap.get("gid").toString();
		String mstId = schMap.get("mstId").toString();
		String svyLabel = schMap.get("sldId").toString();
		String mapId = "Map_".concat(analId);
		
		String vnaraPntDatasetNm = "tf_feis_wka_vnarapnt";//포인트(유출구)
		String vnaraPlgnDatasetNm = "tf_feis_wka_vnaraplgn";//폴리곤(사방댐,계류보전,유역면적,산지사방)
		
		String vnaraPntCopyDatasetNm = "wpnt_".concat(analId);//포인트(유출구) 조회 데이터셋명
		String vnaraPlgnCopyDatasetNm = "wplgn_".concat(analId);//폴리곤(사방댐,계류보전,유역면적,산지사방) 조회 데이터셋명
		
		String statMapDatasetNm = "wstat_".concat(analId);
		
		DatasetVector vnaraPntCopyDatasetVector = null;
		DatasetVector vnaraPlgnCopyDatasetVector = null;
		DatasetVector statMapDatasetVector = null;
		
		String vnaraQuery = "gid = ".concat(gId);
		
		Rectangle2D newBound = null;
		
		try {
			//슈퍼맵 연결
			LOGGER.info("슈퍼맵 연결 시작 : ".concat(analId));
			getConnectionInfo(analId);
			LOGGER.info("슈퍼맵 연결 완료 : ".concat(analId));
			//smwu프로젝트에 Map 생성하기
			LOGGER.info("Map 생성 시작 : ".concat(analId));
			createNewMap(mapId,3857);
			LOGGER.info("Map 생성 완료 : ".concat(analId));
			
			//포인트 데이터셋에서 vnara_exmnn_id로 대상 조회
			LOGGER.info(vnaraPntDatasetNm+"데이터셋을 memory udb에 "+vnaraQuery+" 조건의 "+vnaraPntCopyDatasetNm+" 데이터셋으로 복사 : ".concat(analId));
			copyPggisToMemoryUdb(vnaraPntDatasetNm,vnaraPntCopyDatasetNm,vnaraQuery);
			LOGGER.info("데이터셋 복사 완료 : ".concat(analId));
			
			//폴리곤 데이터셋에서 vnara_exmnn_id로 대상 조회
			LOGGER.info(vnaraPlgnDatasetNm+"데이터셋을 memory udb에 "+vnaraQuery+" 조건의 "+vnaraPlgnCopyDatasetNm+" 데이터셋으로 복사 : ".concat(analId));
			copyPggisToMemoryUdb(vnaraPlgnDatasetNm,vnaraPlgnCopyDatasetNm,vnaraQuery);
			LOGGER.info("데이터셋 복사 완료 : ".concat(analId));
			
			vnaraPlgnCopyDatasetVector = (DatasetVector) mDatasets.get(vnaraPlgnCopyDatasetNm);
			vnaraPntCopyDatasetVector = (DatasetVector) mDatasets.get(vnaraPntCopyDatasetNm);
			
			//mDatasource.setPrjCoordSys(PrjCoordSys.fromEPSG(5186));
			//현황도 위치 데이터셋 생성
			LOGGER.info(statMapDatasetNm+"데이터셋을 생성 : ".concat(analId));
			createDataset("Point", statMapDatasetNm);
			LOGGER.info("데이터셋 생성 완료 : ".concat(analId));
			
			statMapDatasetVector = (DatasetVector) mDatasets.get(statMapDatasetNm);
			statMapDatasetVector.setPrjCoordSys(PrjCoordSys.fromEPSG(5186));
			Recordset statRecordset = statMapDatasetVector.query("",CursorType.DYNAMIC);
			
			//현황도 정보 json 변환
			JSONParser parser = new JSONParser();
			if(statMap != null) {
				Object obj = parser.parse(statMap);
				JSONArray jsonArray = (JSONArray) obj;
				
				for (int i = 0; i < jsonArray.size(); i++) {
					org.json.simple.JSONObject jsonObj = (org.json.simple.JSONObject)jsonArray.get(i);
					if(jsonObj.get("경도") != null && jsonObj.get("위도") != null) {
						String lon = jsonObj.get("경도").toString();
						String lat = jsonObj.get("위도").toString();
						
						double x = Double.parseDouble(lon);
						double y = Double.parseDouble(lat);
						
						Point2D pt2d = new Point2D(x,y);
						Geometry geom = new GeoPoint(pt2d);
						
						statRecordset.addNew(geom);
						statRecordset.update();
					}
				}
			}
			statRecordset.dispose();
			statRecordset.close();
			
			if(coordSysTranslator(vnaraPlgnCopyDatasetVector,3857) && coordSysTranslator(vnaraPntCopyDatasetVector,3857) && coordSysTranslator(statMapDatasetVector,3857)) {
				Recordset mRecordset = vnaraPlgnCopyDatasetVector.query("",CursorType.STATIC);
				
				if(mRecordset.getGeometry() != null) {
					Rectangle2D bound = mRecordset.getGeometry().getBounds();
					
					double wd = bound.getWidth()*1.5;
					
					newBound = new Rectangle2D();
					
					newBound.setTop(bound.getTop()+wd);
					newBound.setBottom(bound.getBottom()-wd);
					newBound.setLeft(bound.getLeft()-wd);
					newBound.setRight(bound.getRight()+wd);
					
					vDataset = vDatasets.get("VworldSatellite");
					
					LOGGER.info("Map에 데이터셋 추가 시작");
					addLayerImage(vDataset,mapId,"vworld");
					addLayerThemeUniqueVector(vnaraPlgnCopyDatasetVector, mapId, vnaraPlgnCopyDatasetNm);
					addLayerSingleBandVector(vnaraPntCopyDatasetVector,mapId,vnaraPntCopyDatasetNm);
					addLayerThemeUniqueVector(statMapDatasetVector, mapId, statMapDatasetNm);
					LOGGER.info("Map에 데이터셋 추가 완료");
					
					vo = getSavePath(analId,downloadMidDir);
					vo.setOrignlFileNm("현황도");
					vo.setAnalType("현황도");
					vo.setMstId(Integer.valueOf(mstId));
					vo.setSldId(svyLabel);
					
					if(setMapLayoutControl("wkaVectorLocTemplate",mapId,newBound)) {
						vo = saveMapImage(vo);
						if(deleted) {
							deleteMap(mapId);
						}
					}
				}else {
					LOGGER.info("vnaraPlgn 레코드셋 정보가 없습니다.");
				}
				
			}else {
				LOGGER.error("좌표변환에 실패하였습니다.");
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		return vo;
	}
	
	/**
	 * 취약지역 대피체계 satelliteTemplate
	 * @param schMap
	 * @param analId
	 * @return
	 * @throws Exception
	 */
	public AnalFileVO creatWkaLocExitMap(HashMap<String, Object> schMap,String analId) throws Exception{
		//List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		
		String gId = schMap.get("gid").toString();
		String mstId = schMap.get("mstId").toString();
		String svyLabel = schMap.get("sldId").toString();
		String mapId = "Map_".concat(analId);
		
		String vnaraPntDatasetNm = "tf_feis_wka_vnarapnt";//포인트(유출구)
		String vnaraPlgnDatasetNm = "tf_feis_wka_vnaraplgn";//폴리곤(사방댐,계류보전,유역면적,산지사방)
		String vnaraLneDatasetNm = "tf_feis_wka_vnaralne";//폴리라인(대피로)
		String vnaraPntCopyDatasetNm = "wpnt_".concat(analId);//포인트(유출구) 조회 데이터셋명
		String vnaraPlgnCopyDatasetNm = "wplgn_".concat(analId);//폴리곤(사방댐,계류보전,유역면적,산지사방) 조회 데이터셋명
		String vnaraLneCopyDatasetNm = "wlne_".concat(analId);//폴리라인(대피로) 조회 데이터셋명
		
		DatasetVector vnaraPntCopyDatasetVector = null;
		DatasetVector vnaraPlgnCopyDatasetVector = null;
		DatasetVector vnaraLneCopyDatasetVector = null;
		
		String vnaraQuery = "gid = ".concat(gId);
		
		Rectangle2D newBound = null;
		
		try {
			//슈퍼맵 연결
			LOGGER.info("슈퍼맵 연결 시작 : ".concat(analId));
			getConnectionInfo(analId);
			LOGGER.info("슈퍼맵 연결 완료 : ".concat(analId));
			//smwu프로젝트에 Map 생성하기
			LOGGER.info("Map 생성 시작 : ".concat(analId));
			createNewMap(mapId,3857);
			LOGGER.info("Map 생성 완료 : ".concat(analId));
			
			//포인트 데이터셋에서 vnara_exmnn_id로 대상 조회
			LOGGER.info(vnaraPntDatasetNm+"데이터셋을 memory udb에 "+vnaraQuery+" 조건의 "+vnaraPntCopyDatasetNm+" 데이터셋으로 복사 : ".concat(analId));
			copyPggisToMemoryUdb(vnaraPntDatasetNm,vnaraPntCopyDatasetNm,vnaraQuery);
			LOGGER.info("데이터셋 복사 완료 : ".concat(analId));
			
			//폴리곤 데이터셋에서 vnara_exmnn_id로 대상 조회
			LOGGER.info(vnaraPlgnDatasetNm+"데이터셋을 memory udb에 "+vnaraQuery+" 조건의 "+vnaraPlgnCopyDatasetNm+" 데이터셋으로 복사 : ".concat(analId));
			copyPggisToMemoryUdb(vnaraPlgnDatasetNm,vnaraPlgnCopyDatasetNm,vnaraQuery);
			LOGGER.info("데이터셋 복사 완료 : ".concat(analId));
			
			//폴리라인 데이터셋에서 vnara_exmnn_id로 대상 조회
			LOGGER.info(vnaraLneDatasetNm+"데이터셋을 memory udb에 "+vnaraQuery+" 조건의 "+vnaraLneCopyDatasetNm+" 데이터셋으로 복사 : ".concat(analId));
			copyPggisToMemoryUdb(vnaraLneDatasetNm,vnaraLneCopyDatasetNm,vnaraQuery);
			LOGGER.info("데이터셋 복사 완료 : ".concat(analId));
			
			vnaraPlgnCopyDatasetVector = (DatasetVector) mDatasets.get(vnaraPlgnCopyDatasetNm);
			vnaraPntCopyDatasetVector = (DatasetVector) mDatasets.get(vnaraPntCopyDatasetNm);
			vnaraLneCopyDatasetVector = (DatasetVector) mDatasets.get(vnaraLneCopyDatasetNm);
			
			if(coordSysTranslator(vnaraPlgnCopyDatasetVector,3857) && coordSysTranslator(vnaraPntCopyDatasetVector,3857) && coordSysTranslator(vnaraLneCopyDatasetVector,3857)) {
				Recordset mRecordset = vnaraLneCopyDatasetVector.query("",CursorType.STATIC);
				
				if(mRecordset.getGeometry() != null) {
					Rectangle2D bound = mRecordset.getGeometry().getBounds();
					//Rectangle2D bound1 = mRecordset.getBounds();
					//레코드수가 2개이상일 경우 
					if(mRecordset.getRecordCount() > 1) {
						
					}
					
					//2023-07-05 : 라인 공간정보를 한 위치에 입력한 값이 들어올 경우 템플릿 영역설정 시 오류가 발생하면서 메모리가 100% 치는 증상으로 인해 지오메트리 바운드 값을 비교하여 동일할 경우 제외
					double lr = Math.abs(bound.getLeft() - bound.getRight());
					double tb = Math.abs(bound.getBottom() - bound.getTop());
					
					if(lr > 0.1 && tb > 0.1) {
						double wd = bound.getWidth()*1.5;
						//height 값이랑 비교해서 큰값으로  :::승현
						newBound = new Rectangle2D();
						
						newBound.setTop(bound.getTop()+wd);
						newBound.setBottom(bound.getBottom()-wd);
						newBound.setLeft(bound.getLeft()-wd);
						newBound.setRight(bound.getRight()+wd);
						
						vDataset = vDatasets.get("VworldSatellite");
						
						LOGGER.info("Map에 데이터셋 추가 시작");
						addLayerImage(vDataset,mapId,"vworld");
						addLayerThemeUniqueVector(vnaraPlgnCopyDatasetVector, mapId, vnaraPlgnCopyDatasetNm);
						addLayerSingleBandVector(vnaraLneCopyDatasetVector,mapId,vnaraLneCopyDatasetNm);
						addLayerSingleBandVector(vnaraPntCopyDatasetVector,mapId,vnaraPntCopyDatasetNm);
						LOGGER.info("Map에 데이터셋 추가 완료");
						
						vo = getSavePath(analId,downloadMidDir);
						vo.setOrignlFileNm("대피체계");
						vo.setAnalType("대피체계");
						vo.setMstId(Integer.valueOf(mstId));
						vo.setSldId(svyLabel);
						
						if(setMapLayoutControl("wkaVectorLocTemplate",mapId,newBound)) {
							vo = saveMapImage(vo);
						}
					}
					
					if(deleted) {
						deleteMap(mapId);
					}
					
				}else {
					LOGGER.error("레코드셋 정보가 없습니다.");
				}
				
			}else {
				LOGGER.error("좌표변환에 실패하였습니다.");
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		return vo;
	}
	
	/**
	 * 취약지역해제조사 현황도
	 * @param schMap
	 * @param analId
	 * @return
	 * @throws Exception
	 */
	public AnalFileVO creatCnlLocExitMap(HashMap<String, Object> schMap,String analId) throws Exception{
		//List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		
		String gId = schMap.get("gid").toString();
		String mstId = schMap.get("mstId").toString();
		String svyLabel = schMap.get("sldId").toString();
		String mapId = "Map_".concat(analId);
		
		String vnaraPntDatasetNm = "tf_feis_cnl_vnarapnt";//포인트(유출구)
		String vnaraPlgnDatasetNm = "tf_feis_cnl_vnaraplgn";//폴리곤(사방댐,계류보전,유역면적,산지사방)
		String vnaraLneDatasetNm = "tf_feis_cnl_vnaralne";//폴리라인(대피로)
		String vnaraPntCopyDatasetNm = "wpnt_".concat(analId);//포인트(유출구) 조회 데이터셋명
		String vnaraPlgnCopyDatasetNm = "wplgn_".concat(analId);//폴리곤(사방댐,계류보전,유역면적,산지사방) 조회 데이터셋명
		String vnaraLneCopyDatasetNm = "wlne_".concat(analId);//폴리라인(대피로) 조회 데이터셋명
		
		DatasetVector vnaraPntCopyDatasetVector = null;
		DatasetVector vnaraPlgnCopyDatasetVector = null;
		DatasetVector vnaraLneCopyDatasetVector = null;
		
		String vnaraQuery = "gid = ".concat(gId);
		
		Rectangle2D newBound = null;
		
		try {
			//슈퍼맵 연결
			LOGGER.info("슈퍼맵 연결 시작 : ".concat(analId));
			getConnectionInfo(analId);
			LOGGER.info("슈퍼맵 연결 완료 : ".concat(analId));
			//smwu프로젝트에 Map 생성하기
			LOGGER.info("Map 생성 시작 : ".concat(analId));
			createNewMap(mapId,3857);
			LOGGER.info("Map 생성 완료 : ".concat(analId));
			
			//포인트 데이터셋에서 vnara_exmnn_id로 대상 조회
			LOGGER.info(vnaraPntDatasetNm+"데이터셋을 memory udb에 "+vnaraQuery+" 조건의 "+vnaraPntCopyDatasetNm+" 데이터셋으로 복사 : ".concat(analId));
			copyPggisToMemoryUdb(vnaraPntDatasetNm,vnaraPntCopyDatasetNm,vnaraQuery);
			LOGGER.info("데이터셋 복사 완료 : ".concat(analId));
			
			//폴리곤 데이터셋에서 vnara_exmnn_id로 대상 조회
			LOGGER.info(vnaraPlgnDatasetNm+"데이터셋을 memory udb에 "+vnaraQuery+" 조건의 "+vnaraPlgnCopyDatasetNm+" 데이터셋으로 복사 : ".concat(analId));
			copyPggisToMemoryUdb(vnaraPlgnDatasetNm,vnaraPlgnCopyDatasetNm,vnaraQuery);
			LOGGER.info("데이터셋 복사 완료 : ".concat(analId));
			
			//폴리라인 데이터셋에서 vnara_exmnn_id로 대상 조회
			LOGGER.info(vnaraLneDatasetNm+"데이터셋을 memory udb에 "+vnaraQuery+" 조건의 "+vnaraLneCopyDatasetNm+" 데이터셋으로 복사 : ".concat(analId));
			copyPggisToMemoryUdb(vnaraLneDatasetNm,vnaraLneCopyDatasetNm,vnaraQuery);
			LOGGER.info("데이터셋 복사 완료 : ".concat(analId));
			
			vnaraPlgnCopyDatasetVector = (DatasetVector) mDatasets.get(vnaraPlgnCopyDatasetNm);
			vnaraPntCopyDatasetVector = (DatasetVector) mDatasets.get(vnaraPntCopyDatasetNm);
			vnaraLneCopyDatasetVector = (DatasetVector) mDatasets.get(vnaraLneCopyDatasetNm);
			
			if(vnaraLneCopyDatasetVector.getRecordCount() > 0) {
				coordSysTranslator(vnaraLneCopyDatasetVector,3857);
			}
			if(coordSysTranslator(vnaraPlgnCopyDatasetVector,3857) && coordSysTranslator(vnaraPntCopyDatasetVector,3857)) {
				
				Recordset mRecordset = vnaraPlgnCopyDatasetVector.query("",CursorType.STATIC);
				
				Rectangle2D bound = mRecordset.getGeometry().getBounds();
				
				double wd = bound.getWidth()*1.5;
				
				newBound = new Rectangle2D();
				
				newBound.setTop(bound.getTop()+wd);
				newBound.setBottom(bound.getBottom()-wd);
				newBound.setLeft(bound.getLeft()-wd);
				newBound.setRight(bound.getRight()+wd);
				
				vDataset = vDatasets.get("VworldSatellite");
				
				LOGGER.info("Map에 데이터셋 추가 시작");
				addLayerImage(vDataset,mapId,"vworld");
				addLayerThemeUniqueVector(vnaraPlgnCopyDatasetVector, mapId, vnaraPlgnCopyDatasetNm);
				
				if(vnaraLneCopyDatasetVector.getRecordCount() > 0) {
					addLayerSingleBandVector(vnaraLneCopyDatasetVector,mapId,vnaraLneCopyDatasetNm);
				}
				addLayerSingleBandVector(vnaraPntCopyDatasetVector,mapId,vnaraPntCopyDatasetNm);
				LOGGER.info("Map에 데이터셋 추가 완료");
				
				vo = getSavePath(analId,downloadMidDir);
				vo.setOrignlFileNm("대피체계");
				vo.setAnalType("대피체계");
				vo.setMstId(Integer.valueOf(mstId));
				vo.setSldId(svyLabel);
				
				if(setMapLayoutControl("satelliteTemplate",mapId,newBound)) {
					vo = saveMapImage(vo);
					if(deleted) {
						deleteMap(mapId);
					}
				}
			}else {
				LOGGER.error("좌표변환에 실패하였습니다.");
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		return vo;
	}
	//---------------------------------------------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------------------------------------------
	
	/**
	 * 유역분석(WaterShed)
	 * @throws Exception
	 */
	public AnalFileVO waterShedTest(double x, double y, String lgstrCd, Map<String, Object> attr) throws Exception{
		AnalFileVO vo = null;
		//DatasetGrid grid = null;
		String analId = attr.get("anal_id").toString();
		String sdCd = lgstrCd.substring(0, 2);
		
		String directionGridNm = "tf_feis_flowdirection_".concat(sdCd);
		String watershedRaseterNm = "watershed".concat("_raster_").concat(analId);
		String watershedPolygonNm = "watershed".concat("_polygon_").concat(analId);
		String watershedPointNm = "watershed".concat("_point_").concat(analId);
		//String outputPath = "";
		try {
			getConnectionInfo(analId);
			
			DatasetGrid directionGrid = (DatasetGrid)uDatasource.getDatasets().get(directionGridNm);//flow_direction은 feis udbx에서 가져오기
			Point2Ds point2ds = new Point2Ds();
			Point2D point2d = new Point2D(x,y);
			
			point2ds.add(point2d);
			
			HydrologyAnalyst.watershed(directionGrid, point2ds, uDatasource, watershedRaseterNm);
			
			//uRasterToVector(watershedRaseterNm,watershedPolygonNm,"tf_feis_watershed",attr);
			if(uDatasets.contains(watershedRaseterNm)) {
				Dataset sourceDs = (Dataset) uDatasets.get(watershedRaseterNm);
				
				ConversionAnalystParameter parameter = new ConversionAnalystParameter();
				parameter.setSourceDataset(sourceDs);
				parameter.setTargetDatasource(uDatasource);
				parameter.setTargetDatasetName(watershedPolygonNm);
				parameter.setSmoothDegree(40);
				parameter.setNoValue(0);
				parameter.setSmoothMethod(SmoothMethod.BSPLINE);
				parameter.setTargetDatasetType(DatasetType.REGION);
				parameter.setValueFieldName("value");
				
				DatasetVector mDataset = ConversionAnalyst.rasterToVector(parameter);
				mDataset.smooth(40, false);
				
			}else {
				LOGGER.error("rasterToVector Data가 존재하지 않습니다.");
				//return null;
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		
		return vo;
	}
	
	/**
	 * 유역분석(WaterShed)
	 * @throws Exception
	 */
	public AnalFileVO waterShedProcessing(double x, double y, String lgstrCd, Map<String, Object> attr) throws Exception{
		LOGGER.info("유역분석 시작");
		AnalFileVO vo = null;
		//DatasetGrid grid = null;
		String analId = attr.get("anal_id").toString();
		String sdCd = lgstrCd.substring(0, 2);
		
		String directionGridNm = "tf_feis_flowdirection_".concat(sdCd);
		String watershedRaseterNm = "watershed".concat("_raster_").concat(analId);
		String watershedPolygonNm = "watershed".concat("_polygon_").concat(analId);
		String watershedPointNm = "watershed".concat("_point_").concat(analId);
		//String outputPath = "";
		try {
			getConnectionInfo(analId);
			
			DatasetGrid directionGrid = (DatasetGrid)uDatasource.getDatasets().get(directionGridNm);//flow_direction은 feis udbx에서 가져오기
			Point2Ds point2ds = new Point2Ds();
			Point2D point2d = new Point2D(x,y);
			
			point2ds.add(point2d);
			
			HydrologyAnalyst.watershed(directionGrid, point2ds, mDatasource, watershedRaseterNm);
//			HydrologyAnalyst.watershed(directionGrid, point2ds, uDatasource, watershedRaseterNm);
			
			addRecordset(new GeoPoint(point2d),attr,"tf_feis_ecrtcnl");
			
			mRasterToVector(watershedRaseterNm,watershedPolygonNm,"tf_feis_watershed",attr);
//			uRasterToVector(watershedRaseterNm,watershedPolygonNm,"tf_feis_watershed",attr);
			
			String ecrtcnlQuery = "anal_id = '".concat(attr.get("anal_id").toString()).concat("'");
			
			copyPggisToMemoryUdb("tf_feis_ecrtcnl",watershedPointNm,ecrtcnlQuery);
//			copyPggisToUdb("tf_feis_ecrtcnl",watershedPointNm,ecrtcnlQuery);
			
			vo = getSavePath(analId,downloadMidDir);
			vo.setOrignlFileNm("유역분석");
			vo.setAnalType("유역분석");
			vo.setMstId(Integer.valueOf(attr.get("mst_id").toString()));
			vo.setSldId(attr.get("sld_id").toString());
			vo.setCreatUser(attr.get("creat_user").toString());
			vo.setFileExtsn("zip");
			//레스터데이터는 삭제
//			if(deleted && uDatasets.contains(watershedRaseterNm)) {
//				uDatasets.delete(watershedRaseterNm);
//			}
			
			mExportUdbToFile(watershedPolygonNm, vo, "shp");
			mExportUdbToFile(watershedPointNm, vo, "shp");
//			uExportUdbToFile(watershedPolygonNm, vo, "shp");
//			uExportUdbToFile(watershedPointNm, vo, "shp");
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		
		return vo;
	}
	
	/**
	 * 래스터를 벡터로 변환(memory udb)
	 * @param sourceDataset
	 * @param targetDatasetName
	 * @throws Exception
	 */
	public void mRasterToVector(String sourceDataset, String targetDatasetName, String saveDatasetName, Map<String, Object> saveAttr) throws Exception{
		try {
			Dataset sourceDs = null;
			double area = 0.0;
			int position = 0;
			int checkCnt = 0;
			if(mDatasets.contains(sourceDataset)) {
				sourceDs = (Dataset) mDatasets.get(sourceDataset);
				
				ConversionAnalystParameter parameter = new ConversionAnalystParameter();
				parameter.setSourceDataset(sourceDs);
				parameter.setTargetDatasource(mDatasource);
				parameter.setTargetDatasetName(targetDatasetName);
				parameter.setSmoothDegree(40);
				parameter.setNoValue(-9999.0);
				parameter.setSpecifiedValue(1);
				parameter.setSmoothMethod(SmoothMethod.BSPLINE);
				parameter.setTargetDatasetType(DatasetType.REGION);
				parameter.setValueFieldName("value");
				
				DatasetVector mDataset = ConversionAnalyst.rasterToVector(parameter);
				mDataset.smooth(40, false);
				
				Recordset mRecordset = mDataset.getRecordset(false, CursorType.DYNAMIC);
				
				if(mRecordset.getRecordCount() > 0) {
					if(mRecordset.getRecordCount() > 1) {
						mRecordset.moveFirst();
						
						while(!mRecordset.isEOF()) {
							GeoRegion region = (GeoRegion) mRecordset.getGeometry();
							System.out.println(region.getArea());
							
							if(area < region.getArea()) {
								area = region.getArea();
								position = checkCnt;
							}
							checkCnt++;
							mRecordset.moveNext();
						}
					}
					mRecordset.moveTo(position);
					copyUdbToPggisRcordset(mRecordset,saveDatasetName,saveAttr);
				}
				
//				mRecordset.close();
				mDataset.close();
			}else {
				LOGGER.error("rasterToVector Data가 존재하지 않습니다.");
				//return null;
			}
			
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} 
	}
	
	/**
	 * 래스터를 벡터로 변환(udb)
	 * @param sourceDataset
	 * @param targetDatasetName
	 * @throws Exception
	 */
	public void uRasterToVector(String sourceDataset, String targetDatasetName, String saveDatasetName, Map<String, Object> saveAttr) throws Exception{
		try {
			Dataset sourceDs = null;
			
			if(uDatasets.contains(sourceDataset)) {
				sourceDs = (Dataset) uDatasets.get(sourceDataset);
				
				ConversionAnalystParameter parameter = new ConversionAnalystParameter();
				parameter.setSourceDataset(sourceDs);
				parameter.setTargetDatasource(uDatasource);
				parameter.setTargetDatasetName(targetDatasetName);
				parameter.setSmoothDegree(40);
				parameter.setNoValue(-9999.0);
				parameter.setSpecifiedValue(1);
				parameter.setSmoothMethod(SmoothMethod.BSPLINE);
				parameter.setTargetDatasetType(DatasetType.REGION);
				parameter.setValueFieldName("value");
				
				DatasetVector uDataset = ConversionAnalyst.rasterToVector(parameter);
				uDataset.smooth(40, false);
				
				Recordset uRecordset = uDataset.getRecordset(false, CursorType.STATIC);
				
				if(uRecordset.getRecordCount() > 0) {
					copyUdbToPggisRcordset(uRecordset,saveDatasetName,saveAttr);
				}
			}else {
				LOGGER.error("rasterToVector Data가 존재하지 않습니다.");
				//return null;
			}
			
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} 
	}
	
	/**
	 * 대상지 위치도 생성
	 * @throws Exception
	 */
	public List<AnalFileVO> createLocationImg(String mstId,String sldId,String analId) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		//String saveImgNm = null;
		String mapId = "Map_".concat(analId);
		String ecrtcnlDatasetNm = getLayerName("ecrtcnl");//"tf_feis_ecrtcnl";
		String watershedDatasetNm = getLayerName("watershed");//"tf_feis_watershed";
		String lgstrDatasetNm = getLayerName("lgstr");
		String watershedQuery = "mst_id = ".concat(mstId).concat(" and sld_id = '").concat(sldId).concat("' and anal_id = '").concat(analId).concat("'");
		String ecrtcnlCopyDatasetNm = "ecrtcnl_".concat(analId);
		String watershedCopyDatasetNm = "watershed_".concat(analId);
		String lgstrCopyDatasetNm = "lgstr_".concat(analId);
		
		DatasetVector ecrtcnlCopyDatastVector = null;
		DatasetVector watershedCopyDatasetVector = null;
		DatasetVector lgstrClipDatasetVector = null;
		
		Rectangle2D newBound = null;
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapId,5186);
			
			//유출구 데이터 DB에서 UDB로 복사
			copyPggisToMemoryUdb(ecrtcnlDatasetNm,ecrtcnlCopyDatasetNm,watershedQuery);
			//copyPggisToUdb(ecrtcnlDatasetNm,ecrtcnlCopyDatasetNm,watershedQuery);
			
			//유역분석 결과 벡터레이어 DB에서 UDB로 복사
			copyPggisToMemoryUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			//copyPggisToUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			
			//지적데이터셋 자르기
			if(mDatasets.contains(watershedCopyDatasetNm)) {
				
				watershedCopyDatasetVector = (DatasetVector) mDatasets.get(watershedCopyDatasetNm);
				Recordset mRecordset = watershedCopyDatasetVector.query("",CursorType.STATIC);
				
				Rectangle2D bound = mRecordset.getGeometry().getBounds();
				newBound = new Rectangle2D();
				//클립할 영역 설정(이미지 영역보다 조금 더 많이 자름)
				newBound.setTop(bound.getTop()+1000);
				newBound.setBottom(bound.getBottom()-1000);
				newBound.setLeft(bound.getLeft()-1000);
				newBound.setRight(bound.getRight()+1000);
				
				GeoRectangle geoRect = new GeoRectangle(newBound, 0);
				GeoRegion region = geoRect.convertToRegion();

				mRecordset.dispose();
				
				lgstrClipDatasetVector = VectorClip.clipDatasetVector((DatasetVector)datasource.getDatasets().get(lgstrDatasetNm), region, true, false, mDatasource, lgstrCopyDatasetNm);
				
				//이미지 영역설정
				newBound.setTop(bound.getTop()+100);
				newBound.setBottom(bound.getBottom()-100);
				newBound.setLeft(bound.getLeft()-100);
				newBound.setRight(bound.getRight()+100);
			}
			
			ecrtcnlCopyDatastVector = (DatasetVector) mDatasets.get(ecrtcnlCopyDatasetNm);
			
			addLayerSingleBandVector(lgstrClipDatasetVector,mapId,lgstrCopyDatasetNm);
			addLayerThemeLabelVector(lgstrClipDatasetVector,mapId,lgstrCopyDatasetNm);
			addLayerSingleBandVector(watershedCopyDatasetVector,mapId,watershedCopyDatasetNm);
			addLayerSingleBandVector(ecrtcnlCopyDatastVector,mapId,ecrtcnlCopyDatasetNm);
			
			vo = getSavePath(analId,downloadMidDir);
			vo.setOrignlFileNm("위치도");
			vo.setAnalType("위치도");
			vo.setMstId(Integer.valueOf(mstId));
			vo.setSldId(sldId);
			//vo.setCreatUser(attr.get("creat_user").toString());
			//vo.setFileExtsn("zip");
			
			if(setMapLayoutControl("locTemplate",mapId,newBound)) {
				//saveImgNm = saveMapImage();
				AnalFileVO imgVo = saveMapImageToJpg(vo);//saveMapImage(vo);
				list.add(imgVo);
				
//				if(deleted) {
//					deleteMap(mapId);
//				}
			}
			
			lgstrClipDatasetVector.close();
			watershedCopyDatasetVector.close();
			ecrtcnlCopyDatastVector.close();
			
			mExportUdbToFile(lgstrCopyDatasetNm, vo, "shp");
			mExportUdbToFile(watershedCopyDatasetNm, vo, "shp");
			mExportUdbToFile(ecrtcnlCopyDatasetNm, vo, "shp");
			
			vo.setFileExtsn("zip");
			list.add(vo);
			//"D:\\home\\tomcat\\FEIStorage\\analysis\\20220923\\D9CB988E19CA428FB5AB3C6FFFFD3EB9.png";//
			//String type = "shp";
			//HashMap<String, FileType> hash = manage.getFileType(type);
			//manage.exportDataset(vTest, type, hash);
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		return list;
	}
	
	/**
	 * 사방사업 타당성평가 대상지 위치
	 * @param mstId
	 * @param sldId
	 * @param analId
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createEcbSldLocationImg(String mstId,String sldId,String analId) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		//String saveImgNm = null;
		String mapId = "Map_".concat(analId);
		String ecrtcnlDatasetNm = getLayerName("ecrtcnl");//"tf_feis_ecrtcnl";
		String watershedDatasetNm = getLayerName("watershed");//"tf_feis_watershed";
		String lgstrDatasetNm = getLayerName("lgstr");//지적
		String demDatasetNm = getLayerName("dem");//dem
		String hillshadeDatasetNm = getLayerName("hillshade");//hillshade
		String ctrlnDatasetNm = getLayerName("ctrln");//hillshade
		
		String watershedQuery = "mst_id = ".concat(mstId).concat(" and sld_id = '").concat(sldId).concat("' and anal_id = '").concat(analId).concat("'");
		String ecrtcnlCopyDatasetNm = "ecrtcnl_".concat(analId);
		String watershedCopyDatasetNm = "watershed_".concat(analId);
		String lgstrCopyDatasetNm = "ecb_lgstr_".concat(analId);
		String demCopyDatasetNm = "sdem_".concat(analId);
		String hillshadeCopyDatasetNm = "hillshade_".concat(analId);
		String ctrlnCopyDatasetNm = "ecb_ctrln_".concat(analId);
		
		DatasetVector ecrtcnlCopyDatastVector = null;
		DatasetVector watershedCopyDatasetVector = null;
		DatasetVector lgstrClipDatasetVector = null;
		DatasetVector ctrlnClipDatasetVector = null;
		Dataset demClipDataset = null;
		Dataset hillshadeClipDataset = null;
		
		Rectangle2D newBound = null;
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapId,5186);
			
			//유출구 데이터 DB에서 UDB로 복사
			copyPggisToMemoryUdb(ecrtcnlDatasetNm,ecrtcnlCopyDatasetNm,watershedQuery);
			//copyPggisToUdb(ecrtcnlDatasetNm,ecrtcnlCopyDatasetNm,watershedQuery);
			
			//유역분석 결과 벡터레이어 DB에서 UDB로 복사
			copyPggisToMemoryUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			//copyPggisToUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			
			//지적데이터셋 자르기
			if(mDatasets.contains(watershedCopyDatasetNm)) {
				
				watershedCopyDatasetVector = (DatasetVector) mDatasets.get(watershedCopyDatasetNm);
				Recordset mRecordset = watershedCopyDatasetVector.query("",CursorType.STATIC);
				
				double addLen = 0.0;
				Rectangle2D bound = mRecordset.getGeometry().getBounds();
				
				boolean checkLen = bound.getWidth() > bound.getHeight() ? true : false;
				double maxlength = checkLen ? bound.getWidth()*0.1 : bound.getHeight()*0.1;
				
				if(checkLen) {
					addLen = (bound.getWidth() - bound.getHeight())/2;
				}else {
					addLen = (bound.getHeight() - bound.getWidth())/2;
				}
				
				newBound = new Rectangle2D();
				//클립할 영역 설정(이미지 영역보다 조금 더 많이 자름)
				newBound.setTop((checkLen ? bound.getTop()+addLen : bound.getTop())+1000);
				newBound.setBottom((checkLen ? bound.getBottom()-addLen : bound.getBottom())-1000);
				newBound.setLeft((checkLen ? bound.getLeft() : bound.getLeft()-addLen)-1000);
				newBound.setRight((checkLen ? bound.getRight() : bound.getRight()+addLen)+1000);
				
				GeoRectangle geoRect = new GeoRectangle(newBound, 0);
				GeoRegion region = geoRect.convertToRegion();

				mRecordset.dispose();
				
				lgstrClipDatasetVector = VectorClip.clipDatasetVector((DatasetVector)datasource.getDatasets().get(lgstrDatasetNm), region, true, false, mDatasource, lgstrCopyDatasetNm);
				ctrlnClipDatasetVector = VectorClip.clipDatasetVector((DatasetVector)datasource.getDatasets().get(ctrlnDatasetNm), region, true, false, mDatasource, ctrlnCopyDatasetNm);
				demClipDataset = RasterClip.clip((DatasetGrid)datasource.getDatasets().get(demDatasetNm),region, true, false, mDatasource, demCopyDatasetNm);
				hillshadeClipDataset = RasterClip.clip((DatasetGrid)datasource.getDatasets().get(hillshadeDatasetNm),region, true, false, mDatasource, hillshadeCopyDatasetNm);
				
				//이미지 영역설정
				newBound = new Rectangle2D();
				newBound.setTop(bound.getTop()+maxlength);
				newBound.setBottom(bound.getBottom()-maxlength);
				newBound.setLeft(bound.getLeft()-maxlength);
				newBound.setRight(bound.getRight()+maxlength);
			}
			
			ecrtcnlCopyDatastVector = (DatasetVector) mDatasets.get(ecrtcnlCopyDatasetNm);
			
			addLayerSingleBandGrid(demClipDataset, mapId, demCopyDatasetNm);
			addLayerSingleBandGrid(hillshadeClipDataset, mapId, hillshadeCopyDatasetNm);
			addLayerSingleBandVector(ctrlnClipDatasetVector,mapId,ctrlnCopyDatasetNm);
			addLayerSingleBandVector(lgstrClipDatasetVector,mapId,lgstrCopyDatasetNm);
			addLayerThemeLabelVector(lgstrClipDatasetVector,mapId,lgstrCopyDatasetNm);
			addLayerSingleBandVector(watershedCopyDatasetVector,mapId,watershedCopyDatasetNm);
			addLayerSingleBandVector(ecrtcnlCopyDatastVector,mapId,ecrtcnlCopyDatasetNm);
			
			vo = getSavePath(analId,downloadMidDir);
			vo.setOrignlFileNm("위치도");
			vo.setAnalType("위치도");
			vo.setMstId(Integer.valueOf(mstId));
			vo.setSldId(sldId);
			//vo.setCreatUser(attr.get("creat_user").toString());
			//vo.setFileExtsn("zip");
			
			if(setMapLayoutControl("locTemplate",mapId,newBound)) {
				AnalFileVO imgVo = saveMapImageToJpg(vo);//saveMapImage(vo);
				list.add(imgVo);
				
//				if(deleted) {
//					deleteMap(mapId);
//				}
			}
			demClipDataset.close();
			hillshadeClipDataset.close();
			lgstrClipDatasetVector.close();
			watershedCopyDatasetVector.close();
			ecrtcnlCopyDatastVector.close();
			
			mExportUdbToFile(demCopyDatasetNm, vo, "tif");
			mExportUdbToFile(hillshadeCopyDatasetNm, vo, "tif");
			mExportUdbToFile(ctrlnCopyDatasetNm, vo, "shp");
			mExportUdbToFile(lgstrCopyDatasetNm, vo, "shp");
			mExportUdbToFile(watershedCopyDatasetNm, vo, "shp");
			mExportUdbToFile(ecrtcnlCopyDatasetNm, vo, "shp");
			
			vo.setFileExtsn("zip");
			list.add(vo);
			//"D:\\home\\tomcat\\FEIStorage\\analysis\\20220923\\D9CB988E19CA428FB5AB3C6FFFFD3EB9.png";//
			//String type = "shp";
			//HashMap<String, FileType> hash = manage.getFileType(type);
			//manage.exportDataset(vTest, type, hash);
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		return list;
	}
	
	/**
	 * 사방사업 타당성평가 대상지 항공사진
	 * @param mstId
	 * @param sldId
	 * @param analId
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createEcbSldLocationSatImg(String mstId,String sldId,String analId) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		
		String mapId = "Map_sat_".concat(analId);
		String watershedDatasetNm = getLayerName("watershed");//"tf_feis_watershed";
		String watershedQuery = "mst_id = ".concat(mstId).concat(" and sld_id = '").concat(sldId).concat("' and anal_id = '").concat(analId).concat("'");
		String watershedCopyDatasetNm = "watershed_".concat(analId);
		//String boundaryDatasetNm = "boundary_".concat(analId);
		
		DatasetVector watershedCopyDatasetVector = null;
		//DatasetVector boundaryDatasetVector = null;
		//GeoRegion region = null;
		
		Rectangle2D newBound = null;
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapId,3857);
			
			//유역분석 결과 벡터레이어 DB에서 UDB로 복사
			copyPggisToMemoryUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			//copyPggisToUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			
			//데이터셋 자르기
			if(mDatasets.contains(watershedCopyDatasetNm)) {
				watershedCopyDatasetVector = (DatasetVector) mDatasets.get(watershedCopyDatasetNm);
			}
			
			if(coordSysTranslator(watershedCopyDatasetVector,3857)) {
				
				Recordset mRecordset = watershedCopyDatasetVector.query("",CursorType.STATIC);
				//uRecordset = clipDatasetVector.query("",CursorType.STATIC);
				
				Rectangle2D bound = mRecordset.getGeometry().getBounds();
				
				boolean checkLen = bound.getWidth() > bound.getHeight() ? true : false;
				double maxlength = checkLen ? bound.getWidth()*0.1 : bound.getHeight()*0.1;
				
				newBound = new Rectangle2D();

				newBound.setTop(bound.getTop()+maxlength);
				newBound.setBottom(bound.getBottom()-maxlength);
				newBound.setLeft(bound.getLeft()-maxlength);
				newBound.setRight(bound.getRight()+maxlength);
				
				mRecordset.dispose();
				
//				if(deleted) {
//					uDatasets.delete(watershedCopyDatasetNm);
//				}
				
				vDataset = vDatasets.get("VworldSatellite");
				
				addLayerImage(vDataset,mapId,"vworld");
				addLayerSingleBandVector(watershedCopyDatasetVector,mapId,watershedCopyDatasetNm);
				
				vo = getSavePath(analId,downloadMidDir);
				vo.setOrignlFileNm("위치도(영상)");
				vo.setAnalType("위치도(영상)");
				vo.setMstId(Integer.valueOf(mstId));
				vo.setSldId(sldId);
				
				if(setMapLayoutControl("locTemplate",mapId,newBound)) {
					AnalFileVO imgVo = saveMapImageToJpg(vo);//saveMapImage(vo);
					list.add(imgVo);
					
					if(deleted) {
						deleteMap(mapId);
					}
				}
				watershedCopyDatasetVector.close();
				
				mExportUdbToFile(watershedCopyDatasetNm, vo, "shp");
				
				vo.setFileExtsn("zip");
				list.add(vo);
			}else {
				LOGGER.error("좌표변환에 실패하였습니다.");
			}
			
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		
		return list;
	}
	
	/**
	 * 사방사업 타당성평가 분석사진
	 * @param mstId
	 * @param sldId
	 * @param analId
	 * @param captionNm
	 * @param mapStyle
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createEcbClipImg(String mstId,String sldId,String analId, String captionNm, String mapStyle) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		
		String mapId = "Map_".concat(captionNm).concat("_"+analId);
		String watershedDatasetNm = getLayerName("watershed");//"tf_feis_watershed";
		String hillshadeDatasetNm = getLayerName("hillshade");//hillshade
		String clipDatasetNm = getLayerName(captionNm);
		String templateNm = getLayoutTemplateNm(captionNm);
		
		String watershedQuery = "mst_id = ".concat(mstId).concat(" and sld_id = '").concat(sldId).concat("' and anal_id = '").concat(analId).concat("'");
		
		String watershedCopyDatasetNm = "watershed_".concat(analId);
		String clipCopyDatasetNm = captionNm.concat("_"+analId);
		String hillshadeCopyDatasetNm = "hillshade_".concat(analId);
		
		JSONObject statisticMap = null;
		
		DatasetVector watershedCopyDatasetVector = null;
		Dataset clipDataset = null;
		Dataset hillshadeClipDataset = null;
		
		DatasetType clipType = null;
		GeoRegion region = null;
		
		Rectangle2D bound = null;
		
		vo = getSavePath(analId,downloadMidDir);
		vo.setOrignlFileNm(captionNm);
		vo.setAnalType(captionNm);
		vo.setMstId(Integer.valueOf(mstId));
		vo.setSldId(sldId);
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapId,5186);
			
			//유역분석 결과 벡터레이어 DB에서 UDB로 복사
			copyPggisToMemoryUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			//copyPggisToUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			
			//데이터셋 자르기
			if(mDatasets.contains(watershedCopyDatasetNm)) {
				watershedCopyDatasetVector = (DatasetVector) mDatasets.get(watershedCopyDatasetNm);
				Recordset mRecordset = watershedCopyDatasetVector.query("",CursorType.STATIC);
				
				bound = mRecordset.getGeometry().getBounds();
				
				region = new GeoRegion();
				
				while (!mRecordset.isEOF()) {
					for (int i = 0; i < ((GeoRegion)mRecordset.getGeometry()).getPartCount(); i++) {
						region.addPart(((GeoRegion) mRecordset.getGeometry()).getPart(i));
					}
					mRecordset.moveNext();
				}
				mRecordset.dispose();
				
				Dataset clipData =  datasource.getDatasets().get(clipDatasetNm);
				Dataset hillshadeData = (DatasetGrid)datasource.getDatasets().get(hillshadeDatasetNm);
				
				//Dataset clipData =  uDatasource.getDatasets().get(clipDatasetNm);
				clipType = clipData.getType();

				if(clipType.equals(DatasetType.GRID)) {
					clipDataset = RasterClip.clip((DatasetGrid)clipData,region, true, false, mDatasource, clipCopyDatasetNm);
					statisticMap = caculateStatisticsGrid(clipDataset,captionNm,region.getArea());
				}else {
					clipDataset = VectorClip.clipDatasetVector((DatasetVector)clipData, region, true, false, mDatasource, clipCopyDatasetNm);
					statisticMap = caculateStatisticsVector(clipDataset, captionNm);
				}
				
				hillshadeClipDataset = RasterClip.clip(hillshadeData,region, true, false, mDatasource, hillshadeCopyDatasetNm);
				
				if(statisticMap != null) {
					statisticMap.put("전체면적", region.getArea());
					vo.setStatData(statisticMap.toString());
				}
				
				clipData.close();
				hillshadeData.close();
			}
			
			if(clipType.equals(DatasetType.GRID)) {
				if(mapStyle.equals("range")){
					addLayerThemeRangeGrid(clipDataset,mapId,clipCopyDatasetNm);
				}else if(mapStyle.equals("uniqe")){
					
				}else {
					addLayerSingleBandGrid(clipDataset,mapId,clipCopyDatasetNm);
				}
				
				
			}else {
				if(mapStyle.equals("uniqe")){
					addLayerThemeUniqueVector(clipDataset,mapId,clipCopyDatasetNm);
				}else {
					addLayerSingleBandVector(clipDataset,mapId,clipCopyDatasetNm);
				}
			}
			addLayerSingleBandGrid(hillshadeClipDataset, mapId, hillshadeCopyDatasetNm);
			addLayerSingleBandVector(watershedCopyDatasetVector,mapId,watershedCopyDatasetNm);
			
			if(setMapLayoutControl(templateNm,mapId,bound)) {
				AnalFileVO imgVo = saveMapImageToJpg(vo);//saveMapImage(vo);
				list.add(imgVo);
				
				if(deleted) {
					deleteMap(mapId);
				}
			}
			hillshadeClipDataset.close();
			watershedCopyDatasetVector.close();
			clipDataset.close();
			
			if(clipType.equals(DatasetType.GRID)) {
				mExportUdbToFile(clipCopyDatasetNm, vo, "tif");
			}else {
				mExportUdbToFile(clipCopyDatasetNm, vo, "shp");
			}
			mExportUdbToFile(watershedCopyDatasetNm, vo, "shp");
			mExportUdbToFile(hillshadeCopyDatasetNm, vo, "tif");
			
			vo.setFileExtsn("zip");
			list.add(vo);
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		
		return list;
	}
	
	/**
	 * 사방사업 타당성평가 수계분석(3ha)
	 * @param mstId
	 * @param sldId
	 * @param analId
	 * @param captionNm
	 * @param mapStyle
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createEcbStream3haClipImg(String mstId,String sldId,String analId) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		
		String mapId = "Map_river_".concat("_"+analId);
		String watershedDatasetNm = getLayerName("watershed");//"tf_feis_watershed";
		String hillshadeDatasetNm = getLayerName("hillshade");//hillshade
		String stream3hDatasetNm = getLayerName("stream3ha");//stream_3ha
		
		String templateNm = getLayoutTemplateNm("river");
		
		String watershedQuery = "mst_id = ".concat(mstId).concat(" and sld_id = '").concat(sldId).concat("' and anal_id = '").concat(analId).concat("'");
		
		String watershedCopyDatasetNm = "watershed_".concat(analId);
		String stream3haClipDatasetNm = "stream3ha_".concat(analId);
		String hillshadeClipDatasetNm = "hillshade_".concat(analId);
		
		DatasetVector watershedCopyDatasetVector = null;
		DatasetVector stream3haClipDatasetVector = null;
		Dataset hillshadeClipDataset = null;
		
		GeoRegion region = null;
		Rectangle2D bound = null;
		
		vo = getSavePath(analId,downloadMidDir);
		vo.setOrignlFileNm("stream3ha");
		vo.setAnalType("stream3ha");
		vo.setMstId(Integer.valueOf(mstId));
		vo.setSldId(sldId);
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapId,5186);
			
			//유역분석 결과 벡터레이어 DB에서 UDB로 복사
			copyPggisToMemoryUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			//copyPggisToUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			
			//데이터셋 자르기
			if(mDatasets.contains(watershedCopyDatasetNm)) {
				watershedCopyDatasetVector = (DatasetVector) mDatasets.get(watershedCopyDatasetNm);
				Recordset mRecordset = watershedCopyDatasetVector.query("",CursorType.STATIC);
				
				bound = mRecordset.getGeometry().getBounds();
				
				region = new GeoRegion();
				
				while (!mRecordset.isEOF()) {
					for (int i = 0; i < ((GeoRegion)mRecordset.getGeometry()).getPartCount(); i++) {
						region.addPart(((GeoRegion) mRecordset.getGeometry()).getPart(i));
					}
					mRecordset.moveNext();
				}
				mRecordset.dispose();
				
				DatasetVector stream3haData = (DatasetVector)datasource.getDatasets().get(stream3hDatasetNm);
				Dataset hillshadeData = (DatasetGrid)datasource.getDatasets().get(hillshadeDatasetNm);
				
				stream3haClipDatasetVector = VectorClip.clipDatasetVector((DatasetVector)stream3haData, region, true, false, mDatasource, stream3haClipDatasetNm);
				hillshadeClipDataset = RasterClip.clip(hillshadeData,region, true, false, mDatasource, hillshadeClipDatasetNm);
				
				stream3haData.close();
				hillshadeData.close();
			}
			
			addLayerSingleBandGrid(hillshadeClipDataset, mapId, hillshadeClipDatasetNm);
			addLayerSingleBandVector(stream3haClipDatasetVector,mapId,stream3haClipDatasetNm);
			addLayerSingleBandVector(watershedCopyDatasetVector,mapId,watershedCopyDatasetNm);
			
			if(setMapLayoutControl(templateNm,mapId,bound)) {
				AnalFileVO imgVo = saveMapImageToJpg(vo);
				list.add(imgVo);
				
				if(deleted) {
					deleteMap(mapId);
				}
			}
			
			stream3haClipDatasetVector.close();
			hillshadeClipDataset.close();
			watershedCopyDatasetVector.close();
			
			mExportUdbToFile(stream3haClipDatasetNm, vo, "shp");
			mExportUdbToFile(watershedCopyDatasetNm, vo, "shp");
			mExportUdbToFile(hillshadeClipDatasetNm, vo, "tif");
			
			vo.setFileExtsn("zip");
			list.add(vo);
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		
		return list;
	}
	
	/**
	 * 사방사업 타당성평가 수계분석(5ha)
	 * @param mstId
	 * @param sldId
	 * @param analId
	 * @param captionNm
	 * @param mapStyle
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createEcbStream5haClipImg(String mstId,String sldId,String analId) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		
		String mapId = "Map_river_".concat("_"+analId);
		String watershedDatasetNm = getLayerName("watershed");//"tf_feis_watershed";
		String hillshadeDatasetNm = getLayerName("hillshade");//hillshade
		String stream5hDatasetNm = getLayerName("stream5ha");//stream_5ha
		
		String templateNm = getLayoutTemplateNm("river");
		
		String watershedQuery = "mst_id = ".concat(mstId).concat(" and sld_id = '").concat(sldId).concat("' and anal_id = '").concat(analId).concat("'");
		
		String watershedCopyDatasetNm = "watershed_".concat(analId);
		String stream5haClipDatasetNm = "stream5ha_".concat(analId);
		String hillshadeClipDatasetNm = "hillshade_".concat(analId);
		
		DatasetVector watershedCopyDatasetVector = null;
		DatasetVector stream5haClipDatasetVector = null;
		Dataset hillshadeClipDataset = null;
		
		GeoRegion region = null;
		Rectangle2D bound = null;
		
		vo = getSavePath(analId,downloadMidDir);
		vo.setOrignlFileNm("stream5ha");
		vo.setAnalType("stream5ha");
		vo.setMstId(Integer.valueOf(mstId));
		vo.setSldId(sldId);
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapId,5186);
			
			//유역분석 결과 벡터레이어 DB에서 UDB로 복사
			copyPggisToMemoryUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			//copyPggisToUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			
			//데이터셋 자르기
			if(mDatasets.contains(watershedCopyDatasetNm)) {
				watershedCopyDatasetVector = (DatasetVector) mDatasets.get(watershedCopyDatasetNm);
				Recordset mRecordset = watershedCopyDatasetVector.query("",CursorType.STATIC);
				
				bound = mRecordset.getGeometry().getBounds();
				
				region = new GeoRegion();
				
				while (!mRecordset.isEOF()) {
					for (int i = 0; i < ((GeoRegion)mRecordset.getGeometry()).getPartCount(); i++) {
						region.addPart(((GeoRegion) mRecordset.getGeometry()).getPart(i));
					}
					mRecordset.moveNext();
				}
				mRecordset.dispose();
				
				DatasetVector stream5haData = (DatasetVector)datasource.getDatasets().get(stream5hDatasetNm);
				Dataset hillshadeData = (DatasetGrid)datasource.getDatasets().get(hillshadeDatasetNm);
				
				stream5haClipDatasetVector = VectorClip.clipDatasetVector((DatasetVector)stream5haData, region, true, false, mDatasource, stream5haClipDatasetNm);
				hillshadeClipDataset = RasterClip.clip(hillshadeData,region, true, false, mDatasource, hillshadeClipDatasetNm);
				
				stream5haData.close();
				hillshadeData.close();
			}
			
			addLayerSingleBandGrid(hillshadeClipDataset, mapId, hillshadeClipDatasetNm);
			addLayerSingleBandVector(stream5haClipDatasetVector,mapId,stream5haClipDatasetNm);
			addLayerSingleBandVector(watershedCopyDatasetVector,mapId,watershedCopyDatasetNm);
			
			if(setMapLayoutControl(templateNm,mapId,bound)) {
				AnalFileVO imgVo = saveMapImageToJpg(vo);
				list.add(imgVo);
				
				if(deleted) {
					deleteMap(mapId);
				}
			}
			
			stream5haClipDatasetVector.close();
			hillshadeClipDataset.close();
			watershedCopyDatasetVector.close();
			
			mExportUdbToFile(stream5haClipDatasetNm, vo, "shp");
			mExportUdbToFile(watershedCopyDatasetNm, vo, "shp");
			mExportUdbToFile(hillshadeClipDatasetNm, vo, "tif");
			
			vo.setFileExtsn("zip");
			list.add(vo);
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		
		return list;
	}
	
	/**
	 * 사방사업 타당성평가 대상지위치(시도)
	 * @param mstId
	 * @param sldId
	 * @param analId
	 * @param adminCode
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createEcbSidoClipImg(String mstId,String sldId,String analId,String adminCode) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;

		String mapId = "Map_sido_".concat(analId);
		String ecrtcnlDatasetNm = getLayerName("ecrtcnl");//"tf_feis_ecrtcnl";
		String sidoDatasetNm = getLayerName("sido");
		
		String sidoCode = adminCode.substring(0,2);
		
		String ecrtcnlQuery = "mst_id = ".concat(mstId).concat(" and sld_id = '").concat(sldId).concat("' and anal_id = '").concat(analId).concat("'");
		String sidoQuery = "ctprvn_cod = '".concat(sidoCode).concat("'");
		
		String ecrtcnlCopyDatasetNm = "ecrtcnl_".concat(analId);
		String sidoCopyDatasetNm = "ecb_sido_".concat(analId);
		
		DatasetVector ecrtcnlCopyDatastVector = null;
		DatasetVector sidoDatasetVector = null;
		DatasetVector sidoCopyDatasetVector = null;
		
		Rectangle2D newBound = null;
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapId,5186);
			
			//유출구 데이터 DB에서 UDB로 복사
			copyPggisToMemoryUdb(ecrtcnlDatasetNm,ecrtcnlCopyDatasetNm,ecrtcnlQuery);
			//copyPggisToUdb(ecrtcnlDatasetNm,ecrtcnlCopyDatasetNm,watershedQuery);
			copyPggisToMemoryUdb(sidoDatasetNm,sidoCopyDatasetNm,sidoQuery);
			
			//지적데이터셋 자르기
			if(mDatasets.contains(ecrtcnlCopyDatasetNm)) {
				
				sidoDatasetVector = (DatasetVector) datasets.get(sidoDatasetNm);
				
				Rectangle2D bound = sidoDatasetVector.getBounds();
				double maxlength = 100;
				//이미지 영역설정
				newBound = new Rectangle2D();
				newBound.setTop(bound.getTop()+maxlength);
				newBound.setBottom(bound.getBottom()-maxlength);
				newBound.setLeft(bound.getLeft()-maxlength);
				newBound.setRight(bound.getRight()+maxlength);
				
				ecrtcnlCopyDatastVector = (DatasetVector) mDatasets.get(ecrtcnlCopyDatasetNm);
				sidoCopyDatasetVector = (DatasetVector) mDatasets.get(sidoCopyDatasetNm);
			}
			
			addLayerSingleBandVector(sidoDatasetVector,mapId,"ecb_".concat(sidoDatasetNm));
			addLayerSingleBandVector(sidoCopyDatasetVector,mapId,sidoCopyDatasetNm);
			addLayerThemeLabelVector(sidoCopyDatasetVector,mapId,sidoCopyDatasetNm);
			
			vo = getSavePath(analId,downloadMidDir);
			vo.setOrignlFileNm("대상지(시도)");
			vo.setAnalType("대상지(시도)");
			vo.setMstId(Integer.valueOf(mstId));
			vo.setSldId(sldId);
			
			if(setMapLayoutControl("tp_none",mapId,newBound)) {
				AnalFileVO imgVo = saveMapImageToJpg(vo);
				list.add(imgVo);
				
//				if(deleted) {
//					deleteMap(mapId);
//				}
			}
			
			sidoDatasetVector.close();
			sidoCopyDatasetVector.close();
			ecrtcnlCopyDatastVector.close();
			
			mExportUdbToFile(sidoCopyDatasetNm, vo, "shp");
			mExportUdbToFile(ecrtcnlCopyDatasetNm, vo, "shp");
			
			vo.setFileExtsn("zip");
			list.add(vo);

		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		return list;
	}
	
	/**
	 * 사방사업 타당성평가 대상지위치(시군구)
	 * @param mstId
	 * @param sldId
	 * @param analId
	 * @param adminCode
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createEcbSignguClipImg(String mstId,String sldId,String analId,String adminCode) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;

		String mapId = "Map_sido_".concat(analId);
		String ecrtcnlDatasetNm = getLayerName("ecrtcnl");//"tf_feis_ecrtcnl";
		String signguDatasetNm = getLayerName("signgu");
		
		String sidoCode = adminCode.substring(0,2);
		String signguCode = adminCode.substring(0,5);
		
		String ecrtcnlQuery = "mst_id = ".concat(mstId).concat(" and sld_id = '").concat(sldId).concat("' and anal_id = '").concat(analId).concat("'");
		String signgusQuery = "ctprvn_cod = '".concat(sidoCode).concat("'");
		String signguQuery = "signgu_cod = '".concat(signguCode).concat("'");
		
		String ecrtcnlCopyDatasetNm = "ecrtcnl_".concat(analId);
		String signgusCopyDatasetNm = "ecb_signgus_".concat(analId);
		String signguCopyDatasetNm = "ecb_signgu_".concat(analId);
		
		DatasetVector ecrtcnlCopyDatastVector = null;
		DatasetVector signgusCopyDatasetVector = null;
		DatasetVector signguCopyDatasetVector = null;
		
		Rectangle2D newBound = null;
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapId,5186);
			
			//유출구 데이터 DB에서 UDB로 복사
			copyPggisToMemoryUdb(ecrtcnlDatasetNm,ecrtcnlCopyDatasetNm,ecrtcnlQuery);
			//copyPggisToUdb(ecrtcnlDatasetNm,ecrtcnlCopyDatasetNm,watershedQuery);
			copyPggisToMemoryUdb(signguDatasetNm,signgusCopyDatasetNm,signgusQuery);
			copyPggisToMemoryUdb(signguDatasetNm,signguCopyDatasetNm,signguQuery);
			
			//지적데이터셋 자르기
			if(mDatasets.contains(ecrtcnlCopyDatasetNm)) {
				
				signgusCopyDatasetVector = (DatasetVector) mDatasets.get(signgusCopyDatasetNm);
				
				Rectangle2D bound = signgusCopyDatasetVector.getBounds();
				double maxlength = 100;
				//이미지 영역설정
				newBound = new Rectangle2D();
				newBound.setTop(bound.getTop()+maxlength);
				newBound.setBottom(bound.getBottom()-maxlength);
				newBound.setLeft(bound.getLeft()-maxlength);
				newBound.setRight(bound.getRight()+maxlength);
				
				ecrtcnlCopyDatastVector = (DatasetVector) mDatasets.get(ecrtcnlCopyDatasetNm);
				signguCopyDatasetVector = (DatasetVector) mDatasets.get(signguCopyDatasetNm);
			}
			
			addLayerSingleBandVector(signgusCopyDatasetVector,mapId,signgusCopyDatasetNm);
			addLayerSingleBandVector(signguCopyDatasetVector,mapId,signguCopyDatasetNm);
			addLayerThemeLabelVector(signgusCopyDatasetVector,mapId,signgusCopyDatasetNm);
			
			vo = getSavePath(analId,downloadMidDir);
			vo.setOrignlFileNm("대상지(시군구)");
			vo.setAnalType("대상지(시군구)");
			vo.setMstId(Integer.valueOf(mstId));
			vo.setSldId(sldId);
			
			if(setMapLayoutControl("tp_none",mapId,newBound)) {
				AnalFileVO imgVo = saveMapImageToJpg(vo);
				list.add(imgVo);
				
//				if(deleted) {
//					deleteMap(mapId);
//				}
			}
			
			signgusCopyDatasetVector.close();
			signguCopyDatasetVector.close();
			ecrtcnlCopyDatastVector.close();
			
			mExportUdbToFile(signgusCopyDatasetNm, vo, "shp");
			mExportUdbToFile(signguCopyDatasetNm, vo, "shp");
			mExportUdbToFile(ecrtcnlCopyDatasetNm, vo, "shp");
			
			vo.setFileExtsn("zip");
			list.add(vo);

		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		return list;
	}
	
	/**
	 * 사방사업 타당성평가 관계지적도
	 * @param mstId
	 * @param sldId
	 * @param analId
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createEcbCadastralMapImg(String mstId,String sldId,String analId) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		//String saveImgNm = null;
		String mapId = "Map_".concat(analId);
		String ecrtcnlDatasetNm = getLayerName("ecrtcnl");//"tf_feis_ecrtcnl";
		String watershedDatasetNm = getLayerName("watershed");//"tf_feis_watershed";
		String lgstrDatasetNm = getLayerName("lgstr");//지적
		
		String watershedQuery = "mst_id = ".concat(mstId).concat(" and sld_id = '").concat(sldId).concat("' and anal_id = '").concat(analId).concat("'");
		String ecrtcnlCopyDatasetNm = "ecrtcnl_".concat(analId);
		String watershedCopyDatasetNm = "watershed_".concat(analId);
		String lgstrCopyDatasetNm = "ecb_lgstr_".concat(analId);
		
		DatasetVector ecrtcnlCopyDatastVector = null;
		DatasetVector watershedCopyDatasetVector = null;
		DatasetVector lgstrClipDatasetVector = null;
		
		Rectangle2D newBound = null;
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapId,5186);
			
			//유출구 데이터 DB에서 UDB로 복사
			copyPggisToMemoryUdb(ecrtcnlDatasetNm,ecrtcnlCopyDatasetNm,watershedQuery);
			//copyPggisToUdb(ecrtcnlDatasetNm,ecrtcnlCopyDatasetNm,watershedQuery);
			
			//유역분석 결과 벡터레이어 DB에서 UDB로 복사
			copyPggisToMemoryUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			//copyPggisToUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			
			//지적데이터셋 자르기
			if(mDatasets.contains(watershedCopyDatasetNm)) {
				
				watershedCopyDatasetVector = (DatasetVector) mDatasets.get(watershedCopyDatasetNm);
				Recordset mRecordset = watershedCopyDatasetVector.query("",CursorType.STATIC);
				
				double addLen = 0.0;
				Rectangle2D bound = mRecordset.getGeometry().getBounds();
				
				boolean checkLen = bound.getWidth() > bound.getHeight() ? true : false;
				double maxlength = checkLen ? bound.getWidth()*2 : bound.getHeight()*2;
				double cliplength = checkLen ? bound.getWidth()*10 : bound.getHeight()*10;
				
				if(checkLen) {
					addLen = (bound.getWidth() - bound.getHeight())/2;
				}else {
					addLen = (bound.getHeight() - bound.getWidth())/2;
				}
				
				newBound = new Rectangle2D();
				//클립할 영역 설정(이미지 영역보다 조금 더 많이 자름)
				newBound.setTop((checkLen ? bound.getTop()+addLen : bound.getTop())+cliplength);
				newBound.setBottom((checkLen ? bound.getBottom()-addLen : bound.getBottom())-cliplength);
				newBound.setLeft((checkLen ? bound.getLeft() : bound.getLeft()-addLen)-cliplength);
				newBound.setRight((checkLen ? bound.getRight() : bound.getRight()+addLen)+cliplength);
				
				GeoRectangle geoRect = new GeoRectangle(newBound, 0);
				GeoRegion region = geoRect.convertToRegion();

				mRecordset.dispose();
				
				lgstrClipDatasetVector = VectorClip.clipDatasetVector((DatasetVector)datasource.getDatasets().get(lgstrDatasetNm), region, true, false, mDatasource, lgstrCopyDatasetNm);
				
				//이미지 영역설정
				newBound = new Rectangle2D();
				newBound.setTop(bound.getTop()+maxlength);
				newBound.setBottom(bound.getBottom()-maxlength);
				newBound.setLeft(bound.getLeft()-maxlength);
				newBound.setRight(bound.getRight()+maxlength);
			}
			
			ecrtcnlCopyDatastVector = (DatasetVector) mDatasets.get(ecrtcnlCopyDatasetNm);
			
			addLayerSingleBandVector(lgstrClipDatasetVector,mapId,lgstrCopyDatasetNm);
			addLayerThemeLabelVector(lgstrClipDatasetVector,mapId,lgstrCopyDatasetNm);
			addLayerSingleBandVector(watershedCopyDatasetVector,mapId,watershedCopyDatasetNm);
			addLayerSingleBandVector(ecrtcnlCopyDatastVector,mapId,ecrtcnlCopyDatasetNm);
			
			vo = getSavePath(analId,downloadMidDir);
			vo.setOrignlFileNm("관계지적도");
			vo.setAnalType("관계지적도");
			vo.setMstId(Integer.valueOf(mstId));
			vo.setSldId(sldId);
			
			if(setMapLayoutControl("locTemplate",mapId,newBound)) {
				AnalFileVO imgVo = saveMapImageToJpg(vo);//saveMapImage(vo);
				list.add(imgVo);
				
//				if(deleted) {
//					deleteMap(mapId);
//				}
			}
			lgstrClipDatasetVector.close();
			watershedCopyDatasetVector.close();
			ecrtcnlCopyDatastVector.close();
			
			mExportUdbToFile(lgstrCopyDatasetNm, vo, "shp");
			mExportUdbToFile(watershedCopyDatasetNm, vo, "shp");
			mExportUdbToFile(ecrtcnlCopyDatasetNm, vo, "shp");
			
			vo.setFileExtsn("zip");
			list.add(vo);
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		return list;
	}
	
	/**
	 * 사방사업 타당성평가 수치지형도
	 * @param mstId
	 * @param sldId
	 * @param analId
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createEcbSldLocationTopoMapImg(String mstId,String sldId,String analId,String lonLatText) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		//String saveImgNm = null;
		String mapId = "Map_".concat(analId);
		String ecrtcnlDatasetNm = getLayerName("ecrtcnl");
		String watershedDatasetNm = getLayerName("watershed");
		String ctrlnDatasetNm = getLayerName("ctrln");
		String roadDatasetNm = getLayerName("road");
		
		String watershedQuery = "mst_id = ".concat(mstId).concat(" and sld_id = '").concat(sldId).concat("' and anal_id = '").concat(analId).concat("'");
		String ecrtcnlCopyDatasetNm = "ecrtcnl_".concat(analId);
		String watershedCopyDatasetNm = "watershed_".concat(analId);
		String ctrlnCopyDatasetNm = "ecb_ctrln_".concat(analId);
		String roadCopyDatasetNm = "ecb_road_".concat(analId);
		DatasetVector ecrtcnlCopyDatasetVector = null;
		DatasetVector watershedCopyDatasetVector = null;
		DatasetVector ctrlnClipDatasetVector = null;
		DatasetVector roadClipDatasetVector = null;
		
		Rectangle2D newBound = null;
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapId,5186);
			
			//유출구 데이터 DB에서 UDB로 복사
			copyPggisToMemoryUdb(ecrtcnlDatasetNm,ecrtcnlCopyDatasetNm,watershedQuery);
			//copyPggisToUdb(ecrtcnlDatasetNm,ecrtcnlCopyDatasetNm,watershedQuery);
			
			//유역분석 결과 벡터레이어 DB에서 UDB로 복사
			copyPggisToMemoryUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			//copyPggisToUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			
			//지적데이터셋 자르기
			if(mDatasets.contains(watershedCopyDatasetNm)) {
				
				watershedCopyDatasetVector = (DatasetVector) mDatasets.get(watershedCopyDatasetNm);
				Recordset mRecordset = watershedCopyDatasetVector.query("",CursorType.STATIC);
				
				double addLen = 0.0;
				Rectangle2D bound = mRecordset.getGeometry().getBounds();
				
				boolean checkLen = bound.getWidth() > bound.getHeight() ? true : false;
				double maxlength = checkLen ? bound.getWidth()*2 : bound.getHeight()*2;
				double cliplength = checkLen ? bound.getWidth()*5 : bound.getHeight()*5;
				
				if(checkLen) {
					addLen = (bound.getWidth() - bound.getHeight())/2;
				}else {
					addLen = (bound.getHeight() - bound.getWidth())/2;
				}
				
				newBound = new Rectangle2D();
				//클립할 영역 설정(이미지 영역보다 조금 더 많이 자름)
				newBound.setTop((checkLen ? bound.getTop()+addLen : bound.getTop())+cliplength);
				newBound.setBottom((checkLen ? bound.getBottom()-addLen : bound.getBottom())-cliplength);
				newBound.setLeft((checkLen ? bound.getLeft() : bound.getLeft()-addLen)-cliplength);
				newBound.setRight((checkLen ? bound.getRight() : bound.getRight()+addLen)+cliplength);
				
				GeoRectangle geoRect = new GeoRectangle(newBound, 0);
				GeoRegion region = geoRect.convertToRegion();

				mRecordset.dispose();
				
				ctrlnClipDatasetVector = VectorClip.clipDatasetVector((DatasetVector)datasource.getDatasets().get(ctrlnDatasetNm), region, true, false, mDatasource, ctrlnCopyDatasetNm);
				roadClipDatasetVector = VectorClip.clipDatasetVector((DatasetVector)datasource.getDatasets().get(roadDatasetNm), region, true, false, mDatasource, roadCopyDatasetNm);
				//이미지 영역설정
				newBound = new Rectangle2D();
				newBound.setTop(bound.getTop()+maxlength);
				newBound.setBottom(bound.getBottom()-maxlength);
				newBound.setLeft(bound.getLeft()-maxlength);
				newBound.setRight(bound.getRight()+maxlength);
			}
			
			ecrtcnlCopyDatasetVector = (DatasetVector) mDatasets.get(ecrtcnlCopyDatasetNm);
			
			FieldInfo fieldInfo = new FieldInfo();
			fieldInfo.setName("coord");
			fieldInfo.setType(FieldType.TEXT);
			ecrtcnlCopyDatasetVector.getFieldInfos().add(fieldInfo);
			
			Recordset ecrtcnlRecordset = ecrtcnlCopyDatasetVector.query("",CursorType.DYNAMIC);
			ecrtcnlRecordset.edit();
			
			ecrtcnlRecordset.setFieldValue("coord", lonLatText);
			
			ecrtcnlRecordset.update();
			ecrtcnlRecordset.close();
			
			addLayerSingleBandVector(ctrlnClipDatasetVector,mapId,ctrlnCopyDatasetNm);
			addLayerSingleBandVector(roadClipDatasetVector,mapId,roadCopyDatasetNm);
			addLayerSingleBandVector(ecrtcnlCopyDatasetVector,mapId,ecrtcnlCopyDatasetNm);
			addLayerThemeLabelVector(ecrtcnlCopyDatasetVector,mapId,"ecb_ecrtcnlcoord");
			
			vo = getSavePath(analId,downloadMidDir);
			vo.setOrignlFileNm("대상지(수치지형도)");
			vo.setAnalType("대상지(수치지형도)");
			vo.setMstId(Integer.valueOf(mstId));
			vo.setSldId(sldId);
			
			if(setMapLayoutControl("locTemplate",mapId,newBound)) {
				AnalFileVO imgVo = saveMapImageToJpg(vo);//saveMapImage(vo);
				list.add(imgVo);
				
//				if(deleted) {
//					deleteMap(mapId);
//				}
			}
			watershedCopyDatasetVector.close();
			roadClipDatasetVector.close();
			ecrtcnlCopyDatasetVector.close();
			
			mExportUdbToFile(ctrlnCopyDatasetNm, vo, "shp");
			mExportUdbToFile(roadCopyDatasetNm, vo, "shp");
			mExportUdbToFile(ecrtcnlCopyDatasetNm, vo, "shp");
			
			vo.setFileExtsn("zip");
			list.add(vo);
			//"D:\\home\\tomcat\\FEIStorage\\analysis\\20220923\\D9CB988E19CA428FB5AB3C6FFFFD3EB9.png";//
			//String type = "shp";
			//HashMap<String, FileType> hash = manage.getFileType(type);
			//manage.exportDataset(vTest, type, hash);
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		return list;
	}
	
	/**
	 * 사방사업 타당성평가 계류경사 분석
	 * @param mstId
	 * @param sldId
	 * @param analId
	 * @param lineWkt
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createEcbMntnTrntSlopeImg(String mstId,String sldId,String analId,String lineWkt,Map<String, Object> lineWktAttr) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		//String saveImgNm = null;
		
		String demDatasetNm = getLayerName("dem");
		String mntnTrntCopyDatasetNm = "mntnTrnt_".concat(analId);
		String mntnTrntPntDatasetNm = "mntnTrntPnt_".concat(analId);
		
		DatasetVector mntnTrntCopyDatasetVector = null;
		DatasetVector mntnTrntPntDatasetVector = null;
		DatasetGrid demDatasetGrid = null;
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			//라이데이터셋 생성
			Geometry lnewktGeometry = createGeometry(lineWkt, "POLYLINE");
			
			addRecordset(lnewktGeometry,lineWktAttr,"tf_feis_mntntrnt");
			
			String mntnTrntQuery = "anal_id = '".concat(lineWktAttr.get("anal_id").toString()).concat("'");
			
			copyPggisToMemoryUdb("tf_feis_mntntrnt",mntnTrntCopyDatasetNm,mntnTrntQuery);
			
			//createDataset("Line",lneWktDatasetNm);
			
//			lneWktDatasetVector = (DatasetVector) mDatasets.get(lneWktDatasetNm);
//			lneWktDatasetVector.setPrjCoordSys(PrjCoordSys.fromEPSG(5186));
//			Recordset lneWktRecordset = lneWktDatasetVector.query("",CursorType.DYNAMIC);
//			lneWktRecordset.addNew(lnewktGeometry);
//			lneWktRecordset.update();
//			lneWktRecordset.close();
			
			//포인트데이터셋 생성
			createDataset("Point", mntnTrntPntDatasetNm);
			
			mntnTrntPntDatasetVector = (DatasetVector) mDatasets.get(mntnTrntPntDatasetNm);
			mntnTrntPntDatasetVector.setPrjCoordSys(PrjCoordSys.fromEPSG(5186));
			FieldInfos lnePntFieldInfos = mntnTrntPntDatasetVector.getFieldInfos();
			FieldInfo valueInfo = new FieldInfo("value", FieldType.DOUBLE);
			lnePntFieldInfos.add(valueInfo);
			
			Recordset mntnTrntPntRecordset = mntnTrntPntDatasetVector.query("",CursorType.DYNAMIC);
			
			demDatasetGrid = (DatasetGrid) datasets.get(demDatasetNm);
			mntnTrntCopyDatasetVector = (DatasetVector) mDatasets.get(mntnTrntCopyDatasetNm);
			Recordset mntnTrntCopyRecordset = mntnTrntCopyDatasetVector.query("",CursorType.STATIC);
			
			mntnTrntCopyRecordset.moveFirst();
//			Point2D startPoint = null;
//			Point2D endPoint = null;
			double distance = 20.0;
			
//			double totalArea = 0;
			int i = 0;
//			int maxBound = 0;
			
			XYSeriesCollection xySeriesCollection = new XYSeriesCollection( );
			
			while(!mntnTrntCopyRecordset.isEOF()) {
				i++;
				GeoLine geoLine = (GeoLine)mntnTrntCopyRecordset.getGeometry();
				double len = geoLine.getLength();
				int lCnt = (int) Math.ceil(len / distance);
				
				XYSeries xySeries = new XYSeries("Series"+i);
				for (int j = 0; j <= lCnt; j++) {
					Map<String, Object> attr = new HashMap<String, Object>();
					Point2D findPoint = geoLine.findPointOnLineByDistance(j*distance);
					Point pt = demDatasetGrid.xyToGrid(findPoint);
					
					double gridValue = demDatasetGrid.getValue(pt.x, pt.y);
					attr.put("value", gridValue);
					Geometry geom = new GeoPoint(findPoint);
					mntnTrntPntRecordset.addNew(geom,attr);
					mntnTrntPntRecordset.update();
					
					xySeries.add(j*(int)distance,gridValue);
				}
				xySeriesCollection.addSeries(xySeries);
				
//				startPoint = geoLine.getPart(0).getItem(0);
				
				int l_cnt = geoLine.getPart(0).getCount();
//				endPoint = geoLine.getPart(0).getItem(l_cnt-1);
				
				mntnTrntCopyRecordset.moveNext();
				
				vo = getSavePath(analId,downloadMidDir);
				vo.setOrignlFileNm("계류경사분석");
				vo.setAnalType("계류경사분석");
				vo.setMstId(Integer.valueOf(mstId));
				vo.setSldId(sldId);
				
				AnalFileVO imgVo = createXYChartToImage("line",xySeriesCollection,(lCnt*(int)distance),vo);
				list.add(imgVo);
				
			}
			mntnTrntCopyRecordset.close();
			mntnTrntPntRecordset.dispose();
			mntnTrntPntRecordset.close();
			
			mntnTrntCopyDatasetVector.close();
			mntnTrntPntDatasetVector.close();
			demDatasetGrid.close();
			
			mExportUdbToFile(mntnTrntCopyDatasetNm, vo, "shp");
			mExportUdbToFile(mntnTrntPntDatasetNm, vo, "shp");
			
			vo.setFileExtsn("zip");
			list.add(vo);
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		return list;
	}
	
	
	/**
	 * 유역분석 폴리곤으로 데이터셋 자르기
	 * @param mstId
	 * @param sldId
	 * @param analId
	 * @param clipDatasetNm
	 * @param captionNm
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createClipImg(String mstId,String sldId,String analId, String captionNm, String mapStyle) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		
		//String saveImgNm = null;
		String mapId = "Map_".concat(captionNm).concat("_"+analId);
		String watershedDatasetNm = getLayerName("watershed");//"tf_feis_watershed";
		String watershedQuery = "mst_id = ".concat(mstId).concat(" and sld_id = '").concat(sldId).concat("' and anal_id = '").concat(analId).concat("'");
		String watershedCopyDatasetNm = "watershed_".concat(analId);
		String clipCopyDatasetNm = captionNm.concat("_"+analId);
		String templateNm = getLayoutTemplateNm(captionNm);
		String clipDatasetNm = getLayerName(captionNm);
		
		JSONObject statisticMap = null;
		
		DatasetVector watershedCopyDatasetVector = null;
		Dataset clipDataset = null;
		DatasetType clipType = null;
		GeoRegion region = null;
		
		Rectangle2D bound = null;
		
		vo = getSavePath(analId,downloadMidDir);
		vo.setOrignlFileNm(captionNm);
		vo.setAnalType(captionNm);
		vo.setMstId(Integer.valueOf(mstId));
		vo.setSldId(sldId);
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapId,5186);
			
			//유역분석 결과 벡터레이어 DB에서 UDB로 복사
			copyPggisToMemoryUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			//copyPggisToUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			
			//데이터셋 자르기
			if(mDatasets.contains(watershedCopyDatasetNm)) {
				watershedCopyDatasetVector = (DatasetVector) mDatasets.get(watershedCopyDatasetNm);
				Recordset mRecordset = watershedCopyDatasetVector.query("",CursorType.STATIC);
				
				bound = mRecordset.getGeometry().getBounds();
				
//				boolean checkLen = bound.getWidth() > bound.getHeight() ? true : false;
//				double maxlength = checkLen ? bound.getWidth()*0.1 : bound.getHeight()*0.1;
//				
//				newBound = new Rectangle2D();
//
//				newBound.setTop(bound.getTop()+maxlength);
//				newBound.setBottom(bound.getBottom()-maxlength);
//				newBound.setLeft(bound.getLeft()-maxlength);
//				newBound.setRight(bound.getRight()+maxlength);
				
				region = new GeoRegion();
				
				while (!mRecordset.isEOF()) {
					for (int i = 0; i < ((GeoRegion)mRecordset.getGeometry()).getPartCount(); i++) {
						region.addPart(((GeoRegion) mRecordset.getGeometry()).getPart(i));
					}
					mRecordset.moveNext();
				}
				mRecordset.dispose();
				
				Dataset clipData =  datasource.getDatasets().get(clipDatasetNm);
				//Dataset clipData =  uDatasource.getDatasets().get(clipDatasetNm);
				clipType = clipData.getType();

				if(clipType.equals(DatasetType.GRID)) {
					clipDataset = RasterClip.clip((DatasetGrid)clipData,region, true, false, mDatasource, clipCopyDatasetNm);
					statisticMap = caculateStatisticsGrid(clipDataset,captionNm,region.getArea());
				}else {
					clipDataset = VectorClip.clipDatasetVector((DatasetVector)clipData, region, true, false, mDatasource, clipCopyDatasetNm);
					statisticMap = caculateStatisticsVector(clipDataset, captionNm);
				}
				
				if(statisticMap != null) {
					statisticMap.put("전체면적", region.getArea());
					vo.setStatData(statisticMap.toString());
				}
				
				clipData.close();
			}
			
			if(clipType.equals(DatasetType.GRID)) {
				if(mapStyle.equals("range")){
					addLayerThemeRangeGrid(clipDataset,mapId,clipCopyDatasetNm);
				}else if(mapStyle.equals("uniqe")){
					
				}else {
					addLayerSingleBandGrid(clipDataset,mapId,clipCopyDatasetNm);
				}
				
				
			}else {
				if(mapStyle.equals("uniqe")){
					addLayerThemeUniqueVector(clipDataset,mapId,clipCopyDatasetNm);
				}else {
					addLayerSingleBandVector(clipDataset,mapId,clipCopyDatasetNm);
				}
			}
			
			addLayerSingleBandVector(watershedCopyDatasetVector,mapId,watershedCopyDatasetNm);
			
			
			
			if(setMapLayoutControl(templateNm,mapId,bound)) {
				AnalFileVO imgVo = saveMapImageToJpg(vo);//saveMapImage(vo);
				list.add(imgVo);
				
				if(deleted) {
					deleteMap(mapId);
				}
			}
			watershedCopyDatasetVector.close();
			clipDataset.close();
			
			if(clipType.equals(DatasetType.GRID)) {
				mExportUdbToFile(clipCopyDatasetNm, vo, "tif");
			}else {
				mExportUdbToFile(clipCopyDatasetNm, vo, "shp");
			}
			mExportUdbToFile(watershedCopyDatasetNm, vo, "shp");
			
			vo.setFileExtsn("zip");
			list.add(vo);
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		
		return list;
	}
	
	/**
	 * 대상지 위치도(영상) 생성
	 * @param mstId
	 * @param sldId
	 * @param analId
	 * @param clipDatasetNm
	 * @param captionNm
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createClipSatImg(String mstId,String sldId,String analId, String captionNm) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		
		String mapId = "Map_sat_".concat(analId);
		String watershedDatasetNm = getLayerName("watershed");//"tf_feis_watershed";
		String watershedQuery = "mst_id = ".concat(mstId).concat(" and sld_id = '").concat(sldId).concat("' and anal_id = '").concat(analId).concat("'");
		String watershedCopyDatasetNm = "watershed_".concat(analId);
		String clipCopyDatasetNm = captionNm.concat("_"+analId);
		String clipDatasetNm = getLayerName(captionNm);
		
		DatasetVector watershedCopyDatasetVector = null;
		DatasetVector clipDatasetVector = null;
		GeoRegion region = null;
		
		Rectangle2D newBound = null;
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapId,3857);
			
			//유역분석 결과 벡터레이어 DB에서 UDB로 복사
			copyPggisToMemoryUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			//copyPggisToUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			
			//데이터셋 자르기
			if(mDatasets.contains(watershedCopyDatasetNm)) {
				watershedCopyDatasetVector = (DatasetVector) mDatasets.get(watershedCopyDatasetNm);
				
				Recordset mRecordset = watershedCopyDatasetVector.query("",CursorType.STATIC);
				
//				Rectangle2D bound = mRecordset.getGeometry().getBounds();
//				newBound = new Rectangle2D();
//				
//				newBound.setTop(bound.getTop()+1000);
//				newBound.setBottom(bound.getBottom()-1000);
//				newBound.setLeft(bound.getLeft()-1000);
//				newBound.setRight(bound.getRight()+1000);
				
				double addLen = 0.0;
				Rectangle2D bound = mRecordset.getGeometry().getBounds();
				
				//가로와 세로를 비교하여 큰 길이를 구하기
				addLen = (bound.getWidth() - bound.getHeight())/2;// 
				boolean checkLen = bound.getWidth() > bound.getHeight() ? true : false;
				
				newBound = new Rectangle2D();
				//클립할 영역 설정(이미지 영역보다 조금 더 많이 자름)
				newBound.setTop((checkLen ? bound.getTop()+addLen : bound.getTop())+1000);
				newBound.setBottom((checkLen ? bound.getBottom()-addLen : bound.getBottom())-1000);
				newBound.setLeft((checkLen ? bound.getLeft() : bound.getLeft()-addLen)-1000);
				newBound.setRight((checkLen ? bound.getRight() : bound.getRight()+addLen)+1000);
				
				GeoRectangle geoRect = new GeoRectangle(newBound, 0);
				region = geoRect.convertToRegion();

				mRecordset.dispose();
			}
			
			if(datasets.contains(clipDatasetNm)) {
				//VectorClip.clipDatasetVector((DatasetVector)datasource.getDatasets().get(clipDatasetNm), region, true, false, uDatasource, clipCopyDatasetNm+"_origin");
				clipDatasetVector = VectorClip.clipDatasetVector((DatasetVector)datasource.getDatasets().get(clipDatasetNm), region, true, false, mDatasource, clipCopyDatasetNm);
				//clipDatasetVector.close();
				if(coordSysTranslator(clipDatasetVector,3857)) {
					
					coordSysTranslator(watershedCopyDatasetVector,3857);
					
					Recordset mRecordset = watershedCopyDatasetVector.query("",CursorType.STATIC);
					//uRecordset = clipDatasetVector.query("",CursorType.STATIC);
					
					Rectangle2D bound = mRecordset.getGeometry().getBounds();
					newBound = new Rectangle2D();
					
					newBound.setTop(bound.getTop()+100);
					newBound.setBottom(bound.getBottom()-100);
					newBound.setLeft(bound.getLeft()-100);
					newBound.setRight(bound.getRight()+100);
					
					mRecordset.dispose();
					watershedCopyDatasetVector.close();
					
//					if(deleted) {
//						uDatasets.delete(watershedCopyDatasetNm);
//					}
					
					vDataset = vDatasets.get("VworldSatellite");
					
					addLayerImage(vDataset,mapId,"vworld");
					addLayerSingleBandVector(clipDatasetVector,mapId,clipCopyDatasetNm);
					
					vo = getSavePath(analId,downloadMidDir);
					vo.setOrignlFileNm("위치도(영상)");
					vo.setAnalType("위치도(영상)");
					vo.setMstId(Integer.valueOf(mstId));
					vo.setSldId(sldId);
					
					if(setMapLayoutControl("satelliteTemplate",mapId,newBound)) {
						//saveImgNm = saveMapImage();
						AnalFileVO imgVo = saveMapImageToJpg(vo);//saveMapImage(vo);
						list.add(imgVo);
						
						if(deleted) {
							deleteMap(mapId);
						}
					}
					clipDatasetVector.close();
					
					mExportUdbToFile(clipCopyDatasetNm, vo, "shp");
					
					vo.setFileExtsn("zip");
					list.add(vo);
				}else {
					LOGGER.error("좌표변환에 실패하였습니다.");
				}
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		
		return list;
	}
	
	/**
	 * Stream Order(스트림 순서) 생성
	 * @param mstId
	 * @param sldId
	 * @param analId
	 * @param captionNm
	 * @return
	 * @throws Exception
	 */
	public String streamOrder(String mstId,String sldId,String analId, String captionNm) throws Exception{
		//List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		//AnalFileVO vo = null;
		
		//String saveImgNm = null;
		//String mapId = "Map_".concat(captionNm).concat("_"+analId);
		String watershedDatasetNm = "tf_feis_watershed";
		String streamOrderDatasetNm = "tf_feis_streamorder";
		String flowDirectionDatasetNm = "tf_feis_flowdirection";
		String clipStreamGridDatasetNm = "stream_".concat(analId);
		String clipDirectionGridDatasetNm = "direction_".concat(analId);
		String watershedCopyDatasetNm = "watershed_".concat(analId);
		String resultDatasetNm = captionNm.concat("_"+analId);
		
		String watershedQuery = "mst_id = ".concat(mstId).concat(" and sld_id = '").concat(sldId).concat("' and anal_id = '").concat(analId).concat("'");
		
		//String clipDatasetNm = getLayerName(captionNm);
		
		DatasetVector watershedCopyDatasetVector = null;
		DatasetGrid clipStreamGridDataset = null;
		DatasetGrid clipDirectionGridDataset = null;
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//유역분석 결과 벡터레이어 DB에서 UDB로 복사
			copyPggisToMemoryUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			//copyPggisToUdb(watershedDatasetNm,watershedCopyDatasetNm,watershedQuery);
			
			//데이터셋 자르기
			if(mDatasets.contains(watershedCopyDatasetNm)) {
				watershedCopyDatasetVector = (DatasetVector) mDatasets.get(watershedCopyDatasetNm);
				Recordset mRecordset = watershedCopyDatasetVector.query("",CursorType.STATIC);
				
				GeoRegion region = new GeoRegion();
				
				while (!mRecordset.isEOF()) {
					for (int i = 0; i < ((GeoRegion)mRecordset.getGeometry()).getPartCount(); i++) {
						region.addPart(((GeoRegion) mRecordset.getGeometry()).getPart(i));
					}
					mRecordset.moveNext();
				}
				mRecordset.dispose();
				watershedCopyDatasetVector.close();
				
				DatasetGrid streamGrid = (DatasetGrid)datasource.getDatasets().get(streamOrderDatasetNm);
				DatasetGrid directionGrid = (DatasetGrid)datasource.getDatasets().get(flowDirectionDatasetNm);
				
				clipStreamGridDataset = (DatasetGrid)RasterClip.clip(streamGrid,region, true, false, mDatasource, clipStreamGridDatasetNm);
				clipDirectionGridDataset = (DatasetGrid)RasterClip.clip(directionGrid,region, true, false, mDatasource, clipDirectionGridDatasetNm);
				//clipDataset = VectorClip.clipDatasetVector((DatasetVector)clipData, region, true, false, uDatasource, clipCopyDatasetNm);
				
				streamGrid.close();
				directionGrid.close();
				
				//clipData.close();
				DatasetGrid grid = HydrologyAnalyst.streamOrder(clipStreamGridDataset, clipDirectionGridDataset, StreamOrderType.SHREVE, mDatasource, resultDatasetNm);
				
				clipStreamGridDataset.close();
				clipDirectionGridDataset.close();
				grid.close();
			}
			
//			if(deleted) {
//				if(uDatasets.contains(watershedCopyDatasetNm)) {
//					uDatasets.delete(watershedCopyDatasetNm);					
//				}
//				if(uDatasets.contains(streamOrderDatasetNm)) {
//					uDatasets.delete(streamOrderDatasetNm);					
//				}
//				if(uDatasets.contains(flowDirectionDatasetNm)) {
//					uDatasets.delete(flowDirectionDatasetNm);					
//				}
//				if(uDatasets.contains(resultDatasetNm)) {
//					uDatasets.delete(resultDatasetNm);					
//				}
//				if(uDatasets.contains(clipStreamGridDatasetNm)) {
//					uDatasets.delete(clipStreamGridDatasetNm);					
//				}
//				if(uDatasets.contains(clipDirectionGridDatasetNm)) {
//					uDatasets.delete(clipDirectionGridDatasetNm);					
//				}
//			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		
		return "";
	}
	
	/**
	 * 사방사업 타당성평가 생태자연도
	 * @param mstId
	 * @param sldId
	 * @param analId
	 * @param clipDatasetNm
	 * @param captionNm
	 * @return
	 * @throws Exception
	 */
	public String createVytEcbNatureImg(String mstId,String sldId,String analId,String clipDatasetNm, String captionNm) throws Exception{
		String saveImgNm = null;
		//String mapId = "Map_nature_".concat(analId);
		//String watershedDatasetNm = "tf_feis_watershed";
		//String watershedQuery = "mst_id = ".concat(mstId).concat(" and sld_id = '").concat(sldId).concat("' and anal_id = '").concat(analId).concat("'");
		//String clipCopyDatasetNm = captionNm.concat("_"+analId);
		
		return saveImgNm;
	}
	
	/**
	 * 사방사업 타당성평가 첫번째 대상지위지도
	 * @param pnu
	 * @param analId
	 * @throws Exception
	 */
	public void createVytEcbLocation001(String pnu,String analId) throws Exception{
		//String saveImgNm = null;
		String mapIdSgg = "Map_VytEcb001Sgg_".concat(analId);
		String mapIdEmd = "Map_VytEcb001Emd_".concat(analId);
		String sggDatasetNm = "tf_feis_signgu";
		String emdDatasetNm = "tf_feis_emd";
		
		String sggQuery = "ctprvn_cod = '".concat(pnu.substring(0, 2)).concat("'");
		String emdQuery = "signgu_cod = '".concat(pnu.substring(0, 5)).concat("'");
		
		String sggCopyDatasetNm = "sgg_".concat(analId);
		String emdCopyDatasetNm = "emd_".concat(analId);
		
		DatasetVector sggDatasetVector = null, emdDatasetVector = null;
		Recordset sggRecordset = null, emdRecordset = null;
		
		//Rectangle2D newBound = null;
		Rectangle2D sggBound = null, emdBound = null;

		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapIdSgg,5186);
			createNewMap(mapIdEmd,5186);
			
			//시군구 데이터 추출
			copyPggisToMemoryUdb(sggDatasetNm,sggCopyDatasetNm,sggQuery);
			//읍면동 데이터 추출
			copyPggisToMemoryUdb(emdDatasetNm,emdCopyDatasetNm,emdQuery);
			
			//추출한 시군구 데이터셋 선택
			if(mDatasets.contains(sggCopyDatasetNm)) {
				sggDatasetVector = (DatasetVector) mDatasets.get(sggCopyDatasetNm);
				sggRecordset = sggDatasetVector.query("",CursorType.STATIC);
				
				Rectangle2D bound = sggRecordset.getGeometry().getBounds();
				sggBound = new Rectangle2D();
				
				sggBound.setTop(bound.getTop()+100);
				sggBound.setBottom(bound.getBottom()-100);
				sggBound.setLeft(bound.getLeft()-100);
				sggBound.setRight(bound.getRight()+100);

				sggRecordset.dispose();
				
				addLayerThemeUniqueVector(sggDatasetVector,mapIdSgg,sggCopyDatasetNm);
			}
			
			//추출한 읍면동 데이터셋 선택
			if(mDatasets.contains(emdCopyDatasetNm)) {
				emdDatasetVector = (DatasetVector) mDatasets.get(emdCopyDatasetNm);
				emdRecordset = emdDatasetVector.query("",CursorType.STATIC);
				
				Rectangle2D bound = emdRecordset.getGeometry().getBounds();
				emdBound = new Rectangle2D();
				
				emdBound.setTop(bound.getTop()+100);
				emdBound.setBottom(bound.getBottom()-100);
				emdBound.setLeft(bound.getLeft()-100);
				emdBound.setRight(bound.getRight()+100);
				
				emdRecordset.dispose();
				
				addLayerThemeUniqueVector(emdDatasetVector,mapIdEmd,emdCopyDatasetNm);
			}
			
			mapLayoutcontrol = new MapLayoutControl();
			mapLayoutcontrol.getMapLayout().setWorkspace(workspace);
			mapLayoutcontrol.getMapLayout().open("tp_vyt_ecb_001_img01");
			
			int mapLen = 0;
			String targetMapName = null;
			Rectangle2D targetBound = null;
			
			try {
				LayoutElements layoutElements = mapLayoutcontrol.getMapLayout().getElements();
				while(!layoutElements.isEOF()) {
					Geometry geometry = layoutElements.getGeometry();
					if(geometry instanceof GeoMap) {
						if(mapLen == 0) {
							targetMapName = mapIdSgg;
							targetBound = sggBound;
						}else {
							targetMapName = mapIdEmd;
							targetBound = emdBound;
						}
						GeoMap target = (GeoMap)geometry;
						target.setMapName(targetMapName);
						
						layoutElements.setGeometry(target);
						
						com.supermap.mapping.Map map = new com.supermap.mapping.Map();
						map.setWorkspace(workspace);
						System.out.println(targetMapName);
						map.open(targetMapName);
						
						//Rectangle2D rect = datasource.getDatasets().get(this.dataSetNm).getBounds();
						//rect.inflate(100, 100);
						
						mapLayoutcontrol.setMapAction(Action.NULL);
						mapLayoutcontrol.setActiveGeoMapID(layoutElements.getID());
						mapLayoutcontrol.getActiveMap().setViewBounds(targetBound);
						mapLayoutcontrol.getActiveMap().setCenter(targetBound.getCenter());
						mapLayoutcontrol.getActiveMap().refresh();
						mapLayoutcontrol.setActiveGeoMapID(-1);
						 
					}
					layoutElements.moveNext();
				}
				layoutElements.refresh();
				mapLayoutcontrol.getMapLayout().refresh();
				
				sggDatasetVector.close();
				emdDatasetVector.close();
				
				if(deleted) {
					deleteMap(mapIdSgg);
					deleteMap(mapIdEmd);
//					workspace.getMaps().remove(mapIdSgg);
//					workspace.getMaps().remove(mapIdEmd);
					
//					if(uDatasets.contains(sggCopyDatasetNm)) {
//						uDatasets.delete(sggCopyDatasetNm);
//					}
//					if(uDatasets.contains(emdCopyDatasetNm)) {
//						uDatasets.delete(emdCopyDatasetNm);
//					}
				}
			} catch (Exception e) {
				LOGGER.error(e.getMessage());
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
	}
	
	/**
	 * 임도 타당성평가 분석
	 */
	
	/**
	 * 임도 대상지 위치 이미지 생성
	 * @param sldId {대상지그룹ID}
	 * @param smid {대상지 고유ID}
	 * @param analId {분석ID}
	 * @param captionNm {테이블ID조회를 위한 키워드}
	 * @param smid2 
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createFrdClipSatImg(String sldId,String smid,String analId, String captionNm, String smid2, String pageType) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		
		String smidNum = null;
		if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
			smidNum = smid2;
		}else {
			smidNum = smid;
		}
		
		String mapId = "Map_frd_sat_".concat(analId);//맵 이름
		String frdDatasetNm = getLayerName(captionNm);//임도테이블명 가져오기
		String frdQuery = "smid = ".concat(smidNum);//임도 where절
		String frdCopyDatasetNm = "frdlne_y_".concat(analId);//임도 복사 레이어명
		
		DatasetVector frdCopyDatasetVector = null;
		GeoRegion region = null;
		Rectangle2D newBound = null;
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapId,3857);
			
			copyPggisToMemoryUdb(frdDatasetNm,frdCopyDatasetNm,frdQuery);
			
			//데이터셋 자르기
			if(mDatasets.contains(frdCopyDatasetNm)) {
				frdCopyDatasetVector = (DatasetVector) mDatasets.get(frdCopyDatasetNm);
				
				if(coordSysTranslator(frdCopyDatasetVector,3857)) {
					Recordset mRecordset = frdCopyDatasetVector.query("",CursorType.STATIC);
					
					Rectangle2D bound = mRecordset.getBounds();
					
					double maxlength = bound.getWidth() > bound.getHeight() ? bound.getWidth()*1.5 : bound.getHeight()*1.5;
					
					//height 값이랑 비교해서 큰값으로  :::승현
					newBound = new Rectangle2D();
					
					newBound.setTop(bound.getTop()+maxlength);
					newBound.setBottom(bound.getBottom()-maxlength);
					newBound.setLeft(bound.getLeft()-maxlength);
					newBound.setRight(bound.getRight()+maxlength);
					
					
					GeoRectangle geoRect = new GeoRectangle(newBound, 0);
					region = geoRect.convertToRegion();

					mRecordset.dispose();
//					frdCopyDatasetVector.close();
					
					vDataset = vDatasets.get("VworldSatellite");
					
					addLayerImage(vDataset,mapId,"vworld");
					addLayerSingleBandVector(frdCopyDatasetVector,mapId,frdCopyDatasetNm);
					
					vo = getSavePath(analId,downloadMidDir);
					vo.setOrignlFileNm("destloc");
					vo.setAnalType("destloc");
					vo.setSldId(sldId);
					if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
		            	vo.setRouteCode("02");
		            	vo.setSmid(smid2);
		            }else{
		            	vo.setRouteCode("01");
		            	vo.setSmid(smid);
		            }
					
					if(setFrdMapLayoutControl("satelliteTemplate",mapId,newBound)) {
						//saveImgNm = saveMapImage();
						AnalFileVO imgVo = saveMapImageToJpg(vo);
						list.add(imgVo);
						
						if(deleted) {
							deleteMap(mapId);
						}
					}
					frdCopyDatasetVector.close();
					
					mExportUdbToFile(frdCopyDatasetNm, vo, "shp");
					
					vo.setFileExtsn("zip");
					list.add(vo);
				}else {
					LOGGER.error("좌표변환에 실패하였습니다.");
				}
				
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		
		return list;
	}
	/**
	 * 임도, 행정구역 이미지 생성
	 * @param sldId {대상지그룹ID}
	 * @param smid {대상지 고유ID}
	 * @param analId {분석ID}
	 * @param captionNm {테이블ID조회를 위한 키워드}
	 * @param sggCodeOne 
	 * @param emdCodeOne 
	 * @param emdList 
	 * @param smid2 
	 * @param pageType 
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createFrdClipAdmImg(String sldId,String smid,String analId, String captionNm, double x, double y, String sggCodeOne, String emdCodeOne, List<EgovMap> emdList, String smid2, String pageType) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		
		String mapId = "Map_frd_adm_".concat(analId);//맵 이름
		
		// 전체 읍면동 조회
		String emdAllDatasetNm = "tf_feis_emd";
		String emdAllDataQuery = "signgu_cod = '".concat(sggCodeOne)+"'";
		String emdAllCopyDatasetNm = "frdplgn_ea_emdAll_".concat(analId);	//emdAll
		DatasetVector emdAllCopyDatasetVector = null;
		
		
		// 해당 포인트의 읍면동 조회
		DatasetVector emdOneCopyDatasetVector = null;
		String emdOneDataQuery = "emd_code = '".concat(emdCodeOne)+"'";
		String emdOneCopyDatasetNm = "frdplgn_eo_emdOne_".concat(analId);		//emdOne
		
		// 센터 포인트 조회
		DatasetVector emdPntCopyDatasetVector = null;
		String emdPntCopyDatasetNm = "frd_one_admPnt_".concat(analId);	//emdAll
		
		
		Rectangle2D newBound = null;
		
		try {
			//슈퍼맵 연결
			LOGGER.info("슈퍼맵 연결 시작 : ".concat(analId));
			getConnectionInfo(analId);
			LOGGER.info("슈퍼맵 연결 완료 : ".concat(analId));
			//smwu프로젝트에 Map 생성하기
			LOGGER.info("Map 생성 시작 : ".concat(analId));
			createNewMap(mapId,3857);
			LOGGER.info("Map 생성 완료 : ".concat(analId));
			
			// 읍면동 All 폴리곤 데이터셋에서 시군구코드로 대상 조회
			LOGGER.info(emdAllDatasetNm+"데이터셋을 memory udb에 "+emdAllDataQuery+" 조건의 "+emdAllCopyDatasetNm+" 데이터셋으로 복사 : ".concat(analId));
			copyPggisToMemoryUdb(emdAllDatasetNm,emdAllCopyDatasetNm,emdAllDataQuery);
			LOGGER.info("데이터셋 복사 완료 : ".concat(analId));
			// 읍면동 One 폴리곤 데이터셋에서 시군구코드로 대상 조회
			LOGGER.info(emdAllDatasetNm+"데이터셋을 memory udb에 "+emdOneDataQuery+" 조건의 "+emdOneCopyDatasetNm+" 데이터셋으로 복사 : ".concat(analId));
			copyPggisToMemoryUdb(emdAllDatasetNm,emdOneCopyDatasetNm,emdOneDataQuery);
			LOGGER.info("데이터셋 복사 완료 : ".concat(analId));
			
			//센터포인트 데이터셋 생성
			LOGGER.info(emdPntCopyDatasetNm+"데이터셋을 생성 : ".concat(analId));
			createDataset("Point", emdPntCopyDatasetNm);
			LOGGER.info("데이터셋 생성 완료 : ".concat(analId));
			
			
			emdAllCopyDatasetVector = (DatasetVector) mDatasets.get(emdAllCopyDatasetNm);
			emdOneCopyDatasetVector = (DatasetVector) mDatasets.get(emdOneCopyDatasetNm);
			
			emdPntCopyDatasetVector = (DatasetVector) mDatasets.get(emdPntCopyDatasetNm);
			emdPntCopyDatasetVector.setPrjCoordSys(PrjCoordSys.fromEPSG(5186));
			Recordset pntRecordset = emdPntCopyDatasetVector.query("",CursorType.DYNAMIC);
			
			Point2D pt2d = new Point2D(x,y);
			Geometry geom = new GeoPoint(pt2d);
			
			pntRecordset.addNew(geom);
			pntRecordset.update();
			
			pntRecordset.dispose();
			pntRecordset.close();
			
			if(coordSysTranslator(emdAllCopyDatasetVector, 3857) && coordSysTranslator(emdOneCopyDatasetVector, 3857) && coordSysTranslator(emdPntCopyDatasetVector,3857)) {
				Recordset mRecordset = emdAllCopyDatasetVector.query("",CursorType.STATIC);
				
				if(mRecordset.getGeometry() != null) {
					Rectangle2D bound = mRecordset.getBounds();
					
					double maxlength = bound.getWidth() > bound.getHeight() ? bound.getWidth()*0.01 : bound.getHeight()*0.01;
					
					newBound = new Rectangle2D();
					
					newBound.setTop(bound.getTop()+maxlength);
					newBound.setBottom(bound.getBottom()-maxlength);
					newBound.setLeft(bound.getLeft()-maxlength);
					newBound.setRight(bound.getRight()+maxlength);
					
					addLayerSingleBandVector(emdAllCopyDatasetVector, mapId, emdAllCopyDatasetNm);
					addLayerSingleBandVector(emdOneCopyDatasetVector, mapId, emdOneCopyDatasetNm);
					addLayerThemeLabelVector(emdAllCopyDatasetVector, mapId, emdAllCopyDatasetNm);
					addLayerSingleBandVector(emdPntCopyDatasetVector, mapId, emdPntCopyDatasetNm);
					
					LOGGER.info("Map에 데이터셋 추가 완료");
					
					vo = getSavePath(analId,downloadMidDir);
					vo.setOrignlFileNm("admin");
					vo.setAnalType("admin");
					vo.setSldId(sldId);
					if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
		            	vo.setRouteCode("02");
		            	vo.setSmid(smid2);
		            }else{
		            	vo.setRouteCode("01");
		            	vo.setSmid(smid);
		            }
					
					if(setFrdMapLayoutControl("satelliteTemplate",mapId,newBound)) {
						AnalFileVO imgVo = saveMapImageToJpg(vo);
						list.add(imgVo);
						
						if(deleted) {
							deleteMap(mapId);
						}
					}
					mExportUdbToFile(emdAllCopyDatasetNm, vo, "shp");
					mExportUdbToFile(emdOneCopyDatasetNm, vo, "shp");
					mExportUdbToFile(emdPntCopyDatasetNm, vo, "shp");
					
					emdAllCopyDatasetVector.close();
					emdOneCopyDatasetVector.close();
					emdPntCopyDatasetVector.close();
					
					
					vo.setFileExtsn("zip");
					list.add(vo);
				}else {
					LOGGER.info("레코드셋 정보가 없습니다.");
				}
				
			}else {
				LOGGER.error("좌표변환에 실패하였습니다.");
			}
			
			
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		
		return list;
	}
	/**
	 * 임도, 관계지적도 이미지 생성
	 * @param sldId {대상지그룹ID}
	 * @param smid {대상지 고유ID}
	 * @param analId {분석ID}
	 * @param captionNm {테이블ID조회를 위한 키워드}
	 * @param sggCodeOne 
	 * @param sggCodeOne 
	 * @param pageType 
	 * @param smid2 
	 * @param emdCodeOne 
	 * @param emdList 
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createFrdClipRelImg(String sldId,String smid,String analId, String captionNm, String sggCodeOne, String smid2, String pageType) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		
		String mapId = "Map_frd_sat_".concat(analId);//맵 이름
		String frdDatasetNm = getLayerName(captionNm);//임도테이블명 가져오기
		String frdQuery = "smid = ".concat(smid);//임도 where절
		String frdCopyDatasetNm = "frdlne_b_".concat(analId);//임도 복사 레이어명
		
		DatasetVector frdCopyDatasetVector = null;
		
		String lgstrDatasetNm = "tf_feis_lgstr";//지적
		String lgstrCopyDatasetNm = "wlgstr_".concat(analId);//지적 클립 데이터셋명
		
		DatasetVector lgstrClipDatasetVector = null;
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapId,3857);
			
			//유역분석 결과 벡터레이어 DB에서 UDB로 복사
			copyPggisToMemoryUdb(frdDatasetNm,frdCopyDatasetNm,frdQuery);
			
			if(mDatasets.contains(frdCopyDatasetNm)) {
				frdCopyDatasetVector = (DatasetVector) mDatasets.get(frdCopyDatasetNm);
				Recordset mRecordset = frdCopyDatasetVector.query("",CursorType.STATIC);
				
				if(mRecordset.getGeometry() != null) {
					Rectangle2D bound = mRecordset.getGeometry().getBounds();
					
					Rectangle2D newBound = new Rectangle2D();
					//클립할 영역 설정(이미지 영역보다 조금 더 많이 자름)
					
					if((bound.getHeight()/2) > bound.getWidth()) {
						double maxlength = bound.getWidth() > bound.getHeight() ? bound.getWidth()*0.5 : bound.getHeight()*0.5;
						newBound = new Rectangle2D();
						newBound.setTop(bound.getTop()+maxlength);
						newBound.setBottom(bound.getBottom()-maxlength);
						newBound.setLeft(bound.getLeft()-maxlength*3);
						newBound.setRight(bound.getRight()+maxlength*3);
					}else {
						double maxlength = bound.getWidth() > bound.getHeight() ? bound.getWidth()*0.5 : bound.getHeight()*0.5;
						newBound = new Rectangle2D();
						newBound.setTop(bound.getTop()+maxlength);
						newBound.setBottom(bound.getBottom()-maxlength);
						newBound.setLeft(bound.getLeft()-maxlength);
						newBound.setRight(bound.getRight()+maxlength);
					}
					
					GeoRectangle geoRect = new GeoRectangle(newBound, 0);
					GeoRegion region = geoRect.convertToRegion();
					
					mRecordset.dispose();
					
					lgstrClipDatasetVector = VectorClip.clipDatasetVector((DatasetVector)datasource.getDatasets().get(lgstrDatasetNm), region, true, false, mDatasource, lgstrCopyDatasetNm);
					if(lgstrClipDatasetVector.getRecordCount() > 0) {
						LOGGER.info("지적 데이터셋 Clip 완료");
					}else {
						LOGGER.info("지적 데이터셋 Clip 실패");
					}
					
					double newMaxLength = bound.getWidth() > bound.getHeight() ? bound.getWidth()*0.1 : bound.getHeight()*0.1;
					newBound = new Rectangle2D();
					newBound.setTop(bound.getTop()+newMaxLength);
					newBound.setBottom(bound.getBottom()-newMaxLength);
					newBound.setLeft(bound.getLeft()-newMaxLength);
					newBound.setRight(bound.getRight()+newMaxLength);
					
					
					addLayerSingleBandVector(lgstrClipDatasetVector,mapId,lgstrCopyDatasetNm);
					addLayerThemeLabelVector(lgstrClipDatasetVector,mapId,lgstrCopyDatasetNm);
					addLayerSingleBandVector(frdCopyDatasetVector, mapId, frdCopyDatasetNm);
					
					
					LOGGER.info("Map에 데이터셋 추가 완료");
					
					vo = getSavePath(analId,downloadMidDir);
					vo.setOrignlFileNm("rllgstr");
					vo.setAnalType("rllgstr");
					vo.setSldId(sldId);
					if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
		            	vo.setRouteCode("02");
		            	vo.setSmid(smid2);
		            }else{
		            	vo.setRouteCode("01");
		            	vo.setSmid(smid);
		            }
					
					if(setFrdMapLayoutControl("satelliteTemplate",mapId,newBound)) {
						AnalFileVO imgVo = saveMapImageToJpg(vo);
						list.add(imgVo);
						
						if(deleted) {
							deleteMap(mapId);
						}
					}
					
					
					frdCopyDatasetVector.close();
					lgstrClipDatasetVector.close();
					
					mExportUdbToFile(frdCopyDatasetNm, vo, "shp");
					mExportUdbToFile(lgstrCopyDatasetNm, vo, "shp");
					vo.setFileExtsn("zip");
					list.add(vo);
					
				}else {
					LOGGER.info("레코드셋 정보가 없습니다.");
				}
				
			}else {
				LOGGER.error("좌표변환에 실패하였습니다.");
			}
				
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		
		return list;
	}
	/**
	 * 임도, 문화재보존관리지도 이미지 생성
	 * @param sldId {대상지그룹ID}
	 * @param smid {대상지 고유ID}
	 * @param analId {분석ID}
	 * @param captionNm {테이블ID조회를 위한 키워드}
	 * @param culY 
	 * @param pageType 
	 * @param smid2 
	 * @param list2 
	 * @param sggCodeOne 
	 * @param sggCodeOne 
	 * @param emdCodeOne 
	 * @param emdList 
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createFrdClipCulImg(String sldId,String smid,String analId, String captionNm, Double culX, Double culY, String smidList, String smid2, String pageType) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		
		String mapId = "Map_frd_sat_".concat(analId);//맵 이름
		
		String frdDatasetNm = getLayerName(captionNm);//임도테이블명 가져오기
		String frdQuery = "smid = ".concat(smid);//임도 where절
		String frdCopyDatasetNm = "frdlne_y_".concat(analId);//임도 복사 레이어명
		DatasetVector frdCopyDatasetVector = null;
		
		String culPntCopyDatasetNm = "frd_cul_pnt_".concat(analId);
		DatasetVector culCopyDatasetVector = null;
		
		String frdLneBufferDatasetNm = "frd_buffer_".concat(analId);
		DatasetVector frdLneBufferDatasetVector = null;
		
		String frdCultureDatasetNm = "tf_feis_cultural";
//		String frdCulLabelQuery = "smid in ("+smidList+")";
		String frdCulLabelQuery = "smid in (".concat(smidList).concat(")");
		String frdCulLabelDatasetNm = "frd_cul_".concat(analId);
		DatasetVector frdCulLabelDatasetVector = null;
		
		GeoRegion region = null;
		Rectangle2D newBound = null;
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapId,3857);
			
			copyPggisToMemoryUdb(frdDatasetNm,frdCopyDatasetNm,frdQuery);
			
			
			if(culX != null && culY != null) {	// 좌표가 있는 경우만 실행
				copyPggisToMemoryUdb(frdCultureDatasetNm,frdCulLabelDatasetNm,frdCulLabelQuery);
				
				createDataset("Point", culPntCopyDatasetNm);
				// 문화재 중심점 좌표에 대해서 중심 벡터 생성
				culCopyDatasetVector = (DatasetVector) mDatasets.get(culPntCopyDatasetNm);
				culCopyDatasetVector.setPrjCoordSys(PrjCoordSys.fromEPSG(5186));
				Recordset pntRecordset = culCopyDatasetVector.query("",CursorType.DYNAMIC);
				
				Point2D pt2d = new Point2D(culX, culY);
				Geometry geom = new GeoPoint(pt2d);
				
				pntRecordset.addNew(geom);
				pntRecordset.update();
				
				pntRecordset.dispose();
				pntRecordset.close();
			
				// 생성된 중심 벡터에 대해 buffer 200m 생성
				frdLneBufferDatasetVector = mDatasets.create(new DatasetVectorInfo(frdLneBufferDatasetNm,DatasetType.REGION),PrjCoordSys.fromEPSG(5186));
				
				BufferAnalystParameter bap = new BufferAnalystParameter();
				bap.setEndType(BufferEndType.ROUND);
				bap.setRadiusUnit(BufferRadiusUnit.Meter);
				bap.setLeftDistance("200");
				bap.setRightDistance("200");
				boolean isBufferCreated = BufferAnalyst.createBuffer(culCopyDatasetVector, frdLneBufferDatasetVector, bap, false, false);
				
				if(!isBufferCreated) {
					System.out.println("버퍼 생성 실패");
				}
				coordSysTranslator(culCopyDatasetVector,3857);
				
				// buffer 벡터 갖고오기
				frdLneBufferDatasetVector = (DatasetVector) mDatasets.get(frdLneBufferDatasetNm);
				coordSysTranslator(frdLneBufferDatasetVector,3857);
				frdCulLabelDatasetVector = (DatasetVector) mDatasets.get(frdCulLabelDatasetNm); 
				coordSysTranslator(frdCulLabelDatasetVector,3857);
			}
			
			//데이터셋 자르기
			if(mDatasets.contains(frdCopyDatasetNm)) {
				frdCopyDatasetVector = (DatasetVector) mDatasets.get(frdCopyDatasetNm);
				
				Recordset mRecordset = frdCopyDatasetVector.query("",CursorType.STATIC);
				
				if(mRecordset.getGeometry() != null) {
					
					coordSysTranslator(frdCopyDatasetVector,3857);
					
					Rectangle2D bound = mRecordset.getBounds();
					
					double maxlength = bound.getWidth() > bound.getHeight() ? bound.getWidth()*1.1 : bound.getHeight()*1.1;
					newBound = new Rectangle2D();
					newBound.setTop(bound.getTop()+maxlength);
					newBound.setBottom(bound.getBottom()-maxlength);
					newBound.setLeft(bound.getLeft()-maxlength);
					newBound.setRight(bound.getRight()+maxlength);
					
					
					GeoRectangle geoRect = new GeoRectangle(newBound, 0);
					region = geoRect.convertToRegion();
					
					mRecordset.dispose();
					
					vDataset = vDatasets.get("VworldSatellite");
					
					addLayerImage(vDataset,mapId,"vworld");	// 브이월드 바탕
					addLayerSingleBandVector(frdCopyDatasetVector,mapId,frdCopyDatasetNm);		//임도 라인
					
					if(culX != null && culY != null) {
						addLayerSingleBandVector(frdLneBufferDatasetVector,mapId,frdLneBufferDatasetNm);	// 버퍼가 있는 원
						addLayerThemeLabelVector(frdCulLabelDatasetVector,mapId,frdCulLabelDatasetNm);	// 문화재 라벨
					}
					
					vo = getSavePath(analId,downloadMidDir);
					vo.setOrignlFileNm("culture");
					vo.setAnalType("culture");
					vo.setSldId(sldId);
					if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
		            	vo.setRouteCode("02");
		            	vo.setSmid(smid2);
		            }else{
		            	vo.setRouteCode("01");
		            	vo.setSmid(smid);
		            }
					
					if(setFrdMapLayoutControl("satelliteTemplate",mapId,newBound)) {
						//saveImgNm = saveMapImage();
						AnalFileVO imgVo = saveMapImageToJpg(vo);
						list.add(imgVo);
						
						if(deleted) {
							deleteMap(mapId);
						}
					}
					
					mExportUdbToFile(frdCopyDatasetNm, vo, "shp");
					if(culX != null && culY != null) {
						mExportUdbToFile(culPntCopyDatasetNm, vo, "shp");
						mExportUdbToFile(frdLneBufferDatasetNm, vo, "shp");
						
						culCopyDatasetVector.close();
						frdLneBufferDatasetVector.close();
					}
					
					vo.setFileExtsn("zip");
					list.add(vo);
					
					frdCopyDatasetVector.close();
				}else {
					LOGGER.error("좌표변환에 실패하였습니다.");
				}
				
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		
		return list;
	}
	
	/**
	 * 임도, 분포도
	 * @param sldId {대상지그룹ID}
	 * @param smid {대상지 고유ID}
	 * @param analId {분석ID}
	 * @param captionNm {테이블ID조회를 위한 키워드}
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createFrdClipDestImg(String sldId,String smid,String analId, String captionNm, String analType, String mapStyle, String bufferSize, String smid2, String pageType) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;

		String mapId = "Map_frd_sat_".concat(analId);//맵 이름
		  
        // 임도 테이블명 조회
		String frdDatasetNm = getLayerName(captionNm);//임도테이블명 가져오기

		// 기존노선
		String frdQuery = null;//임도 where절
		String frdCopyDatasetNm = null; 
		DatasetVector frdCopyDatasetVector = null;

		// 수정노선
		String frdModiQuery = null;
		String frdModiCopyDatasetNm = null;
		DatasetVector frdModiCopyDatasetVector = null;
		if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
			frdModiQuery = "smid = ".concat(smid2);
			frdModiCopyDatasetNm = "frdlne_blue_".concat(analId);
			frdModiCopyDatasetVector = null;
		}else {
			frdQuery = "smid = ".concat(smid);//임도 where절
			frdCopyDatasetNm = "frdlne_y_".concat(analId); 
			frdCopyDatasetVector = null;
		}
			

        //힐쉐이드 테이블명 조회
		String clipRasterDatasetNm = "tf_feis_hillshade";

		// 힐쉐이드 레스터 (전체)
		String clipRasterCopyDatasetNm = "hillshade".concat("_"+analId);
		Dataset clipRasterDataset = null;

		// 힐쉐이드 레스터 (클립)
		String convertClipRasterCopyDatasetNm = "hillshade_3857_".concat(analType).concat("_").concat(analId);
		Dataset convertClipRasterDataset = null;

        // 버퍼 벡터 (전체)
        DatasetVector frdLneBufferDatasetVector = null;
		String frdLneBufferDatasetVectorNm =  "frdLne_buff_".concat(analId);

        // 버퍼 벡터 (클립)
		DatasetVector frdLneBufferClipDatasetVector = null;
		String frdLneBufferClipDatasetVectorNm = "frd_"+analType.concat("_").concat(analId);

        // 통계 JSONObject
        JSONObject statisticMap = null;

        GeoRegion region = null;
		Rectangle2D newBound = null;
		try {
	
			// 슈퍼맵 연결
			getConnectionInfo(analId);
	
			// Map 생성
			createNewMap(mapId,3857);
	
			if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
				// 수정노선
				copyPggisToMemoryUdb(frdDatasetNm,frdModiCopyDatasetNm,frdModiQuery);
			}else {
				// 기존노선
				copyPggisToMemoryUdb(frdDatasetNm,frdCopyDatasetNm,frdQuery);
			}
	
	        if(frdCopyDatasetNm != null || frdModiCopyDatasetNm != null) {
	            frdLneBufferDatasetVector = mDatasets.create(new DatasetVectorInfo(frdLneBufferDatasetVectorNm,DatasetType.REGION),PrjCoordSys.fromEPSG(5186));
	            if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
	                frdModiCopyDatasetVector = (DatasetVector) mDatasets.get(frdModiCopyDatasetNm);
	            }else {
	            	frdCopyDatasetVector = (DatasetVector) mDatasets.get(frdCopyDatasetNm);
	            }
	
	            // 버퍼설정 값
	            BufferAnalystParameter bap = new BufferAnalystParameter();
	            bap.setEndType(BufferEndType.ROUND);
	            bap.setRadiusUnit(BufferRadiusUnit.Meter);
	            bap.setLeftDistance(bufferSize);
	            bap.setRightDistance(bufferSize);
	            
	            // 병합여부
	            boolean isUnion = false;
	            // 기존속성값 유무
	            boolean isAttributeRetained = false;
	            
	            // 버퍼 생성
	            boolean isBufferCreated;
	            if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
	                isBufferCreated = BufferAnalyst.createBuffer(frdModiCopyDatasetVector, frdLneBufferDatasetVector, bap, isUnion, isAttributeRetained);
	            }else {
	                isBufferCreated = BufferAnalyst.createBuffer(frdCopyDatasetVector, frdLneBufferDatasetVector, bap, isUnion, isAttributeRetained);
	            }
	            if(!isBufferCreated) LOGGER.info("임도 버퍼 생성 실패!");
	            
	            //임도라인 버퍼데이터셋 레코드셋 조회
	            Recordset mFrdLneBufferRecordset = frdLneBufferDatasetVector.query("",CursorType.STATIC);
	            GeoRegion frdLneBufferRegion = new GeoRegion();
	            
	            while (!mFrdLneBufferRecordset.isEOF()) {
	                for (int i = 0; i < ((GeoRegion)mFrdLneBufferRecordset.getGeometry()).getPartCount(); i++) {
	                    frdLneBufferRegion.addPart(((GeoRegion) mFrdLneBufferRecordset.getGeometry()).getPart(i));
	                }
	                mFrdLneBufferRecordset.moveNext();
	            }
	            mFrdLneBufferRecordset.dispose();
	            
	            // 버퍼 클립
	            frdLneBufferClipDatasetVector = VectorClip.clipDatasetVector((DatasetVector)datasource.getDatasets().get(getLayerName(analType)), frdLneBufferRegion, true, false, mDatasource, frdLneBufferClipDatasetVectorNm);
	            if(frdLneBufferClipDatasetVector.getRecordCount() > 0) {
	                LOGGER.info("버퍼 데이터셋 Clip 완료");
	            }else {
	                LOGGER.info("버퍼 데이터셋 Clip 실패");
	            }
	            
	            // 힐쉐이드 데이터셋 불러오기
	            Dataset clipRasterData =  datasource.getDatasets().get(clipRasterDatasetNm);
	            
	            // 힐쉐이드 클립
	            clipRasterDataset = RasterClip.clip((DatasetGrid)clipRasterData,frdLneBufferRegion, true, false, mDatasource, clipRasterCopyDatasetNm);
	            if(clipRasterDataset != null) {
	                LOGGER.info("힐쉐이드 레스터 클립 완료");
	            }else {
	                LOGGER.info("힐쉐이드 레스터 클립 실패");
	            }
	        
	            clipRasterData.close();
	            
	            vDataset = vDatasets.get("VworldSatellite");
	            
	            // 벡터 좌표변환
	            coordSysTranslator(frdLneBufferClipDatasetVector,3857);
	            coordSysTranslator(frdLneBufferDatasetVector,3857);
	            if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
	            	coordSysTranslator(frdModiCopyDatasetVector,3857);
	            }else {
	            	coordSysTranslator(frdCopyDatasetVector,3857);
	            }
	            // 레스트 좌표변환 (raster는 좌표변환이 boolean타입의 coordSysTranslator로 안돼서 새로운 dataset으로 받아와야해서 아래코드 사용)
	            convertClipRasterDataset = CoordSysTranslator.convert(clipRasterDataset, new PrjCoordSys(3857), mDatasource, convertClipRasterCopyDatasetNm,new CoordSysTransParameter(), CoordSysTransMethod.MTH_GEOCENTRIC_TRANSLATION);
	            
	            // 이미지 영역 지정
	            Recordset mRecordsetBuff = frdLneBufferDatasetVector.query("", CursorType.STATIC);
	            Rectangle2D bound = mRecordsetBuff.getBounds();
	            double maxlength = bound.getWidth() > bound.getHeight() ? bound.getWidth()*0.4 : bound.getHeight()*0.4;
	            
	            newBound = new Rectangle2D();
	            newBound.setTop(bound.getTop()+maxlength);
	            newBound.setBottom(bound.getBottom()-maxlength);
	            newBound.setLeft(bound.getLeft()-maxlength);
	            newBound.setRight(bound.getRight()+maxlength);
	            
	            GeoRectangle geoRect = new GeoRectangle(newBound, 0);
	            region = geoRect.convertToRegion();
	            
	            // 통계치 계산
	            statisticMap = caculateStatisticsVector(frdLneBufferClipDatasetVector, analType);
	            
	            // Map에 Setting
	            addLayerImage(vDataset,mapId,"vworld");	// 브이월드 바탕
	            addLayerThemeUniqueVector(frdLneBufferClipDatasetVector,mapId,frdLneBufferClipDatasetVectorNm);	// 임도 버퍼 벡터
	            addLayerSingleBandGrid(convertClipRasterDataset,mapId,convertClipRasterCopyDatasetNm);	// 힐쉐이드
	            if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
	                addLayerSingleBandVector(frdModiCopyDatasetVector,mapId,frdModiCopyDatasetNm);	// 수정노선
	            }else {
	            	addLayerSingleBandVector(frdCopyDatasetVector,mapId,frdCopyDatasetNm);	// 임도라인 벡터
	            }
	            
	            mRecordsetBuff.dispose();
	            
	            vo = getSavePath(analId,downloadMidDir);
	            
	            if(statisticMap != null) {
	            	vo.setStatData(statisticMap.toString());
	            }
	            
	            vo.setOrignlFileNm(analType);
	            vo.setAnalType(analType);
	            vo.setSldId(sldId);
	            vo.setBufferSize(bufferSize);
	            
	            if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
	            	vo.setRouteCode("02");
	            	vo.setSmid(smid2);
	            }else{
	            	vo.setRouteCode("01");
	            	vo.setSmid(smid);
	            }
	            
	            if(setFrdMapLayoutControl("tp_vyt_frd_clip",mapId,newBound)) {
	                AnalFileVO imgVo = saveMapImageToJpg(vo);
	                list.add(imgVo);
	                
	                if(deleted) {
	                    deleteMap(mapId);
	                }
	            }
	            
	            mExportUdbToFile(frdLneBufferClipDatasetVectorNm, vo, "shp");
	            mExportUdbToFile(convertClipRasterCopyDatasetNm, vo, "tif");
	            
	            if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
	                mExportUdbToFile(frdModiCopyDatasetNm, vo, "shp");
	                frdModiCopyDatasetVector.close();
	            }else {
	            	mExportUdbToFile(frdCopyDatasetNm, vo, "shp");
	            	frdCopyDatasetVector.close();
	            }
	            
	            frdLneBufferClipDatasetVector.close();
	            frdLneBufferDatasetVector.close();
	            clipRasterDataset.close();
	            convertClipRasterDataset.close();
	            
	            vo.setFileExtsn("zip");
	            list.add(vo);
	        
	        }else {
	            LOGGER.error("좌표변환에 실패하였습니다.");
	        }
	    } catch (Exception e) {
	        LOGGER.error(e.getMessage());
	    } finally {
	        closeConnection();
	    }
		
		return list;
	}

	
	/**
	 * 임도, 분포도(래스터이미지)
	 * @param sldId {대상지그룹ID}
	 * @param smid {대상지 고유ID}
	 * @param analId {분석ID}
	 * @param captionNm {테이블ID조회를 위한 키워드}
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createFrdClipRstrImg(String sldId,String smid,String analId, String captionNm, String analType, String mapStyle, String bufferSize, String smid2 ,String pageType) throws Exception{
        List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;

        String mapId = "Map_frd_sat_".concat(analId);//맵 이름

        // 임도 테이블명 조회
		String frdDatasetNm = getLayerName(captionNm);//임도테이블명 가져오기

        // 기존노선
		String frdQuery = null;//임도 where절
		String frdCopyDatasetNm = null; 
		DatasetVector frdCopyDatasetVector = null;

		
		// 수정노선
		String frdModiQuery = null;
		String frdModiCopyDatasetNm = null;
		DatasetVector frdModiCopyDatasetVector = null;
		if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
			frdModiQuery = "smid = ".concat(smid2);
			frdModiCopyDatasetNm = "frdlne_blue_".concat(analId);
			frdModiCopyDatasetVector = null;
		}else {
			frdQuery = "smid = ".concat(smid);//임도 where절
			frdCopyDatasetNm = "frdlne_y_".concat(analId); 
			frdCopyDatasetVector = null;
		}

        //힐쉐이드 테이블명 조회
		String clipRasterDatasetNm = "tf_feis_hillshade";

        // 힐쉐이드 레스터 (전체)
		String clipRasterCopyDatasetNm = "hillshade".concat("_"+analId);
		Dataset clipRasterDataset = null;

		// 힐쉐이드 레스터 (클립)
		String convertClipRasterCopyDatasetNm = "hillshade_3857_".concat(analType).concat("_").concat(analId);
		Dataset convertClipRasterDataset = null;

        // 버퍼 벡터 (전체)
        DatasetVector frdLneBufferDatasetVector = null;
        String frdLneBufferDatasetVectorNm =  "frdLne_buff_".concat(analId);

        // 분석데이터 (전체)
        String clipRasterCopyOverDatasetNm = analType.concat("_"+analId);
		String clipRasterOverDatasetNm = getLayerName(analType);
		Dataset clipRasterOverDataset = null;
		
        // 분석데이터 (클립)
        String convertClipRasterCopyOverDatasetNm = analType+"_3857_".concat(analType).concat("_").concat(analId);
		Dataset convertClipRasterOverDataset = null;

		JSONObject statisticMap = null;

        GeoRegion region = null;
		Rectangle2D newBound = null;
		
        try{
            
            // 슈퍼맵 연결
            getConnectionInfo(analId);

            // Map 생성
            createNewMap(mapId,3857);

            if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
                copyPggisToMemoryUdb(frdDatasetNm,frdModiCopyDatasetNm,frdModiQuery);
            }else {
            	// 기존노선
            	copyPggisToMemoryUdb(frdDatasetNm,frdCopyDatasetNm,frdQuery);
            }

            if(frdCopyDatasetNm != null || frdModiCopyDatasetNm != null) {
				if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
                    frdModiCopyDatasetVector = (DatasetVector) mDatasets.get(frdModiCopyDatasetNm);
				}else {
					frdCopyDatasetVector = (DatasetVector) mDatasets.get(frdCopyDatasetNm);
				}

                frdLneBufferDatasetVector = mDatasets.create(new DatasetVectorInfo(frdLneBufferDatasetVectorNm,DatasetType.REGION),PrjCoordSys.fromEPSG(5186));

                // 버퍼설정 값
                BufferAnalystParameter bap = new BufferAnalystParameter();
                bap.setEndType(BufferEndType.ROUND);
                bap.setRadiusUnit(BufferRadiusUnit.Meter);
                bap.setLeftDistance(bufferSize);
                bap.setRightDistance(bufferSize);
                
                // 병합여부
                boolean isUnion = false;
                // 기존속성값 유무
                boolean isAttributeRetained = false;

                // 버퍼 생성
                boolean isBufferCreated;
                if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
                    isBufferCreated = BufferAnalyst.createBuffer(frdModiCopyDatasetVector, frdLneBufferDatasetVector, bap, isUnion, isAttributeRetained);
                }else {
                    isBufferCreated = BufferAnalyst.createBuffer(frdCopyDatasetVector, frdLneBufferDatasetVector, bap, isUnion, isAttributeRetained);
                }
                if(!isBufferCreated) LOGGER.info("임도 버퍼 생성 실패!");

                //임도라인버퍼데이터셋 레코드셋 조회
				Recordset mFrdLneBufferRecordset = frdLneBufferDatasetVector.query("",CursorType.STATIC);
				GeoRegion frdLneBufferRegion = new GeoRegion();
				
				while (!mFrdLneBufferRecordset.isEOF()) {
					for (int i = 0; i < ((GeoRegion)mFrdLneBufferRecordset.getGeometry()).getPartCount(); i++) {
						frdLneBufferRegion.addPart(((GeoRegion) mFrdLneBufferRecordset.getGeometry()).getPart(i));
					}
					mFrdLneBufferRecordset.moveNext();
				}
				mFrdLneBufferRecordset.dispose();

				Dataset clipRasterData =  datasource.getDatasets().get(clipRasterDatasetNm);
				clipRasterDataset = RasterClip.clip((DatasetGrid)clipRasterData,frdLneBufferRegion, true, false, mDatasource, clipRasterCopyDatasetNm);
				if(clipRasterDataset != null) {
					LOGGER.info("힐쉐이드 레스터 클립 완료");
				}else {
					LOGGER.info("힐쉐이드 레스터 클립 실패");
				}
				clipRasterData.close();
				
				Dataset clipRasterOverData =  datasource.getDatasets().get(clipRasterOverDatasetNm);
				clipRasterOverDataset = RasterClip.clip((DatasetGrid)clipRasterOverData,frdLneBufferRegion, true, false, mDatasource, clipRasterCopyOverDatasetNm);
				if(clipRasterOverDataset != null) {
					LOGGER.info(analType+" 레스터 클립 완료");
				}else {
					LOGGER.info(analType+" 레스터 클립 실패");
				}
				clipRasterOverData.close();

                // 벡터 좌표변환
                coordSysTranslator(frdLneBufferDatasetVector,3857);
                if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
                    coordSysTranslator(frdModiCopyDatasetVector,3857);
                }else {
                	coordSysTranslator(frdCopyDatasetVector,3857);
                }
                // 레스트 좌표변환 (raster는 좌표변환이 boolean타입의 coordSysTranslator로 안돼서 새로운 dataset으로 받아와야해서 아래코드 사용)
                convertClipRasterDataset = CoordSysTranslator.convert(clipRasterDataset, new PrjCoordSys(3857), mDatasource, convertClipRasterCopyDatasetNm,new CoordSysTransParameter(), CoordSysTransMethod.MTH_GEOCENTRIC_TRANSLATION);
				convertClipRasterOverDataset = CoordSysTranslator.convert(clipRasterOverDataset, new PrjCoordSys(3857), mDatasource, convertClipRasterCopyOverDatasetNm,new CoordSysTransParameter(), CoordSysTransMethod.MTH_GEOCENTRIC_TRANSLATION);

                // 이미지 영역 지정
                Recordset mRecordsetBuff = frdLneBufferDatasetVector.query("", CursorType.STATIC);
                Rectangle2D bound = mRecordsetBuff.getBounds();
                double maxlength = bound.getWidth() > bound.getHeight() ? bound.getWidth()*0.4 : bound.getHeight()*0.4;
                
                newBound = new Rectangle2D();
                newBound.setTop(bound.getTop()+maxlength);
                newBound.setBottom(bound.getBottom()-maxlength);
                newBound.setLeft(bound.getLeft()-maxlength);
                newBound.setRight(bound.getRight()+maxlength);
                
                GeoRectangle geoRect = new GeoRectangle(newBound, 0);
                region = geoRect.convertToRegion();

                // 통계치 계산
                statisticMap = caculateStatisticsGrid(convertClipRasterOverDataset, analType, region.getArea());

                // aspect, landslide -> singleBandGrid
				// dem, slope -> ThemeRangeGrid

                vDataset = vDatasets.get("VworldSatellite");
                addLayerImage(vDataset,mapId,"vworld");	// 브이월드 바탕

                if(analType.equals("slope") || analType.equals("dem")) {
					addLayerThemeRangeGrid(convertClipRasterOverDataset,mapId,convertClipRasterCopyOverDatasetNm); //데이터
				}else if(analType.equals("aspect") || analType.equals("landslide")) {
					addLayerSingleBandGrid(convertClipRasterOverDataset,mapId,convertClipRasterCopyOverDatasetNm); //데이터
				}
                addLayerSingleBandGrid(convertClipRasterDataset,mapId,convertClipRasterCopyDatasetNm);	// 힐쉐이드
				if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
					addLayerSingleBandVector(frdModiCopyDatasetVector,mapId,frdModiCopyDatasetNm);	// 수정노선
				}else {
					addLayerSingleBandVector(frdCopyDatasetVector,mapId,frdCopyDatasetNm);	// 임도라인 벡터
				}

                mRecordsetBuff.dispose();

                vo = getSavePath(analId,downloadMidDir);
				
				if(statisticMap != null) {
					vo.setStatData(statisticMap.toString());
				}
				
                vo.setOrignlFileNm(analType);
				vo.setAnalType(analType);
				vo.setSldId(sldId);
				vo.setBufferSize(bufferSize);

				if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
	            	vo.setRouteCode("02");
	            	vo.setSmid(smid2);
	            }else{
	            	vo.setRouteCode("01");
	            	vo.setSmid(smid);
	            }
				
                String templeNm = null; 
				
				if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
					templeNm = "tp_vyt_frd_"+analType+"_r";
				}else {
					templeNm = "tp_vyt_frd_"+analType;
				}
				
				if(setFrdMapLayoutControl(templeNm,mapId,newBound)) {
					AnalFileVO imgVo = saveMapImageToJpg(vo);
					list.add(imgVo);
					
					if(deleted) {
						deleteMap(mapId);
					}
				}

				mExportUdbToFile(convertClipRasterCopyDatasetNm, vo, "tif");
				mExportUdbToFile(convertClipRasterCopyOverDatasetNm, vo, "tif");
				if(smid2 != null && !smid2.isEmpty() && pageType.equals("svyCompt")) {
					mExportUdbToFile(frdModiCopyDatasetNm, vo, "shp");
					frdModiCopyDatasetVector.close();
				}else {
					mExportUdbToFile(frdCopyDatasetNm, vo, "shp");
					frdCopyDatasetVector.close();
				}

                frdLneBufferDatasetVector.close();
				clipRasterDataset.close();
				convertClipRasterDataset.close();
				convertClipRasterOverDataset.close();

                vo.setFileExtsn("zip");
				list.add(vo);
            }else {
				LOGGER.error("좌표변환에 실패하였습니다.");
			}

        }catch (Exception e){
            LOGGER.error(e.getMessage());
        }finally{
            closeConnection();
        }
        return list;
	}
	
	/**
	 * 임도, 조사완료 항목 좌표, create Point and SHP 
	 * @param data1_value 
	 * @param data1_key 
	 * @param lat 
	 * @param lon 
	 * @param analId 
	 * @param sldId {대상지그룹ID}
	 * @param smid {대상지 고유ID}
	 * @param analId {분석ID}
	 * @param captionNm {테이블ID조회를 위한 키워드}
	 * @return
	 * @throws Exception
	 */
	public List<AnalFileVO> createSvyComptPointShp(String smid, String sldId, String lon1, String lat1, String lon2, String lat2, String data1_key, String data1_value, String analId, String analType) throws Exception{
		List<AnalFileVO> list = new ArrayList<AnalFileVO>();
		AnalFileVO vo = null;
		
		String mapId = "Map_frd_sat_".concat(analId);//맵 이름
		
		String pntCopyDatasetNm = "frd_cul_pnt_".concat(analId);
		DatasetVector copyDatasetVector = null;
		
		
		try {
			//슈퍼맵 연결
			getConnectionInfo(analId);
			
			//smwu프로젝트에 Map 생성하기
			createNewMap(mapId,3857);
			
			if(lon1 != null && lat1 != null) {
				
				createDataset("Point", pntCopyDatasetNm);
				
				copyDatasetVector = (DatasetVector) mDatasets.get(pntCopyDatasetNm);
				copyDatasetVector.setPrjCoordSys(PrjCoordSys.fromEPSG(5186));
				
				Point2D pt2d = new Point2D(Double.parseDouble(lon1), Double.parseDouble(lat1));
				Geometry geom = new GeoPoint(pt2d);
				
				FieldInfos lnePntFieldInfos = copyDatasetVector.getFieldInfos();
				
				
				// 조사명
				FieldInfo valueInfo1 = new FieldInfo("조사명", FieldType.TEXT);
				lnePntFieldInfos.add(valueInfo1);
				
				// data1 key 입력
				FieldInfo valueInfo = new FieldInfo(data1_key, FieldType.TEXT);
				lnePntFieldInfos.add(valueInfo);
				
				Recordset pntRecordset = copyDatasetVector.query("",CursorType.DYNAMIC);
				
				pntRecordset.edit();
				pntRecordset.addNew(geom);
				
				// 조사명 입력
				pntRecordset.setString("조사명", analType);
				// data1 값 입력
				pntRecordset.setString(data1_key, data1_value);
				
				
				pntRecordset.update();
				
				vo = getSavePath(analId,downloadMidDir);
                vo.setOrignlFileNm(analType);
				vo.setAnalType(analType);
				vo.setSmid(smid);
				vo.setSldId(sldId);
				
				if(analType.contains("보호시설")) {
					vo.setRouteCode("20");
				}else if(analType.contains("종단기울기")) {
					vo.setRouteCode("21");
				}
				
				
				mExportUdbToFile(pntCopyDatasetNm, vo, "shp");
				
				pntRecordset.dispose();
				pntRecordset.close();
				
				copyDatasetVector.close();
				
				vo.setFileExtsn("zip");
				list.add(vo);
			}
			
			
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		return list;
	}
	/**
	 * intersect
	 * 
	 */
	public boolean OverlayAnalystIntersect(DatasetVector datasetOperated, DatasetVector datasetOperate, Datasource targetDatasource, String copyDatasetNm) {
		
		try {	
		    //intersect 결과 저장을 위한 벡터 생성
		    //String resultDatasetIntersectName = targetDatasource.getDatasets().getAvailableDatasetName(cationNm);
		    DatasetVectorInfo datasetvectorInfoIntersect = new DatasetVectorInfo();
		    datasetvectorInfoIntersect.setType(DatasetType.REGION);
		    datasetvectorInfoIntersect.setName(copyDatasetNm);
		    datasetvectorInfoIntersect.setEncodeType(EncodeType.NONE);
		    
		    DatasetVector resultDatasetIntersect = targetDatasource.getDatasets().create(datasetvectorInfoIntersect);
		    
		    // 오버레이 분석 파라미터 설정
		    OverlayAnalystParameter overlayAnalystParamIntersect = new OverlayAnalystParameter();
		    overlayAnalystParamIntersect.setTolerance(0.0000011074);
		    
		    // intersect하는 메소드를 호출
		    OverlayAnalyst.intersect(datasetOperated, datasetOperate, resultDatasetIntersect, overlayAnalystParamIntersect);
		}catch (Exception e) {
			LOGGER.error(e.getMessage());
		}
	    
		return true;
	}
	
	
	
	/**
	 * Map 생성
	 * @param mapNm
	 */
	public void createNewMap(String mapNm, int epsg) {
		com.supermap.mapping.Map map = new com.supermap.mapping.Map(workspace);
		//map.setPrjCoordSys(getCustomPrj5179(epsg));
		map.setPrjCoordSys(new PrjCoordSys(epsg));
		workspace.getMaps().add(mapNm, map.toXML());
		workspace.getMaps().setMapXML(mapNm, map.toXML());
	}
	
	/**
	 * Map 삭제
	 * @param mapNm
	 */
	public void deleteMap(String mapNm) {
		//workspace.getMaps().get
		workspace.getMaps().remove(mapNm);
	}
	
	private boolean addLayerThemeRangeGrid(Dataset dataset, String mapName, String caption) {
		try {
			DatasetGrid grid =(DatasetGrid) dataset;
			System.out.println(grid.getName());
			
			com.supermap.mapping.Map map = new com.supermap.mapping.Map(workspace);
			map.open(mapName);
			
			ThemeGridRange themeGridRange = getThemeGridRange(caption);
			//ThemeRange themeRange = 
			
			Layer themeLayer = map.getLayers().add(grid,themeGridRange,true);
			
			//map.viewEntire();
			//vectorlayer.setVisible(false);
			themeLayer.setVisible(true);
			workspace.getMaps().setMapXML(mapName, map.toXML());
			map.refresh();
			map.close();
		}catch (Exception e) {
			LOGGER.error(e.getMessage());
		}
		return true;
	}
	
	/**
	 * Map에 테마라벨 맵 추가
	 * @param dataset
	 * @param mapName
	 * @param caption
	 * @return
	 */
	private boolean addLayerThemeLabelVector(Dataset dataset, String mapName, String caption) {
		try {
			DatasetVector vector = (DatasetVector)dataset;
			System.out.println(vector.getName());
			
			com.supermap.mapping.Map map = new com.supermap.mapping.Map(workspace);
			map.open(mapName);
			
			ThemeLabel themeLabel = getThemeLabel(caption);
			//Layer vectorlayer = map.getLayers().add(vector, true);
			Layer themeLayer = map.getLayers().add(vector,themeLabel,true);
			
			//map.viewEntire();
			//vectorlayer.setVisible(false);
			themeLayer.setVisible(true);
			workspace.getMaps().setMapXML(mapName, map.toXML());
			map.refresh();
			map.close();
		}catch (Exception e) {
			LOGGER.error("Map에 TehmeLabelVector DataSet 추가 : "+e.getMessage());
		}
		return true;
	}
	
	/**
	 * Map에 테마맵 추가
	 * @param dataset
	 * @param mapName
	 * @param caption
	 * @return
	 */
	private boolean addLayerThemeUniqueVector(Dataset dataset, String mapName, String caption) {
		try {
			DatasetVector vector = (DatasetVector)dataset;
			System.out.println(vector.getName());
			
			Recordset record = vector.query("",CursorType.STATIC);
			LinkedHashSet<String> exprList = new LinkedHashSet<String>();
			
			if(record.getRecordCount() > 0 ) {
				do {
					//String expr = (String)record.getFieldValue(getUniqueExpr(caption));
					Object getFieldValue = record.getFieldValue(getUniqueExpr(caption));
					
					String expr = getFieldValue != null ? getFieldValue.toString() : null;
					if(expr != null) {
						exprList.add(expr);
					}
				}while(record.moveNext());
			}
			record.dispose();
			
			com.supermap.mapping.Map map = new com.supermap.mapping.Map(workspace);
			map.open(mapName);
			
			ThemeUnique themeUnique = getThemeUnique(caption,exprList);
			//Layer vectorlayer = map.getLayers().add(vector, true);
			Layer themeLayer = map.getLayers().add(vector,themeUnique,true);
			
			//map.viewEntire();
			//vectorlayer.setVisible(false);
			themeLayer.setVisible(true);
			workspace.getMaps().setMapXML(mapName, map.toXML());
			map.refresh();
			map.close();
		}catch (Exception e) {
			LOGGER.error(e.getMessage());
		}
		return true;
	}
	
	private String getUniqueExpr(String caption) {
		String expr = null;
		if(caption.matches("koftr.*")) {
			expr = "koftr_grou";
		}else if(caption.matches("agcls.*")) {
			expr = "agcls_cd";
		}else if(caption.matches("dnst.*")) {
			expr = "dnst_cd";
		}else if(caption.matches("dmcls.*")) {
			expr = "dmcls_cd";
		}else if(caption.matches("ctrln.*")) {
			expr = "cont";
		}else if(caption.matches("nature.*")) {
			expr = "생태자연도";
		}else if(caption.matches("wplgn.*")) {
			expr = "vnara_plgn";
		}else if(caption.matches("wstat.*")) {
			expr = "smid";
		}else if(caption.matches("geological.*")) {
			expr = "분류_2";
		}else if(caption.matches("frd.*")) {//임도전용
			if(caption.indexOf("_frtp_") > 0) {//임상분포도
				expr = "frtp_cd";
			}else if(caption.indexOf("_fror_") > 0) {//임종분포도
				expr = "fror_cd";
			}else if(caption.indexOf("_agcls_") > 0) {//영급분포도
				expr = "agcls_cd";
			}else if(caption.indexOf("_dmcls_") > 0) {//경급분포도
				expr = "dmcls_cd";
			}else if(caption.indexOf("_dnst_") > 0) {//밀도분포도
				expr = "dnst_cd";
			}else if(caption.indexOf("_koftr_") > 0) {//수종분포도
				expr = "koftr_grou";
			}else if(caption.indexOf("_soil_") > 0) {//토성분포도
				expr = "sibflr_scs";
			}else if(caption.indexOf("_geology_") > 0) {//지질분포도
				expr = "refrock";
			}else if(caption.indexOf("_prrck_") > 0) {//모암분포도
				expr = "prrck_larg";
			}else if(caption.indexOf("_accma_") > 0) {//퇴적양식분포도
				expr = "accma_for";
			}else if(caption.indexOf("_rock_") > 0) {//암석노출도
				expr = "rock_exdgr";
			}else if(caption.indexOf("_nature_") > 0) {//생태자연도
				expr = "생태자연도";
			}
		}
		
		return expr;
	}
	
	/**
	 * Label Theme Map 라벨설정
	 * @param caption
	 * @return
	 */
	private ThemeLabel getThemeLabel(String caption) {
		ThemeLabel themeLabel = new ThemeLabel();
		TextStyle textStyle = new TextStyle();
		
		if(caption.matches("lgstr.*")) {
			textStyle.setForeColor(new Color(196,196,196));
//			textStyle.setFontWidth(25);
			textStyle.setFontHeight(2.5);
			textStyle.setSizeFixed(true);
			textStyle.setAlignment(TextAlignment.MIDDLECENTER);
		}else if(caption.matches("rank.*")) {
			textStyle.setForeColor(new Color(0,78,205));
			textStyle.setBackColor(new Color(255,255,255));
//			textStyle.setFontWidth(25);
			textStyle.setBold(true);
			textStyle.setOutline(true);
			textStyle.setOutlineWidth(1);
			textStyle.setFontHeight(3);
			textStyle.setSizeFixed(true);
			textStyle.setAlignment(TextAlignment.MIDDLECENTER);
		}else if(caption.matches("wlgstr.*")) {
			textStyle.setForeColor(new Color(107,107,107));
			textStyle.setFontHeight(2.5);
			textStyle.setSizeFixed(true);
			textStyle.setAlignment(TextAlignment.MIDDLECENTER);
		}else if(caption.matches("ecb.*")) {
			if(caption.indexOf("lgstr") > 0) {
				textStyle.setForeColor(Color.BLACK);
//				textStyle.setFontWidth(25);
				textStyle.setFontHeight(2.5);
				textStyle.setSizeFixed(true);
				textStyle.setAlignment(TextAlignment.MIDDLECENTER);
			}else if(caption.indexOf("sido") > 0) {
				textStyle.setForeColor(Color.BLACK);
				textStyle.setFontHeight(4);
				textStyle.setSizeFixed(true);
				textStyle.setBold(true);
				textStyle.setAlignment(TextAlignment.MIDDLECENTER);
			}else if(caption.indexOf("signgu") > 0) {
				textStyle.setForeColor(Color.BLACK);
				textStyle.setFontHeight(4);
				textStyle.setSizeFixed(true);
				textStyle.setBold(true);
				textStyle.setAlignment(TextAlignment.MIDDLECENTER);
			}else if(caption.indexOf("ecrtcnlcoord") > 0) {
				themeLabel.setBackShape(LabelBackShape.RECT);
				textStyle.setForeColor(Color.BLACK);
				textStyle.setFontHeight(3);
				textStyle.setSizeFixed(true);
				textStyle.setAlignment(TextAlignment.MIDDLECENTER);
			}
		}else if(caption.matches("frd.*")) {
			if(caption.indexOf("_ea_") > 0) {
				textStyle.setForeColor(Color.BLACK);
				textStyle.setFontHeight(3);
				textStyle.setSizeFixed(true);
				textStyle.setAlignment(TextAlignment.MIDDLECENTER);
			}else if(caption.indexOf("_lgstr_") > 0) {
				textStyle.setForeColor(Color.BLACK);
				textStyle.setFontHeight(5);
				textStyle.setBold(true);
				textStyle.setSizeFixed(true);
				textStyle.setAlignment(TextAlignment.MIDDLECENTER);
			}else if(caption.indexOf("_cul_") > 0) {
//				textStyle.setForeColor(new Color(103,165,56));
				textStyle.setForeColor(new Color(103,165,56));
				textStyle.setBackColor(new Color(255,255,255));
//				textStyle.setFontWidth(25);
				textStyle.setBold(true);
				textStyle.setOutline(true);
				textStyle.setOutlineWidth(1);
				textStyle.setFontHeight(3);
				textStyle.setSizeFixed(true);
				textStyle.setAlignment(TextAlignment.MIDDLECENTER);
			}
			
		}
		themeLabel.setLabelExpression(getLabelExpr(caption));
		themeLabel.setUniformStyle(textStyle);
		
		return themeLabel;
	}
	
	/**
	 * Label Theme Map LabelExprssion 설정
	 * @param caption
	 * @return
	 */
	private String getLabelExpr(String caption) {
		String expr = null;
		if(caption.matches("lgstr.*") || caption.matches("wlgstr.*") || caption.matches("ecb_lgstr.*")) {
			expr = "a5";
		}else if(caption.matches("rank.*")) {
			expr = "svy_label";
		}else if(caption.matches("frd.*")) {
			if(caption.indexOf("_ea_") > 0) {
				expr = "emd_nm";
			}else if(caption.indexOf("_lgstr_") > 0) {
				expr = "a5";
			}else if(caption.indexOf("_cul_") > 0) {
				expr = "cult_nm";
			}
		}else if(caption.matches("ecb_sido.*")) {
			expr = "ctprvn_nm";
		}else if(caption.matches("ecb_signgu.*")) {
			expr = "signgu_nm";
		}else if(caption.matches("ecb_ecrtcnlcoord.*")) {
			expr = "coord";
		}
		return expr;
	}
	
	private ThemeGridRange getThemeGridRange(String caption) {
		ThemeGridRange themeGridRange = new ThemeGridRange();
		//themeGridRange.setSpecialValue(-99999);
		themeGridRange.setSpecialValueTransparent(true);
		if(caption.matches("aspect.*")) {
			themeGridRange.addToTail(new ThemeGridRangeItem(-1, 0, new Color(176,176,178), "평지"));
			themeGridRange.addToTail(new ThemeGridRangeItem(0, 22.5, new Color(250,18,20), "북"));
			themeGridRange.addToTail(new ThemeGridRangeItem(22.5, 67.5, new Color(252,170,18), "북동"));
			themeGridRange.addToTail(new ThemeGridRangeItem(67.5, 112.5, new Color(252,255,19), "동"));
			themeGridRange.addToTail(new ThemeGridRangeItem(112.5, 157.5, new Color(6,255,2), "남동"));
			themeGridRange.addToTail(new ThemeGridRangeItem(157.5, 202.5, new Color(43,255,249), "남"));
			themeGridRange.addToTail(new ThemeGridRangeItem(202.5, 247.5, new Color(46,157,254), "남서"));
			themeGridRange.addToTail(new ThemeGridRangeItem(247.5, 292.5, new Color(42,0,247), "서"));
			themeGridRange.addToTail(new ThemeGridRangeItem(292.5, 337.5, new Color(250,0,254), "북서"));
			themeGridRange.addToTail(new ThemeGridRangeItem(337.5, 360, new Color(250,18,20), "북"));
		}else if(caption.matches("slope.*")) {
			themeGridRange.addToTail(new ThemeGridRangeItem(Double.MIN_VALUE, 10, new Color(56,167,0), "10도 미만"));
			themeGridRange.addToTail(new ThemeGridRangeItem(10, 15, new Color(102,191,1), "10~15도"));
			themeGridRange.addToTail(new ThemeGridRangeItem(15, 20, new Color(156,217,0), "15~20도"));
			themeGridRange.addToTail(new ThemeGridRangeItem(20, 25, new Color(222,241,0), "20~25도"));
			themeGridRange.addToTail(new ThemeGridRangeItem(25, 30, new Color(255,221,0), "25~30도"));
			themeGridRange.addToTail(new ThemeGridRangeItem(30, 35, new Color(255,144,0), "30~35도"));
			themeGridRange.addToTail(new ThemeGridRangeItem(35, 40, new Color(255,73,0), "35~40도"));
			themeGridRange.addToTail(new ThemeGridRangeItem(40, Double.MAX_VALUE, new Color(254,0,0), "40도 이상"));
		}else if(caption.matches("dem.*")) {
			themeGridRange.addToTail(new ThemeGridRangeItem(0, 100, new Color(255,255,128), "0~100m"));
			themeGridRange.addToTail(new ThemeGridRangeItem(100, 200, new Color(255,241,116), "100~200m"));
			themeGridRange.addToTail(new ThemeGridRangeItem(200, 300, new Color(252,224,98), "200~300m"));
			themeGridRange.addToTail(new ThemeGridRangeItem(300, 400, new Color(250,209,85), "300~400m"));
			themeGridRange.addToTail(new ThemeGridRangeItem(400, 500, new Color(247,195,73), "400~500m"));
			themeGridRange.addToTail(new ThemeGridRangeItem(500, 600, new Color(245,180,60), "500~600m"));
			themeGridRange.addToTail(new ThemeGridRangeItem(600, 700, new Color(242,168,47), "600~700m"));
			themeGridRange.addToTail(new ThemeGridRangeItem(700, 800, new Color(219,137,37), "700~800m"));
			themeGridRange.addToTail(new ThemeGridRangeItem(800, 900, new Color(196,110,27), "800~900m"));
			themeGridRange.addToTail(new ThemeGridRangeItem(900, 1000, new Color(173,83,20), "900~1000m"));
			themeGridRange.addToTail(new ThemeGridRangeItem(1000, 1100, new Color(150,58,11), "1000~1100m"));
			themeGridRange.addToTail(new ThemeGridRangeItem(1100, 1200, new Color(129,35,7), "1100~1200m"));
			themeGridRange.addToTail(new ThemeGridRangeItem(1200, Double.MAX_VALUE, new Color(108,6,1), "1200m 이상"));
		}else if(caption.matches("landslide.*")) {
			themeGridRange.addToTail(new ThemeGridRangeItem(Double.MIN_VALUE, 1, new Color(254,0,0), "1등급"));
			themeGridRange.addToTail(new ThemeGridRangeItem(1, 2, new Color(255,200,1), "2등급"));
			themeGridRange.addToTail(new ThemeGridRangeItem(2, 3, new Color(182,254,142), "3등급"));
			themeGridRange.addToTail(new ThemeGridRangeItem(3, 4, new Color(51,195,255), "4등급"));
			themeGridRange.addToTail(new ThemeGridRangeItem(4, Double.MAX_VALUE, new Color(0,1,255), "5등급"));
			
			
//			themeGridRange.addToTail(new ThemeGridRangeItem(Double.MIN_VALUE,1.12903225806452, new Color(170,240,233), "1등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(1.12903225806452, 1.25806451612903, new Color(176,242,211), "1등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(1.25806451612903, 1.38709677419355, new Color(176,244,188), "1등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(1.38709677419355, 1.51612903225806, new Color(191,248,178), "1등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(1.51612903225806, 1.64516129032258, new Color(218,251,178), "1등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(1.64516129032258, 1.7741935483871, new Color(237,249,173), "1등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(1.7741935483871 , 1.90322580645161, new Color(220,236,145), "1등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(1.90322580645161, 2.03225806451613, new Color(160,213,103), "2등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(2.03225806451613, 2.16129032258064, new Color(96,189,66), "2등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(2.16129032258064, 2.29032258064516, new Color(44,164,50), "2등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(2.29032258064516, 2.41935483870968, new Color(20,142,53), "2등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(2.41935483870968, 2.54838709677419, new Color(32,133,61), "2등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(2.54838709677419, 2.67741935483871, new Color(85,144,55), "2등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(2.67741935483871, 2.80645161290322, new Color(129,157,47), "2등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(2.80645161290322, 2.93548387096774, new Color(171,168,38), "2등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(2.93548387096774, 3.06451612903226, new Color(215,177,23), "2등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(3.06451612903226, 3.19354838709677, new Color(235,165,9), "3등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(3.19354838709677, 3.32258064516129, new Color(225,131,2), "3등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(3.32258064516129, 3.4516129032258, new Color(203,89,2), "3등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(3.4516129032258 , 3.58064516129032, new Color(197,54,2), "3등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(3.58064516129032, 3.70967741935484, new Color(157,25,1), "3등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(3.70967741935484, 3.83870967741935, new Color(130,12,1), "3등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(3.83870967741935, 3.96774193548387, new Color(118,15,3), "3등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(3.96774193548387, 4.09677419354838, new Color(114,25,6), "4등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(4.09677419354838, 4.2258064516129, new Color(112,32,7), "4등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(4.2258064516129 , 4.35483870967742, new Color(110,40,10), "4등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(4.35483870967742, 4.48387096774193, new Color(106,45,12), "4등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(4.48387096774193, 4.61290322580645, new Color(115,60,27), "4등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(4.61290322580645, 4.74193548387096, new Color(129,80,50), "4등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(4.74193548387096, 4.87096774193548, new Color(142,102,77), "4등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(4.87096774193548, 5, new Color(153,124,108), "5등급"));
//			themeGridRange.addToTail(new ThemeGridRangeItem(5, Double.MAX_VALUE, new Color(166,153,146), "5등급"));
		}
		return themeGridRange;
	}
	
//	private ThemeRange getThemeRange(String caption) {
//		ThemeRange themeRange = new ThemeRange();
//		//themeGridRange.setSpecialValue(-99999);
//		//themeRange.setSpecialValueTransparent(true);
//		if(caption.matches("aspect.*")) {//new ThemeRangeItem(-1, 0, new Color(176,176,178), "평지")
//			themeRange.addToTail(new ThemeRangeItem(-1, 0, new GeoStyle().settion));
//			themeRange.addToTail(new ThemeRangeItem(0, 22.5, new Color(250,18,20), "북"));
//			themeRange.addToTail(new ThemeRangeItem(22.5, 67.5, new Color(252,170,18), "북동"));
//			themeRange.addToTail(new ThemeRangeItem(67.5, 112.5, new Color(252,255,19), "동"));
//			themeRange.addToTail(new ThemeRangeItem(112.5, 157.5, new Color(6,255,2), "남동"));
//			themeRange.addToTail(new ThemeRangeItem(157.5, 202.5, new Color(43,255,249), "남"));
//			themeRange.addToTail(new ThemeRangeItem(202.5, 247.5, new Color(46,157,254), "남서"));
//			themeRange.addToTail(new ThemeRangeItem(247.5, 292.5, new Color(42,0,247), "서"));
//			themeRange.addToTail(new ThemeRangeItem(292.5, 337.5, new Color(250,0,254), "북서"));
//			themeRange.addToTail(new ThemeRangeItem(337.5, 360, new Color(250,18,20), "북"));
//		}else if(caption.matches("slope.*")) {
//			themeRange.addToTail(new ThemeRangeItem(Double.MIN_VALUE, 10, new Color(56,167,0), "10도 미만"));
//			themeRange.addToTail(new ThemeRangeItem(10, 15, new Color(102,191,1), "10~15도"));
//			themeRange.addToTail(new ThemeRangeItem(15, 20, new Color(156,217,0), "15~20도"));
//			themeRange.addToTail(new ThemeRangeItem(20, 25, new Color(222,241,0), "20~25도"));
//			themeRange.addToTail(new ThemeRangeItem(25, 30, new Color(255,221,0), "25~30도"));
//			themeRange.addToTail(new ThemeRangeItem(30, 35, new Color(255,144,0), "30~35도"));
//			themeRange.addToTail(new ThemeRangeItem(35, 40, new Color(255,73,0), "35~40도"));
//			themeRange.addToTail(new ThemeRangeItem(40, Double.MAX_VALUE, new Color(254,0,0), "40도 이상"));
//		}else if(caption.matches("dem.*")) {
//			themeRange.addToTail(new ThemeRangeItem(0, 100, new Color(255,255,128), "0~100m"));
//			themeRange.addToTail(new ThemeRangeItem(100, 200, new Color(255,241,116), "100~200m"));
//			themeRange.addToTail(new ThemeRangeItem(200, 300, new Color(252,224,98), "200~300m"));
//			themeRange.addToTail(new ThemeRangeItem(300, 400, new Color(250,209,85), "300~400m"));
//			themeRange.addToTail(new ThemeRangeItem(400, 500, new Color(247,195,73), "400~500m"));
//			themeRange.addToTail(new ThemeRangeItem(500, 600, new Color(245,180,60), "500~600m"));
//			themeRange.addToTail(new ThemeRangeItem(600, 700, new Color(242,168,47), "600~700m"));
//			themeRange.addToTail(new ThemeRangeItem(700, 800, new Color(219,137,37), "700~800m"));
//			themeRange.addToTail(new ThemeRangeItem(800, 900, new Color(196,110,27), "800~900m"));
//			themeRange.addToTail(new ThemeRangeItem(900, 1000, new Color(173,83,20), "900~1000m"));
//			themeRange.addToTail(new ThemeRangeItem(1000, 1100, new Color(150,58,11), "1000~1100m"));
//			themeRange.addToTail(new ThemeRangeItem(1100, 1200, new Color(129,35,7), "1100~1200m"));
//			themeRange.addToTail(new ThemeRangeItem(1200, Double.MAX_VALUE, new Color(108,6,1), "1200m 이상"));
//		}
//		return themeRange;
//	}
	
	/**
	 * UniqeValue Theme Map 테마설정
	 * @param caption
	 * @param exprlist
	 * @return
	 */
	private ThemeUnique getThemeUnique(String caption,LinkedHashSet<String> exprlist) {
		ThemeUnique themeUnique = new ThemeUnique();
		themeUnique.setDefaultStyleVisible(false);
		
		themeUnique.setUniqueExpression(getUniqueExpr(caption));
		if(caption.matches("koftr.*")) {
			for (String expr : exprlist) {
				if(expr.equals("10")) {themeUnique.add(getItem(new Color(129,94,41), 100,"10","기타침엽수",caption));
				}else if(expr.equals("11")) {themeUnique.add(getItem(new Color(165,145,104), 100,"11","소나무",caption));
				}else if(expr.equals("12")) {themeUnique.add(getItem(new Color(198,154,135), 100,"12","잣나무",caption));
				}else if(expr.equals("13")) {themeUnique.add(getItem(new Color(191,150,119), 100,"13","낙엽송",caption));
				}else if(expr.equals("14")) {themeUnique.add(getItem(new Color(146,107,44), 100,"14","리기다소나무",caption));
				}else if(expr.equals("15")) {themeUnique.add(getItem(new Color(173,135,1), 100,"15","곰솔",caption));
				}else if(expr.equals("16")) {themeUnique.add(getItem(new Color(176,111,0), 100,"16","전나무",caption));
				}else if(expr.equals("17")) {themeUnique.add(getItem(new Color(177,91,0), 100,"17","편백나무",caption));
				}else if(expr.equals("18")) {themeUnique.add(getItem(new Color(153,81,0), 100,"18","삼나무",caption));
				}else if(expr.equals("19")) {themeUnique.add(getItem(new Color(138,66,18), 100,"19","가분비나무",caption));
				}else if(expr.equals("20")) {themeUnique.add(getItem(new Color(198,125,0), 100,"20","비자나무",caption));
				}else if(expr.equals("21")) {themeUnique.add(getItem(new Color(214,179,0), 100,"21","은행나무",caption));
				}else if(expr.equals("30")) {themeUnique.add(getItem(new Color(198,235,97), 100,"30","기타활엽수",caption));
				}else if(expr.equals("31")) {themeUnique.add(getItem(new Color(222,248,41), 100,"31","상수리나무",caption));
				}else if(expr.equals("32")) {themeUnique.add(getItem(new Color(193,220,7), 100,"32","신갈나무",caption));
				}else if(expr.equals("33")) {themeUnique.add(getItem(new Color(149,169,5), 100,"33","굴참나무",caption));
				}else if(expr.equals("34")) {themeUnique.add(getItem(new Color(207,249,66), 100,"34","기타참나무류",caption));
				}else if(expr.equals("35")) {themeUnique.add(getItem(new Color(230,243,0), 100,"35","오리나무",caption));
				}else if(expr.equals("36")) {themeUnique.add(getItem(new Color(230,233,16), 100,"36","고로쇠나무",caption));
				}else if(expr.equals("37")) {themeUnique.add(getItem(new Color(230,213,0), 100,"37","자작나무",caption));
				}else if(expr.equals("38")) {themeUnique.add(getItem(new Color(230,200,0), 100,"38","박달나무",caption));
				}else if(expr.equals("39")) {themeUnique.add(getItem(new Color(175,224,7), 100,"39","밤나무",caption));
				}else if(expr.equals("40")) {themeUnique.add(getItem(new Color(137,175,5), 100,"40","물푸레나무",caption));
				}else if(expr.equals("41")) {themeUnique.add(getItem(new Color(100,129,3), 100,"41","서어나무",caption));
				}else if(expr.equals("42")) {themeUnique.add(getItem(new Color(78,100,2), 100,"42","때죽나무",caption));
				}else if(expr.equals("43")) {themeUnique.add(getItem(new Color(218,237,154), 100,"43","호두나무",caption));
				}else if(expr.equals("44")) {themeUnique.add(getItem(new Color(181,230,51), 100,"44","백합나무",caption));
				}else if(expr.equals("45")) {themeUnique.add(getItem(new Color(158,181,2), 100,"45","포플러",caption));
				}else if(expr.equals("46")) {themeUnique.add(getItem(new Color(131,188,34), 100,"46","벚나무",caption));
				}else if(expr.equals("47")) {themeUnique.add(getItem(new Color(155,186,61), 100,"47","느티나무",caption));
				}else if(expr.equals("48")) {themeUnique.add(getItem(new Color(118,169,32), 100,"48","층층나무",caption));
				}else if(expr.equals("49")) {themeUnique.add(getItem(new Color(0,149,55), 100,"49","아까시나무",caption));
				}else if(expr.equals("60")) {themeUnique.add(getItem(new Color(33,102,139), 100,"60","기타상록활엽수",caption));
				}else if(expr.equals("61")) {themeUnique.add(getItem(new Color(179,225,172), 100,"61","가시나무",caption));
				}else if(expr.equals("62")) {themeUnique.add(getItem(new Color(179,222,105), 100,"62","구실잣밤나무",caption));
				}else if(expr.equals("63")) {themeUnique.add(getItem(new Color(179,220,16), 100,"63","녹나무",caption));
				}else if(expr.equals("64")) {themeUnique.add(getItem(new Color(102,184,33), 100,"64","굴거리나무",caption));
				}else if(expr.equals("65")) {themeUnique.add(getItem(new Color(102,189,108), 100,"65","황칠나무",caption));
				}else if(expr.equals("66")) {themeUnique.add(getItem(new Color(102,194,165), 100,"66","사스레피나무",caption));
				}else if(expr.equals("67")) {themeUnique.add(getItem(new Color(0,153,155), 100,"67","후박나무",caption));
				}else if(expr.equals("68")) {themeUnique.add(getItem(new Color(0,146,112), 100,"68","새덕이",caption));
				}else if(expr.equals("77")) {themeUnique.add(getItem(new Color(155,192,41), 100,"77","침활혼효림",caption));
				}else if(expr.equals("78")) {themeUnique.add(getItem(new Color(217,182,115), 100,"78","죽림",caption));
				}else if(expr.equals("81")) {themeUnique.add(getItem(new Color(204,204,204), 100,"81","미립목지",caption));
				}else if(expr.equals("82")) {themeUnique.add(getItem(new Color(228,177,155), 100,"82","제지",caption));
				}else if(expr.equals("83")) {themeUnique.add(getItem(new Color(236,249,199), 100,"83","관목덤불",caption));
				}else if(expr.equals("91")) {themeUnique.add(getItem(new Color(254,246,164), 100,"91","주거지",caption));
				}else if(expr.equals("92")) {themeUnique.add(getItem(new Color(170,218,50), 100,"92","초지",caption));
				}else if(expr.equals("93")) {themeUnique.add(getItem(new Color(219,205,0), 100,"93","경작지",caption));
				}else if(expr.equals("94")) {themeUnique.add(getItem(new Color(190,210,255), 100,"94","수체",caption));
				}else if(expr.equals("95")) {themeUnique.add(getItem(new Color(217,125,23), 100,"95","과수원",caption));
				}else if(expr.equals("99")) {themeUnique.add(getItem(new Color(255,255,193), 100,"99","기타",caption));}
			}
		}else if(caption.matches("agcls.*")) {
			for (String expr : exprlist) {
				if(expr.equals("1")) {
					themeUnique.add(getItem(new Color(53,130,53), 100,"1","1영급",caption));
				}else if(expr.equals("2")) {
					themeUnique.add(getItem(new Color(63,140,63), 100,"2","2영급",caption));
				}else if(expr.equals("3")) {
					themeUnique.add(getItem(new Color(73,150,73), 100,"3","3영급",caption));
				}else if(expr.equals("4")) {
					themeUnique.add(getItem(new Color(83,160,83), 100,"4","4영급",caption));
				}else if(expr.equals("5")) {
					themeUnique.add(getItem(new Color(93,170,93), 100,"5","5영급",caption));
				}else if(expr.equals("6")) {
					themeUnique.add(getItem(new Color(103,180,103), 100,"6","6영급",caption));
				}else if(expr.equals("7")) {
					themeUnique.add(getItem(new Color(129,193,129), 100,"7","7영급",caption));
				}else if(expr.equals("8")) {
					themeUnique.add(getItem(new Color(146,202,146), 100,"8","8영급",caption));
				}else if(expr.equals("9")) {
					themeUnique.add(getItem(new Color(173,215,173), 100,"9","9영급",caption));
				}
			}
		}else if(caption.matches("dnst.*")) {
			for (String expr : exprlist) {
				if(expr.equals("A")) {
					themeUnique.add(getItem(new Color(0,236,118), 100,"A","소",caption));
				}else if(expr.equals("B")) {
					themeUnique.add(getItem(new Color(0,196,118), 100,"B","중",caption));
				}else if(expr.equals("C")) {
					themeUnique.add(getItem(new Color(0,156,118), 100,"C","밀",caption));
				}
			}
		}else if(caption.matches("dmcls.*")) {
			for (String expr : exprlist) {
				if(expr.equals("0")) {
					themeUnique.add(getItem(new Color(252,213,181), 100,"0","치수",caption));
				}else if(expr.equals("1")) {
					themeUnique.add(getItem(new Color(250,192,144), 100,"1","소경목",caption));
				}else if(expr.equals("2")) {
					themeUnique.add(getItem(new Color(228,108,10), 100,"2","중경목",caption));
				}else if(expr.equals("3")) {
					themeUnique.add(getItem(new Color(152,72,7), 100,"3","대경목",caption));
				}
			}
		}else if(caption.matches("ctrln.*")) {
			for (String expr : exprlist) {
				double cont = Double.parseDouble(expr);
				if(cont%100 == 0) {
					themeUnique.add(getItem(new Color(185,93,49), 100,expr,expr,caption));
				}else if(cont%20 == 0){
					themeUnique.add(getItem(new Color(255,192,162), 100,expr,expr,caption));
				}
			}
		}else if(caption.matches("nature.*")) {
			themeUnique.add(getItem(new Color(47,152,47), 100,"1","1등급",caption));
			themeUnique.add(getItem(new Color(207,227,201), 100,"2","2등급",caption));
			themeUnique.add(getItem(new Color(255,255,255), 100,"3","3등급",caption));
		}else if(caption.matches("wplgn.*")) {
			themeUnique.add(getItem(new Color(3,4,189), 0,"01","사방댐",caption));
			themeUnique.add(getItem(new Color(244,209,111), 0,"02","계류보전",caption));
			themeUnique.add(getItem(new Color(3,4,189), 0,"03","유역면적",caption));
			themeUnique.add(getItem(new Color(211,34,4), 0,"04","산지사방",caption));
		}else if(caption.matches("wstat.*")) {
			themeUnique.add(getItem(new Color(255,255,255), 100,"1","1",caption));
			themeUnique.add(getItem(new Color(255,255,255), 100,"2","2",caption));
			themeUnique.add(getItem(new Color(255,255,255), 100,"3","3",caption));
			themeUnique.add(getItem(new Color(255,255,255), 100,"4","4",caption));
			themeUnique.add(getItem(new Color(255,255,255), 100,"5","5",caption));
			themeUnique.add(getItem(new Color(255,255,255), 100,"6","6",caption));
			themeUnique.add(getItem(new Color(255,255,255), 100,"7","7",caption));
			themeUnique.add(getItem(new Color(255,255,255), 100,"8","8",caption));
			themeUnique.add(getItem(new Color(255,255,255), 100,"9","9",caption));
		}else if(caption.matches("geological.*")) {
			for (String expr : exprlist) {
				if(expr.equals("1")) {
					themeUnique.add(getItem(new Color(155,187,89), 100,"1","화성암",caption));
				}else if(expr.equals("2")) {
					themeUnique.add(getItem(new Color(75,172,198), 100,"2","퇴적암",caption));
				}else if(expr.equals("3")) {
					themeUnique.add(getItem(new Color(192,80,77), 100,"3","변성암",caption));
				}
			}
		}else if(caption.matches("frd_.*")) {
			if(caption.indexOf("_frtp_") > 0) {	// 임상
				for (String expr : exprlist) {
					if(expr.equals("0")) {themeUnique.add(getItem(new Color(205,205,205), 100,"0","무립지/비산림",caption));
					}else if(expr.equals("1")) {themeUnique.add(getItem(new Color(35,123,0), 100,"1","침엽수림",caption));
					}else if(expr.equals("2")) {themeUnique.add(getItem(new Color(66,211,0), 100,"2","활엽수림",caption));
					}else if(expr.equals("3")) {themeUnique.add(getItem(new Color(96,142,86), 100,"3","혼효림",caption));
					}else if(expr.equals("4")) {themeUnique.add(getItem(new Color(247,240,200), 100,"4","죽림",caption));
					}
				}
			}else if(caption.indexOf("_fror_") > 0) { //임종
				for (String expr : exprlist) {
					if(expr.equals("0")) {themeUnique.add(getItem(new Color(205,205,205), 100,"0","무립지/비산림",caption));
					}else if(expr.equals("1")) {themeUnique.add(getItem(new Color(255,255,128), 100,"1","임공림",caption));
					}else if(expr.equals("2")) {themeUnique.add(getItem(new Color(154,212,127), 100,"2","천연림",caption));
					}
				}
			}else if(caption.indexOf("_agcls_") > 0) { //영급
				for (String expr : exprlist) {
					if(expr.equals("1")) {themeUnique.add(getItem(new Color(53,130,53), 100,"1","1영급",caption));
					}else if(expr.equals("2")) {themeUnique.add(getItem(new Color(63,140,63), 100,"2","2영급",caption));
					}else if(expr.equals("3")) {themeUnique.add(getItem(new Color(73,150,73), 100,"3","3영급",caption));
					}else if(expr.equals("4")) {themeUnique.add(getItem(new Color(83,160,83), 100,"4","4영급",caption));
					}else if(expr.equals("5")) {themeUnique.add(getItem(new Color(93,170,93), 100,"5","5영급",caption));
					}else if(expr.equals("6")) {themeUnique.add(getItem(new Color(103,180,103), 100,"6","6영급",caption));
					}else if(expr.equals("7")) {themeUnique.add(getItem(new Color(129,193,129), 100,"7","7영급",caption));
					}else if(expr.equals("8")) {themeUnique.add(getItem(new Color(146,202,146), 100,"8","8영급",caption));
					}else if(expr.equals("9")) {themeUnique.add(getItem(new Color(173,215,173), 100,"9","9영급",caption));
					}
				}
			}else if(caption.indexOf("_dmcls_") > 0) { //경급
				for (String expr : exprlist) {
					if(expr.equals("0")) {themeUnique.add(getItem(new Color(154,212,127), 100,"0","치수",caption));
					}else if(expr.equals("1")) {themeUnique.add(getItem(new Color(216,240,128), 100,"1","소경목",caption));
					}else if(expr.equals("2")) {themeUnique.add(getItem(new Color(254,212,128), 100,"2","중경목",caption));
					}else if(expr.equals("3")) {themeUnique.add(getItem(new Color(254,128,129), 100,"3","대경목",caption));
					}
				}
			}else if(caption.indexOf("_dnst_") > 0) { //밀도
				for (String expr : exprlist) {
					if(expr.equals("A")) {themeUnique.add(getItem(new Color(232,255,185), 100,"A","소",caption));
					}else if(expr.equals("B")) {themeUnique.add(getItem(new Color(204,243,128), 100,"B","중",caption));
					}else if(expr.equals("C")) {themeUnique.add(getItem(new Color(166,185,129), 100,"C","밀",caption));
					}
				}
			}else if(caption.indexOf("_koftr_") > 0) { //수종
				for (String expr : exprlist) {
					if(expr.equals("10")) {themeUnique.add(getItem(new Color(129,94,41), 100,"10","기타침엽수",caption));
					}else if(expr.equals("11")) {themeUnique.add(getItem(new Color(165,145,104), 100,"11","소나무",caption));
					}else if(expr.equals("12")) {themeUnique.add(getItem(new Color(198,154,135), 100,"12","잣나무",caption));
					}else if(expr.equals("13")) {themeUnique.add(getItem(new Color(191,150,119), 100,"13","낙엽송",caption));
					}else if(expr.equals("14")) {themeUnique.add(getItem(new Color(146,107,44), 100,"14","리기다소나무",caption));
					}else if(expr.equals("15")) {themeUnique.add(getItem(new Color(173,135,1), 100,"15","곰솔",caption));
					}else if(expr.equals("16")) {themeUnique.add(getItem(new Color(176,111,0), 100,"16","전나무",caption));
					}else if(expr.equals("17")) {themeUnique.add(getItem(new Color(177,91,0), 100,"17","편백나무",caption));
					}else if(expr.equals("18")) {themeUnique.add(getItem(new Color(153,81,0), 100,"18","삼나무",caption));
					}else if(expr.equals("19")) {themeUnique.add(getItem(new Color(138,66,18), 100,"19","가분비나무",caption));
					}else if(expr.equals("20")) {themeUnique.add(getItem(new Color(198,125,0), 100,"20","비자나무",caption));
					}else if(expr.equals("21")) {themeUnique.add(getItem(new Color(214,179,0), 100,"21","은행나무",caption));
					}else if(expr.equals("30")) {themeUnique.add(getItem(new Color(198,235,97), 100,"30","기타활엽수",caption));
					}else if(expr.equals("31")) {themeUnique.add(getItem(new Color(222,248,41), 100,"31","상수리나무",caption));
					}else if(expr.equals("32")) {themeUnique.add(getItem(new Color(193,220,7), 100,"32","신갈나무",caption));
					}else if(expr.equals("33")) {themeUnique.add(getItem(new Color(149,169,5), 100,"33","굴참나무",caption));
					}else if(expr.equals("34")) {themeUnique.add(getItem(new Color(207,249,66), 100,"34","기타참나무류",caption));
					}else if(expr.equals("35")) {themeUnique.add(getItem(new Color(230,243,0), 100,"35","오리나무",caption));
					}else if(expr.equals("36")) {themeUnique.add(getItem(new Color(230,233,16), 100,"36","고로쇠나무",caption));
					}else if(expr.equals("37")) {themeUnique.add(getItem(new Color(230,213,0), 100,"37","자작나무",caption));
					}else if(expr.equals("38")) {themeUnique.add(getItem(new Color(230,200,0), 100,"38","박달나무",caption));
					}else if(expr.equals("39")) {themeUnique.add(getItem(new Color(175,224,7), 100,"39","밤나무",caption));
					}else if(expr.equals("40")) {themeUnique.add(getItem(new Color(137,175,5), 100,"40","물푸레나무",caption));
					}else if(expr.equals("41")) {themeUnique.add(getItem(new Color(100,129,3), 100,"41","서어나무",caption));
					}else if(expr.equals("42")) {themeUnique.add(getItem(new Color(78,100,2), 100,"42","때죽나무",caption));
					}else if(expr.equals("43")) {themeUnique.add(getItem(new Color(218,237,154), 100,"43","호두나무",caption));
					}else if(expr.equals("44")) {themeUnique.add(getItem(new Color(181,230,51), 100,"44","백합나무",caption));
					}else if(expr.equals("45")) {themeUnique.add(getItem(new Color(158,181,2), 100,"45","포플러",caption));
					}else if(expr.equals("46")) {themeUnique.add(getItem(new Color(131,188,34), 100,"46","벚나무",caption));
					}else if(expr.equals("47")) {themeUnique.add(getItem(new Color(155,186,61), 100,"47","느티나무",caption));
					}else if(expr.equals("48")) {themeUnique.add(getItem(new Color(118,169,32), 100,"48","층층나무",caption));
					}else if(expr.equals("49")) {themeUnique.add(getItem(new Color(0,149,55), 100,"49","아까시나무",caption));
					}else if(expr.equals("60")) {themeUnique.add(getItem(new Color(33,102,139), 100,"60","기타상록활엽수",caption));
					}else if(expr.equals("61")) {themeUnique.add(getItem(new Color(179,225,172), 100,"61","가시나무",caption));
					}else if(expr.equals("62")) {themeUnique.add(getItem(new Color(179,222,105), 100,"62","구실잣밤나무",caption));
					}else if(expr.equals("63")) {themeUnique.add(getItem(new Color(179,220,16), 100,"63","녹나무",caption));
					}else if(expr.equals("64")) {themeUnique.add(getItem(new Color(102,184,33), 100,"64","굴거리나무",caption));
					}else if(expr.equals("65")) {themeUnique.add(getItem(new Color(102,189,108), 100,"65","황칠나무",caption));
					}else if(expr.equals("66")) {themeUnique.add(getItem(new Color(102,194,165), 100,"66","사스레피나무",caption));
					}else if(expr.equals("67")) {themeUnique.add(getItem(new Color(0,153,155), 100,"67","후박나무",caption));
					}else if(expr.equals("68")) {themeUnique.add(getItem(new Color(0,146,112), 100,"68","새덕이",caption));
					}else if(expr.equals("77")) {themeUnique.add(getItem(new Color(155,192,41), 100,"77","침활혼효림",caption));
					}else if(expr.equals("78")) {themeUnique.add(getItem(new Color(217,182,115), 100,"78","죽림",caption));
					}else if(expr.equals("81")) {themeUnique.add(getItem(new Color(204,204,204), 100,"81","미립목지",caption));
					}else if(expr.equals("82")) {themeUnique.add(getItem(new Color(228,177,155), 100,"82","제지",caption));
					}else if(expr.equals("83")) {themeUnique.add(getItem(new Color(236,249,199), 100,"83","관목덤불",caption));
					}else if(expr.equals("91")) {themeUnique.add(getItem(new Color(254,246,164), 100,"91","주거지",caption));
					}else if(expr.equals("92")) {themeUnique.add(getItem(new Color(170,218,50), 100,"92","초지",caption));
					}else if(expr.equals("93")) {themeUnique.add(getItem(new Color(219,205,0), 100,"93","경작지",caption));
					}else if(expr.equals("94")) {themeUnique.add(getItem(new Color(190,210,255), 100,"94","수체",caption));
					}else if(expr.equals("95")) {themeUnique.add(getItem(new Color(217,125,23), 100,"95","과수원",caption));
					}else if(expr.equals("99")) {themeUnique.add(getItem(new Color(255,255,193), 100,"99","기타",caption));}
				}
			}else if(caption.indexOf("_soil_") > 0) { //토성
				for (String expr : exprlist) {
					if(expr.equals("01")) {themeUnique.add(getItem(new Color(204,194,169), 100,"01","사양토",caption));
					}else if(expr.equals("02")) {themeUnique.add(getItem(new Color(242,227,184), 100,"02","양토",caption));
					}else if(expr.equals("03")) {themeUnique.add(getItem(new Color(242,209,194), 100,"03","미사질양토",caption));
					}else if(expr.equals("04")) {themeUnique.add(getItem(new Color(215,205,175), 100,"04","미사질식양토",caption));
					}else if(expr.equals("05")) {themeUnique.add(getItem(new Color(225,214,185), 100,"05","사질식양토",caption));
					}else if(expr.equals("06")) {themeUnique.add(getItem(new Color(235,223,195), 100,"06","미사질식토",caption));
					}else if(expr.equals("07")) {themeUnique.add(getItem(new Color(245,232,205), 100,"07","식양토",caption));
					}else if(expr.equals("08")) {themeUnique.add(getItem(new Color(255,241,215), 100,"08","미사",caption));
					}else if(expr.equals("09")) {themeUnique.add(getItem(new Color(220,230,175), 100,"09","양질사토",caption));
					}else if(expr.equals("10")) {themeUnique.add(getItem(new Color(230,240,185), 100,"10","사토",caption));
					}else if(expr.equals("11")) {themeUnique.add(getItem(new Color(240,250,195), 100,"11","점토",caption));
					}else if(expr.equals("99")) {themeUnique.add(getItem(new Color(250,255,205), 100,"99","기타",caption));
					}
				}
			}else if(caption.indexOf("_geology_") > 0) { //지질분포도
				//추후 정보 받으면 추가해야함
				for (String expr : exprlist) {
					if(expr.equals("각섬석화강암")) {themeUnique.add(getItem(new Color(48,8,82), 100,"각섬석화강암","각섬석화강암",caption));
					}else if(expr.equals("각섬암")) {themeUnique.add(getItem(new Color(159,157,184), 100,"각섬암","각섬암",caption));
					}else if(expr.equals("갈두층")) {themeUnique.add(getItem(new Color(164,31,83), 100,"갈두층","갈두층",caption));
					}else if(expr.equals("격포리층")) {themeUnique.add(getItem(new Color(64,129,204), 100,"격포리층","격포리층",caption));
					}else if(expr.equals("고성층")) {themeUnique.add(getItem(new Color(88,32,193), 100,"고성층","고성층",caption));
					}else if(expr.equals("규암")) {themeUnique.add(getItem(new Color(221,150,244), 100,"규암","규암",caption));
					}else if(expr.equals("길왕리층")) {themeUnique.add(getItem(new Color(121,51,146), 100,"길왕리층","길왕리층",caption));
					}else if(expr.equals("낙동층")) {themeUnique.add(getItem(new Color(20,39,241), 100,"낙동층","낙동층",caption));
					}else if(expr.equals("달길층")) {themeUnique.add(getItem(new Color(166,117,140), 100,"달길층","달길층",caption));
					}else if(expr.equals("덕용산규암")) {themeUnique.add(getItem(new Color(222,198,200), 100,"덕용산규암","덕용산규암",caption));
					}else if(expr.equals("두무진층")) {themeUnique.add(getItem(new Color(227,42,75), 100,"두무진층","두무진층",caption));
					}else if(expr.equals("두원층")) {themeUnique.add(getItem(new Color(185,238,99), 100,"두원층","두원층",caption));
					}else if(expr.equals("류문암,류문암질응회암")) {themeUnique.add(getItem(new Color(47,72,73), 100,"류문암,류문암질응회암","류문암,류문암질응회암",caption));
					}else if(expr.equals("마이산층")) {themeUnique.add(getItem(new Color(90,2,86), 100,"마이산층","마이산층",caption));
					}else if(expr.equals("만덕산층")) {themeUnique.add(getItem(new Color(175,134,153), 100,"만덕산층","만덕산층",caption));
					}else if(expr.equals("매립지")) {themeUnique.add(getItem(new Color(36,211,39), 100,"매립지","매립지",caption));
					}else if(expr.equals("맥암")) {themeUnique.add(getItem(new Color(207,143,11), 100,"맥암","맥암",caption));
					}else if(expr.equals("면수산규암")) {themeUnique.add(getItem(new Color(230,255,113), 100,"면수산규암","면수산규암",caption));
					}else if(expr.equals("문수산층")) {themeUnique.add(getItem(new Color(13,134,82), 100,"문수산층","문수산층",caption));
					}else if(expr.equals("미고결 퇴적층")) {themeUnique.add(getItem(new Color(148,132,207), 100,"미고결 퇴적층","미고결 퇴적층",caption));
					}else if(expr.equals("미그마타이트질 편마암")) {themeUnique.add(getItem(new Color(146,246,155), 100,"미그마타이트질 편마암","미그마타이트질 편마암",caption));
					}else if(expr.equals("미그마타이트질편마암")) {themeUnique.add(getItem(new Color(34,188,23), 100,"미그마타이트질편마암","미그마타이트질편마암",caption));
					}else if(expr.equals("박달령화강편마암")) {themeUnique.add(getItem(new Color(183,34,107), 100,"박달령화강편마암","박달령화강편마암",caption));
					}else if(expr.equals("반려암")) {themeUnique.add(getItem(new Color(82,157,146), 100,"반려암","반려암",caption));
					}else if(expr.equals("반상변성질편마암")) {themeUnique.add(getItem(new Color(170,243,54), 100,"반상변성질편마암","반상변성질편마암",caption));
					}else if(expr.equals("반상변성질편편마암")) {themeUnique.add(getItem(new Color(188,85,203), 100,"반상변성질편편마암","반상변성질편편마암",caption));
					}else if(expr.equals("반상변정질편마암")) {themeUnique.add(getItem(new Color(18,75,6), 100,"반상변정질편마암","반상변정질편마암",caption));
					}else if(expr.equals("반상화강암")) {themeUnique.add(getItem(new Color(39,202,224), 100,"반상화강암","반상화강암",caption));
					}else if(expr.equals("반송층군")) {themeUnique.add(getItem(new Color(5140109), 100,"반송층군","반송층군",caption));
					}else if(expr.equals("반송층군 대동층군")) {themeUnique.add(getItem(new Color(89,72,111), 100,"반송층군/대동층군","반송층군/대동층군",caption));
					}else if(expr.equals("반암류")) {themeUnique.add(getItem(new Color(48,80,236), 100,"반암류","반암류",caption));
					}else if(expr.equals("반휘암")) {themeUnique.add(getItem(new Color(253,116,225), 100,"반휘암","반휘암",caption));
					}else if(expr.equals("방림층군")) {themeUnique.add(getItem(new Color(111,172,107), 100,"방림층군","방림층군",caption));
					}else if(expr.equals("방이리층")) {themeUnique.add(getItem(new Color(155,188,204), 100,"방이리층","방이리층",caption));
					}else if(expr.equals("변성사질암")) {themeUnique.add(getItem(new Color(76,206,147), 100,"변성사질암","변성사질암",caption));
					}else if(expr.equals("변성사질암대")) {themeUnique.add(getItem(new Color(32,158,140), 100,"변성사질암대","변성사질암대",caption));
					}else if(expr.equals("변성사질암류")) {themeUnique.add(getItem(new Color(146,28,4), 100,"변성사질암류","변성사질암류",caption));
					}else if(expr.equals("변성석영반암")) {themeUnique.add(getItem(new Color(101,105,233), 100,"변성석영반암","변성석영반암",caption));
					}else if(expr.equals("변성화산암류")) {themeUnique.add(getItem(new Color(71,8,174), 100,"변성화산암류","변성화산암류",caption));
					}else if(expr.equals("부산반상질화강편마암")) {themeUnique.add(getItem(new Color(75,49,0), 100,"부산반상질화강편마암","부산반상질화강편마암",caption));
					}else if(expr.equals("북평층군")) {themeUnique.add(getItem(new Color(191,112,189), 100,"북평층군","북평층군",caption));
					}else if(expr.equals("분천 화강편마암")) {themeUnique.add(getItem(new Color(229,179,22), 100,"분천 화강편마암","분천 화강편마암",caption));
					}else if(expr.equals("사문암")) {themeUnique.add(getItem(new Color(1,55,162), 100,"사문암","사문암",caption));
					}else if(expr.equals("사암 및 이암")) {themeUnique.add(getItem(new Color(140,239,178), 100,"사암 및 이암","사암 및 이암",caption));
					}else if(expr.equals("사암및셰일")) {themeUnique.add(getItem(new Color(114,52,10), 100,"사암및셰일","사암및셰일",caption));
					}else if(expr.equals("사암및응회암")) {themeUnique.add(getItem(new Color(81,60,201), 100,"사암및응회암","사암및응회암",caption));
					}else if(expr.equals("사암및이암")) {themeUnique.add(getItem(new Color(216,15,116), 100,"사암및이암","사암및이암",caption));
					}else if(expr.equals("산성맥암류")) {themeUnique.add(getItem(new Color(73,246,109), 100,"산성맥암류","산성맥암류",caption));
					}else if(expr.equals("산성반암")) {themeUnique.add(getItem(new Color(85,241,40), 100,"산성반암","산성반암",caption));
					}else if(expr.equals("산성암")) {themeUnique.add(getItem(new Color(144,99,207), 100,"산성암","산성암",caption));
					}else if(expr.equals("산성암맥")) {themeUnique.add(getItem(new Color(51,89,176), 100,"산성암맥","산성암맥",caption));
					}else if(expr.equals("산성화강암류")) {themeUnique.add(getItem(new Color(206,74,183), 100,"산성화강암류","산성화강암류",caption));
					}else if(expr.equals("산성화산암")) {themeUnique.add(getItem(new Color(206,105,106), 100,"산성화산암","산성화산암",caption));
					}else if(expr.equals("산성화산암류")) {themeUnique.add(getItem(new Color(182,45,173), 100,"산성화산암류","산성화산암류",caption));
					}else if(expr.equals("산수동층")) {themeUnique.add(getItem(new Color(53,141,166), 100,"산수동층","산수동층",caption));
					}else if(expr.equals("상부남포층군(성주리층)")) {themeUnique.add(getItem(new Color(255,189,57), 100,"상부남포층군(성주리층)","상부남포층군(성주리층)",caption));
					}else if(expr.equals("상부대석회암층군")) {themeUnique.add(getItem(new Color(41,85,184), 100,"상부대석회암층군","상부대석회암층군",caption));
					}else if(expr.equals("상부연일층군")) {themeUnique.add(getItem(new Color(143,112,119), 100,"상부연일층군","상부연일층군",caption));
					}else if(expr.equals("상부천매암")) {themeUnique.add(getItem(new Color(143,164,82), 100,"상부천매암","상부천매암",caption));
					}else if(expr.equals("상부천매암대")) {themeUnique.add(getItem(new Color(254,156,39), 100,"상부천매암대","상부천매암대",caption));
					}else if(expr.equals("상부평안층군")) {themeUnique.add(getItem(new Color(215,167,97), 100,"상부평안층군","상부평안층군",caption));
					}else if(expr.equals("서귀포층")) {themeUnique.add(getItem(new Color(21,209,42), 100,"서귀포층","서귀포층",caption));
					}else if(expr.equals("석문층")) {themeUnique.add(getItem(new Color(79,234,80), 100,"석문층","석문층",caption));
					}else if(expr.equals("석영반암")) {themeUnique.add(getItem(new Color(0,135,219), 100,"석영반암","석영반암",caption));
					}else if(expr.equals("석회암")) {themeUnique.add(getItem(new Color(146,189,228), 100,"석회암","석회암",caption));
					}else if(expr.equals("석회암대")) {themeUnique.add(getItem(new Color(26,200,189), 100,"석회암대","석회암대",caption));
					}else if(expr.equals("선소층")) {themeUnique.add(getItem(new Color(222,178,112), 100,"선소층","선소층",caption));
					}else if(expr.equals("설옥리층")) {themeUnique.add(getItem(new Color(193,22,0), 100,"설옥리층","설옥리층",caption));
					}else if(expr.equals("섬록암")) {themeUnique.add(getItem(new Color(22,19,183), 100,"섬록암","섬록암",caption));
					}else if(expr.equals("섬장암")) {themeUnique.add(getItem(new Color(174,22,180), 100,"섬장암","섬장암",caption));
					}else if(expr.equals("세립질화강암")) {themeUnique.add(getItem(new Color(134,213,160), 100,"세립질화강암","세립질화강암",caption));
					}else if(expr.equals("신라력암")) {themeUnique.add(getItem(new Color(233,25,231), 100,"신라력암","신라력암",caption));
					}else if(expr.equals("신라역암")) {themeUnique.add(getItem(new Color(86,175,63), 100,"신라역암","신라역암",caption));
					}else if(expr.equals("신성리층")) {themeUnique.add(getItem(new Color(72,53,77), 100,"신성리층","신성리층",caption));
					}else if(expr.equals("안구장편마암")) {themeUnique.add(getItem(new Color(151,181,116), 100,"안구장편마암","안구장편마암",caption));
					}else if(expr.equals("안산암")) {themeUnique.add(getItem(new Color(229,57,184), 100,"안산암","안산암",caption));
					}else if(expr.equals("안산암,안산암질응회암")) {themeUnique.add(getItem(new Color(183,65,78), 100,"안산암,안산암질응회암","안산암,안산암질응회암",caption));
					}else if(expr.equals("안산암및안산암질응회암")) {themeUnique.add(getItem(new Color(172,225,11), 100,"안산암및안산암질응회암","안산암및안산암질응회암",caption));
					}else if(expr.equals("양덕층군")) {themeUnique.add(getItem(new Color(187,152,231), 100,"양덕층군","양덕층군",caption));
					}else if(expr.equals("양평화성복합체")) {themeUnique.add(getItem(new Color(209,166,246), 100,"양평화성복합체","양평화성복합체",caption));
					}else if(expr.equals("어일층군")) {themeUnique.add(getItem(new Color(69,217,118), 100,"어일층군","어일층군",caption));
					}else if(expr.equals("역암")) {themeUnique.add(getItem(new Color(131,209,115), 100,"역암","역암",caption));
					}else if(expr.equals("역암 및 사암")) {themeUnique.add(getItem(new Color(129,45,253), 100,"역암 및 사암","역암 및 사암",caption));
					}else if(expr.equals("역질사암")) {themeUnique.add(getItem(new Color(162,212,243), 100,"역질사암","역질사암",caption));
					}else if(expr.equals("염기성화산암")) {themeUnique.add(getItem(new Color(75,137,41), 100,"염기성화산암","염기성화산암",caption));
					}else if(expr.equals("엽리상화강암")) {themeUnique.add(getItem(new Color(207,42,30), 100,"엽리상화강암","엽리상화강암",caption));
					}else if(expr.equals("엽리상화강암류")) {themeUnique.add(getItem(new Color(117,55,229), 100,"엽리상화강암류","엽리상화강암류",caption));
					}else if(expr.equals("영월형 조선누층군")) {themeUnique.add(getItem(new Color(13,61,117), 100,"영월형 조선누층군","영월형 조선누층군",caption));
					}else if(expr.equals("용암산층")) {themeUnique.add(getItem(new Color(51,122,24), 100,"용암산층","용암산층",caption));
					}else if(expr.equals("우백질편마암")) {themeUnique.add(getItem(new Color(26,171,117), 100,"우백질편마암","우백질편마암",caption));
					}else if(expr.equals("우백질화강암")) {themeUnique.add(getItem(new Color(75,141,96), 100,"우백질화강암","우백질화강암",caption));
					}else if(expr.equals("우항리층")) {themeUnique.add(getItem(new Color(32,42,133), 100,"우항리층","우항리층",caption));
					}else if(expr.equals("원남층군")) {themeUnique.add(getItem(new Color(231,89,92), 100,"원남층군","원남층군",caption));
					}else if(expr.equals("유문암및유문암질응회암")) {themeUnique.add(getItem(new Color(100,206,200), 100,"유문암및유문암질응회암","유문암및유문암질응회암",caption));
					}else if(expr.equals("유치역암")) {themeUnique.add(getItem(new Color(193,217,198), 100,"유치역암","유치역암",caption));
					}else if(expr.equals("율리층군")) {themeUnique.add(getItem(new Color(206,254,41), 100,"율리층군","율리층군",caption));
					}else if(expr.equals("응회암")) {themeUnique.add(getItem(new Color(77,138,199), 100,"응회암","응회암",caption));
					}else if(expr.equals("장기층군")) {themeUnique.add(getItem(new Color(43,105,104), 100,"장기층군","장기층군",caption));
					}else if(expr.equals("장동층")) {themeUnique.add(getItem(new Color(160,119,85), 100,"장동층","장동층",caption));
					}else if(expr.equals("장목리층")) {themeUnique.add(getItem(new Color(239,136,26), 100,"장목리층","장목리층",caption));
					}else if(expr.equals("장촌층")) {themeUnique.add(getItem(new Color(202,73,166), 100,"장촌층","장촌층",caption));
					}else if(expr.equals("장평리층")) {themeUnique.add(getItem(new Color(200,130,12), 100,"장평리층","장평리층",caption));
					}else if(expr.equals("적상산층")) {themeUnique.add(getItem(new Color(60,251,128), 100,"적상산층","적상산층",caption));
					}else if(expr.equals("적성층")) {themeUnique.add(getItem(new Color(105,214,87), 100,"적성층","적성층",caption));
					}else if(expr.equals("정선형 조선누층군")) {themeUnique.add(getItem(new Color(151,5,187), 100,"정선형 조선누층군","정선형 조선누층군",caption));
					}else if(expr.equals("조면안산암")) {themeUnique.add(getItem(new Color(244,58,202), 100,"조면안산암","조면안산암",caption));
					}else if(expr.equals("조면안산암 분석구")) {themeUnique.add(getItem(new Color(252,173,120), 100,"조면안산암 분석구","조면안산암 분석구",caption));
					}else if(expr.equals("조면암")) {themeUnique.add(getItem(new Color(244,103,158), 100,"조면암","조면암",caption));
					}else if(expr.equals("조면암 및 조면안산암")) {themeUnique.add(getItem(new Color(84,152,143), 100,"조면암 및 조면안산암","조면암 및 조면안산암",caption));
					}else if(expr.equals("조면암 및 현무암")) {themeUnique.add(getItem(new Color(231,78,46), 100,"조면암 및 현무암","조면암 및 현무암",caption));
					}else if(expr.equals("조면암 분석구")) {themeUnique.add(getItem(new Color(209,3,11), 100,"조면암 분석구","조면암 분석구",caption));
					}else if(expr.equals("조면현무암(I)")) {themeUnique.add(getItem(new Color(112,55,5), 100,"조면현무암(I)","조면현무암(I)",caption));
					}else if(expr.equals("조면현무암(I) 응회암")) {themeUnique.add(getItem(new Color(77,5,64), 100,"조면현무암(I) 응회암","조면현무암(I) 응회암",caption));
					}else if(expr.equals("조면현무암(II)")) {themeUnique.add(getItem(new Color(51,96,33), 100,"조면현무암(II)","조면현무암(II)",caption));
					}else if(expr.equals("조면현무암(II) 분석구")) {themeUnique.add(getItem(new Color(122,195,1), 100,"조면현무암(II) 분석구","조면현무암(II) 분석구",caption));
					}else if(expr.equals("조면현무암(III)")) {themeUnique.add(getItem(new Color(79,6,237), 100,"조면현무암(III)","조면현무암(III)",caption));
					}else if(expr.equals("조면현무암(III) 분석구")) {themeUnique.add(getItem(new Color(194,137,92), 100,"조면현무암(III) 분석구","조면현무암(III) 분석구",caption));
					}else if(expr.equals("조면현무암(IV)")) {themeUnique.add(getItem(new Color(103,232,199), 100,"조면현무암(IV)","조면현무암(IV)",caption));
					}else if(expr.equals("조면현무암(V)")) {themeUnique.add(getItem(new Color(201,234,19), 100,"조면현무암(V)","조면현무암(V)",caption));
					}else if(expr.equals("조면현무암(V) 분석구")) {themeUnique.add(getItem(new Color(195,26,237), 100,"조면현무암(V) 분석구","조면현무암(V) 분석구",caption));
					}else if(expr.equals("조면현무암(VI)")) {themeUnique.add(getItem(new Color(177,245,162), 100,"조면현무암(VI)","조면현무암(VI)",caption));
					}else if(expr.equals("조면현무암(VI) 분석구")) {themeUnique.add(getItem(new Color(209,6,162), 100,"조면현무암(VI) 분석구","조면현무암(VI) 분석구",caption));
					}else if(expr.equals("조면현무암(VII)")) {themeUnique.add(getItem(new Color(16,65,88), 100,"조면현무암(VII)","조면현무암(VII)",caption));
					}else if(expr.equals("조면현무암(VII) 분석구")) {themeUnique.add(getItem(new Color(208,153,85), 100,"조면현무암(VII) 분석구","조면현무암(VII) 분석구",caption));
					}else if(expr.equals("조면현무암(VIII)")) {themeUnique.add(getItem(new Color(180,184,117), 100,"조면현무암(VIII)","조면현무암(VIII)",caption));
					}else if(expr.equals("조면현무암(VIII) 분석구")) {themeUnique.add(getItem(new Color(1,67,136), 100,"조면현무암(VIII) 분석구","조면현무암(VIII) 분석구",caption));
					}else if(expr.equals("조면현무암(VIII) 응회암")) {themeUnique.add(getItem(new Color(175,223,50), 100,"조면현무암(VIII) 응회암","조면현무암(VIII) 응회암",caption));
					}else if(expr.equals("중봉산 화강편마암")) {themeUnique.add(getItem(new Color(401,121,21), 100,"중봉산 화강편마암","중봉산 화강편마암",caption));
					}else if(expr.equals("중부공주층군")) {themeUnique.add(getItem(new Color(30,221,43), 100,"중부공주층군","중부공주층군",caption));
					}else if(expr.equals("중부남포층군(백운사층,초계리층)")) {themeUnique.add(getItem(new Color(213,24,170), 100,"중부남포층군(백운사층,초계리층)","중부남포층군(백운사층,초계리층)",caption));
					}else if(expr.equals("중부대석회암층군")) {themeUnique.add(getItem(new Color(192,99,195), 100,"중부대석회암층군","중부대석회암층군",caption));
					}else if(expr.equals("중부연일층군")) {themeUnique.add(getItem(new Color(228,140,199), 100,"중부연일층군","중부연일층군",caption));
					}else if(expr.equals("중부초평층군")) {themeUnique.add(getItem(new Color(81,89,180), 100,"중부초평층군","중부초평층군",caption));
					}else if(expr.equals("중부평안층군")) {themeUnique.add(getItem(new Color(75,179,239), 100,"중부평안층군","중부평안층군",caption));
					}else if(expr.equals("중성,염기성반암")) {themeUnique.add(getItem(new Color(151,235,79), 100,"중성,염기성반암","중성,염기성반암",caption));
					}else if(expr.equals("중성및염기성화산암")) {themeUnique.add(getItem(new Color(176,78,223), 100,"중성및염기성화산암","중성및염기성화산암",caption));
					}else if(expr.equals("중성및염기성화산암류")) {themeUnique.add(getItem(new Color(72,28,122), 100,"중성및염기성화산암류","중성및염기성화산암류",caption));
					}else if(expr.equals("중성암")) {themeUnique.add(getItem(new Color(251,139,107), 100,"중성암","중성암",caption));
					}else if(expr.equals("중성암맥")) {themeUnique.add(getItem(new Color(46,144,40), 100,"중성암맥","중성암맥",caption));
					}else if(expr.equals("중화동층")) {themeUnique.add(getItem(new Color(241,157,66), 100,"중화동층","중화동층",caption));
					}else if(expr.equals("진동층")) {themeUnique.add(getItem(new Color(63,43,103), 100,"진동층","진동층",caption));
					}else if(expr.equals("진주층")) {themeUnique.add(getItem(new Color(69,198,167), 100,"진주층","진주층",caption));
					}else if(expr.equals("청산화강암")) {themeUnique.add(getItem(new Color(147,86,5), 100,"청산화강암","청산화강암",caption));
					}else if(expr.equals("충적층")) {themeUnique.add(getItem(new Color(142,072,27), 100,"충적층","충적층",caption));
					}else if(expr.equals("칠곡층")) {themeUnique.add(getItem(new Color(55,90,187), 100,"칠곡층","칠곡층",caption));
					}else if(expr.equals("태안층군")) {themeUnique.add(getItem(new Color(223,147,27), 100,"태안층군","태안층군",caption));
					}else if(expr.equals("통진층")) {themeUnique.add(getItem(new Color(47,240,71), 100,"통진층","통진층",caption));
					}else if(expr.equals("퇴적암")) {themeUnique.add(getItem(new Color(41,244,166), 100,"퇴적암","퇴적암",caption));
					}else if(expr.equals("퇴적암 및 화산암")) {themeUnique.add(getItem(new Color(134,249,134), 100,"퇴적암 및 화산암","퇴적암 및 화산암",caption));
					}else if(expr.equals("퇴적층")) {themeUnique.add(getItem(new Color(195,5,144), 100,"퇴적층","퇴적층",caption));
					}else if(expr.equals("편마암류")) {themeUnique.add(getItem(new Color(18,22,38), 100,"편마암류","편마암류",caption));
					}else if(expr.equals("편암")) {themeUnique.add(getItem(new Color(250,77,197), 100,"편암","편암",caption));
					}else if(expr.equals("편암류")) {themeUnique.add(getItem(new Color(199,90,78), 100,"편암류","편암류",caption));
					}else if(expr.equals("평창형 조선누층군")) {themeUnique.add(getItem(new Color(91,237,146), 100,"평창형 조선누층군","평창형 조선누층군",caption));
					}else if(expr.equals("평해층군")) {themeUnique.add(getItem(new Color(181,36,15), 100,"평해층군","평해층군",caption));
					}else if(expr.equals("하부공주층군")) {themeUnique.add(getItem(new Color(107,20,103), 100,"하부공주층군","하부공주층군",caption));
					}else if(expr.equals("하부남포층군(아미산층,하조층)")) {themeUnique.add(getItem(new Color(83,78,205), 100,"하부남포층군(아미산층,하조층)","하부남포층군(아미산층,하조층)",caption));
					}else if(expr.equals("하부대석회암층군")) {themeUnique.add(getItem(new Color(252,39,138), 100,"하부대석회암층군","하부대석회암층군",caption));
					}else if(expr.equals("하부연일층군")) {themeUnique.add(getItem(new Color(138,43,90), 100,"하부연일층군","하부연일층군",caption));
					}else if(expr.equals("하부천매암")) {themeUnique.add(getItem(new Color(48,118,145), 100,"하부천매암","하부천매암",caption));
					}else if(expr.equals("하부천매암대")) {themeUnique.add(getItem(new Color(120,81,136), 100,"하부천매암대","하부천매암대",caption));
					}else if(expr.equals("하부초평층군")) {themeUnique.add(getItem(new Color(154,110,135), 100,"하부초평층군","하부초평층군",caption));
					}else if(expr.equals("하부평안층군")) {themeUnique.add(getItem(new Color(175,77,121), 100,"하부평안층군","하부평안층군",caption));
					}else if(expr.equals("하산동층")) {themeUnique.add(getItem(new Color(145,168,104), 100,"하산동층","하산동층",caption));
					}else if(expr.equals("함력천매암")) {themeUnique.add(getItem(new Color(251,84,170), 100,"함력천매암","함력천매암",caption));
					}else if(expr.equals("함력천매암대")) {themeUnique.add(getItem(new Color(222,222,228), 100,"함력천매암대","함력천매암대",caption));
					}else if(expr.equals("함석류석 화강편마암")) {themeUnique.add(getItem(new Color(154,169,114), 100,"함석류석 화강편마암","함석류석 화강편마암",caption));
					}else if(expr.equals("함석류석화강편마암")) {themeUnique.add(getItem(new Color(233,5,71), 100,"함석류석화강편마암","함석류석화강편마암",caption));
					}else if(expr.equals("함안층")) {themeUnique.add(getItem(new Color(141,75,146), 100,"함안층","함안층",caption));
					}else if(expr.equals("함역천매암대")) {themeUnique.add(getItem(new Color(167,222,104), 100,"함역천매암대","함역천매암대",caption));
					}else if(expr.equals("현무암")) {themeUnique.add(getItem(new Color(34,19,93), 100,"현무암","현무암",caption));
					}else if(expr.equals("현무암(I)")) {themeUnique.add(getItem(new Color(146,116,218), 100,"현무암(I)","현무암(I)",caption));
					}else if(expr.equals("현무암(I) 응회암")) {themeUnique.add(getItem(new Color(200,193,173), 100,"현무암(I) 응회암","현무암(I) 응회암",caption));
					}else if(expr.equals("현무암(II)")) {themeUnique.add(getItem(new Color(95,86,99), 100,"현무암(II)","현무암(II)",caption));
					}else if(expr.equals("현무암(II) 분석구")) {themeUnique.add(getItem(new Color(200,116,92), 100,"현무암(II) 분석구","현무암(II) 분석구",caption));
					}else if(expr.equals("현무암(III)")) {themeUnique.add(getItem(new Color(150,185,215), 100,"현무암(III)","현무암(III)",caption));
					}else if(expr.equals("현무암(III) 분석구")) {themeUnique.add(getItem(new Color(75,34,70), 100,"현무암(III) 분석구","현무암(III) 분석구",caption));
					}else if(expr.equals("호상편마암")) {themeUnique.add(getItem(new Color(228,254,95), 100,"호상편마암","호상편마암",caption));
					}else if(expr.equals("홍도층")) {themeUnique.add(getItem(new Color(254,31,212), 100,"홍도층","홍도층",caption));
					}else if(expr.equals("홍제사 화강암")) {themeUnique.add(getItem(new Color(65,226,225), 100,"홍제사 화강암","홍제사 화강암",caption));
					}else if(expr.equals("화강반암")) {themeUnique.add(getItem(new Color(79,32,33), 100,"화강반암","화강반암",caption));
					}else if(expr.equals("화강섬록암")) {themeUnique.add(getItem(new Color(202,215,39), 100,"화강섬록암","화강섬록암",caption));
					}else if(expr.equals("화강암")) {themeUnique.add(getItem(new Color(103,133,79), 100,"화강암","화강암",caption));
					}else if(expr.equals("화강암류")) {themeUnique.add(getItem(new Color(40,49,31), 100,"화강암류","화강암류",caption));
					}else if(expr.equals("화강암질편마암")) {themeUnique.add(getItem(new Color(55,227,27), 100,"화강암질편마암","화강암질편마암",caption));
					}else if(expr.equals("화강편마암")) {themeUnique.add(getItem(new Color(98,89,95), 100,"화강편마암","화강편마암",caption));
					}else if(expr.equals("화산암류")) {themeUnique.add(getItem(new Color(191,21,16), 100,"화산암류","화산암류",caption));
					}else if(expr.equals("회장암")) {themeUnique.add(getItem(new Color(227,237,233), 100,"회장암","회장암",caption));
					}else if(expr.equals("휘록암")) {themeUnique.add(getItem(new Color(55,175,122), 100,"휘록암","휘록암",caption));
					}else if(expr.equals("흑운모편마암")) {themeUnique.add(getItem(new Color(34,240,190), 100,"흑운모편마암","흑운모편마암",caption));
					}else if(expr.equals("흑운모화강암")) {themeUnique.add(getItem(new Color(148,213,207), 100,"흑운모화강암","흑운모화강암",caption));
					}else if(expr.equals("흙,모래,자갈")) {themeUnique.add(getItem(new Color(191,5,58), 100,"흙,모래,자갈","흙,모래,자갈",caption));
					}
				}
			}else if(caption.indexOf("_prrck_") > 0) { //모암분포도
				for (String expr : exprlist) {
					if(expr.equals("1")) {themeUnique.add(getItem(new Color(155,187,89), 100,"1","화성암",caption));
					}else if(expr.equals("2")) {themeUnique.add(getItem(new Color(75,172,198), 100,"2","퇴적암",caption));
					}else if(expr.equals("3")) {themeUnique.add(getItem(new Color(192,80,77), 100,"3","변성암",caption));
					}
				}
			}else if(caption.indexOf("_accma_") > 0) { //퇴적양식분포도
				for (String expr : exprlist) {
					if(expr.equals("1")) {themeUnique.add(getItem(new Color(242,209,190), 100,"1","잔적토",caption));
					}else if(expr.equals("2")) {themeUnique.add(getItem(new Color(206,178,167), 100,"2","보행토(포행토)",caption));
					}else if(expr.equals("3")) {themeUnique.add(getItem(new Color(240,222,182), 100,"3","봉적토",caption));
					}
				}
			}else if(caption.indexOf("_rock_") > 0) { //암석노출도
				for (String expr : exprlist) {
					if(expr.equals("1")) {themeUnique.add(getItem(new Color(154,212,127), 100,"1","10% 이하",caption));
					}else if(expr.equals("2")) {themeUnique.add(getItem(new Color(124,182,97), 100,"2","10~30%",caption));
					}else if(expr.equals("3")) {themeUnique.add(getItem(new Color(94,152,67), 100,"3","30~50%",caption));
					}else if(expr.equals("4")) {themeUnique.add(getItem(new Color(64,122,37), 100,"4","50~75%",caption));
					}
				}
			}else if(caption.indexOf("_nature_") > 0) {//생태자연도
				for (String expr : exprlist) {
					if(expr.equals("1")) {themeUnique.add(getItem(new Color(47,152,47), 100,"1","1등급",caption));
					}else if(expr.equals("2")) {themeUnique.add(getItem(new Color(207,227,201), 100,"2","2등급",caption));
					}else if(expr.equals("3")) {themeUnique.add(getItem(new Color(255,255,255), 100,"3","3등급",caption));
					}
				}
			}
		}
		
		return themeUnique;
	}
	
	private ThemeUniqueItem getItem(Color color, int opaqueRate, String value, String caption, String type) {
		// Set the items to the object of themeunique
		ThemeUniqueItem item = new ThemeUniqueItem();
		item.setUnique(value);
		item.setCaption(caption);
		item.setVisible(true);

		// Set the style of the items
		GeoStyle geostyle = new GeoStyle();
		if(type.matches("ctrln.*")) {
			double cont = Double.parseDouble(value);
			geostyle.setLineColor(color);
			if(cont%100 == 0) {
				geostyle.setLineWidth(0.5);
			}else if(cont%20 == 0){
				geostyle.setLineWidth(0.1);
			}
		}else if(type.matches("wplgn.*")) {
			geostyle.setFillForeColor(color);
			geostyle.setFillOpaqueRate(opaqueRate);
			geostyle.setLineWidth(0.5);
			geostyle.setLineColor(color);
			if(value.equals("01")) {
				geostyle.setLineSymbolID(0);
			}else if(value.equals("02")) {
				geostyle.setLineSymbolID(1);
			}else if(value.equals("03")) {
				geostyle.setLineSymbolID(1);
			}else if(value.equals("04")) {
				geostyle.setLineSymbolID(0);
			}
		}else if(type.matches("wstat.*")) {
			int valnum = Integer.valueOf(value);
			geostyle.setMarkerSymbolID(322+valnum);
			geostyle.setMarkerSize(new Size2D(8, 8));
		}else {
			geostyle.setFillForeColor(color);
			geostyle.setFillOpaqueRate(opaqueRate);
			geostyle.setLineSymbolID(5);
		}

		item.setStyle(geostyle);

		return item;
	}
	
	/**
	 * Map에 벡터 데이터셋 추가
	 * @param dataset
	 * @param mapName
	 * @param caption
	 * @return
	 */
	private boolean addLayerSingleBandVector(Dataset dataset, String mapName, String caption) {
		try {
			DatasetVector vector = (DatasetVector)dataset;
			System.out.println(vector.getName());
			com.supermap.mapping.Map map = new com.supermap.mapping.Map(workspace);
			map.open(mapName);
			LayerSettingVector lsv = new LayerSettingVector();
			
			Layer layer = map.getLayers().add(vector,lsv, true);
			lsv = (LayerSettingVector)layer.getAdditionalSetting();
			lsv.setStyle(getGeoStyle(caption));
			
			map.viewEntire();
			layer.setVisible(true);
			workspace.getMaps().setMapXML(mapName, map.toXML());
			
			map.close();
		}catch (Exception e) {
			LOGGER.error("Map에 Vector DataSet 추가 : "+e.getMessage());
		}
		return true;
	}
	
	/**
	 * Map에 래스터 데이터셋 추가
	 * @param dataset
	 * @param mapName
	 * @param caption
	 * @return
	 */
	private boolean addLayerSingleBandGrid(Dataset dataset, String mapName, String caption) {
		try {
			DatasetGrid grid = (DatasetGrid)dataset;
			System.out.println(grid.getName());
			com.supermap.mapping.Map map = new com.supermap.mapping.Map(workspace);
			map.open(mapName);
			
			LayerSettingGrid lsg = new LayerSettingGrid();
			lsg.setSpecialValue(-9999.0);
			lsg.setSpecialValueTransparent(true);
			
			Layer layer = map.getLayers().add(grid,lsg, true);
			lsg = (LayerSettingGrid)layer.getAdditionalSetting();
			
			lsg.setColorDictionary(getColorDictionary(caption));
			
			if(caption.matches("hillshade.*")) {
				lsg.setOpaqueRate(40);
			}
			
			map.viewEntire();
			layer.setVisible(true);
			workspace.getMaps().setMapXML(mapName, map.toXML());
			
			map.close();
		}catch (Exception e) {
			LOGGER.error(e.getMessage());
		}
		return true;
	}
	
	/**
	 * Map에 이미지 데이터셋 추가
	 * @param dataset
	 * @param mapName
	 * @param caption
	 * @return
	 */
	private boolean addLayerImage(Dataset dataset, String mapName, String caption) {
		try {
			DatasetImage image = (DatasetImage)dataset;
			System.out.println(image.getName());
			com.supermap.mapping.Map map = new com.supermap.mapping.Map(workspace);
			map.open(mapName);
			
			LayerSettingImage lsi = new LayerSettingImage();
			//lsi.
			//lsg.setSpecialValue(-9999.0);
			//lsg.setSpecialValueTransparent(true);
			
			Layer layer = map.getLayers().add(image,lsi, true);
			//lsg = (LayerSettingGrid)layer.getAdditionalSetting();

			//lsg.setSpecialValueColor(Color.WHITE);
			//lsg.setColorDictionary(getColorDictionary(caption));
			
			map.viewEntire();
			layer.setVisible(true);
			workspace.getMaps().setMapXML(mapName, map.toXML());
			
			map.close();
		}catch (Exception e) {
			LOGGER.error(e.getMessage());
		}
		return true;
	}
	
	/**
	 * 벡터 데이터셋 심볼 설정
	 * @param caption
	 * @return
	 * @throws Exception
	 */
	private GeoStyle getGeoStyle(String caption) throws Exception{
		GeoStyle style = new GeoStyle();
		
		style.setFillForeColor(Color.white);
		style.setFillOpaqueRate(0);
		
		if(caption.matches("lgstr.*")) {
			style.setLineColor(Color.lightGray);
		}else if(caption.matches("watershed.*")) {
			style.setLineColor(Color.red);
			style.setLineWidth(0.2);
		}else if(caption.matches("ecrtcnl.*")) {
			style.setFillForeColor(Color.red);
			style.setFillOpaqueRate(1);
			style.setMarkerSize(new Size2D(8, 8));
			style.setLineColor(Color.red);
		}else if(caption.matches("ctrln.*")) {
			style.setLineColor(Color.lightGray);
		}else if(caption.matches("lcp_ctrln.*")) {
			style.setLineColor(new Color(228,194,107));
		}else if(caption.matches("road.*")) {
			style.setLineColor(new Color(48,120,235));
			style.setLineWidth(0.5);
		}else if(caption.matches("rank.*")) {
			style.setLineColor(new Color(156,18,18));
			style.setLineWidth(0.5);
		}else if(caption.matches("river.*")) {
			style.setLineColor(new Color(0,112,192));
			style.setLineWidth(0.5);
		}else if(caption.matches("wlgstr.*")) {//취약지역 지적선
			style.setLineColor(new Color(107,107,107));
			style.setLineWidth(0.1);
		}else if(caption.matches("wpnt.*")) {//취약지역 유출구
			style.setFillForeColor(new Color(254,0,0));
			style.setFillOpaqueRate(1);
			style.setMarkerSize(new Size2D(8, 8));
			style.setLineColor(new Color(254,0,0));
//			style.setLineColor(new Color(0,0,0));
//			style.setLineWidth(1);
//			style.setMarkerSymbolID(908129);
		}else if(caption.matches("wlne.*")) {//취약지역 대피로
			style.setLineColor(new Color(211,34,4));
			style.setLineWidth(0.5);
		}else if(caption.matches("stream3ha.*|stream5ha.*")) {
			style.setLineColor(new Color(0,112,192));
			style.setLineWidth(0.5);
		}else if(caption.matches("ecb.*")) {
			if(caption.indexOf("ctrln") > 0) {
				style.setLineColor(new Color(216,204,1));
			}else if(caption.indexOf("lgstr") > 0) {
				style.setLineColor(Color.black);
			}else if(caption.indexOf("sido") > 0) {
				style.setFillForeColor(Color.red);
				style.setFillOpaqueRate(100);
			}else if(caption.indexOf("ctprvn") > 0) {
				style.setFillForeColor(new Color(67,175,116));
				style.setLineColor(Color.white);
				style.setLineWidth(1);
				style.setFillOpaqueRate(100);
			}else if(caption.indexOf("_signgus_") > 0) {
				style.setFillForeColor(new Color(173,219,125));
				style.setLineColor(Color.white);
				style.setLineWidth(1);
				style.setFillOpaqueRate(100);
			}else if(caption.indexOf("_signgu_") > 0) {
				style.setFillForeColor(Color.red);
				style.setFillOpaqueRate(100);
			}else if(caption.indexOf("road") > 0) {
				style.setLineColor(new Color(176,55,55));
				style.setLineWidth(0.2);
			}
		}else if(caption.matches("frd.*")) {
			if(caption.indexOf("_y_") > 0) {
				style.setLineColor(new Color(255,255,0));
				style.setLineWidth(0.5);
			}else if(caption.indexOf("_r_") > 0){
				style.setLineColor(new Color(255,0,0));
				style.setLineWidth(0.5);
			}else if(caption.indexOf("_blue_") > 0){
				style.setLineColor(new Color(0,0,255));
				style.setLineWidth(0.5);
			}else if(caption.indexOf("_ea_") > 0) {
				style.setLineColor(Color.black);
				style.setLineWidth(0.5);
			}else if(caption.indexOf("_eo_") > 0) {
				style.setFillForeColor(new Color(225,225,225));
				style.setFillOpaqueRate(100);
				style.setLineColor(Color.black);
				style.setLineWidth(0.5);
			}else if(caption.indexOf("_one_") > 0) {
				style.setFillForeColor(new Color(254,0,0));
				style.setFillOpaqueRate(1);
				style.setMarkerSize(new Size2D(6, 6));
				style.setLineColor(new Color(254,0,0));
			}else if(caption.indexOf("_b_") > 0) {
				style.setLineColor(new Color(0, 0, 255));
				style.setLineWidth(0.5);
			}else if(caption.indexOf("_cul_") > 0) {
				style.setLineColor(Color.red);
				style.setLineWidth(0.5);
			}else if(caption.indexOf("_buffer_") > 0) {
				style.setFillForeColor(Color.red);
				style.setFillOpaqueRate(20);
				style.setLineColor(Color.red);
				style.setLineWidth(0.5);
			}else if(caption.indexOf("_svy_") > 0) {
				style.setLineColor(Color.red);
				style.setLineWidth(0.5);
			}
		}
		else {
			style.setLineColor(Color.black);
		}
		
		return style;
	}
	
	/**
	 * 래스터 데이터셋 심볼설정
	 * @param caption
	 * @return
	 */
	private ColorDictionary getColorDictionary(String caption) {
		ColorDictionary cd = new ColorDictionary();
		
		if(caption.matches("slope.*")) {
			cd.setColor(10, new Color(56,167,0));
			cd.setColor(15, new Color(102,191,1));
			cd.setColor(20, new Color(156,217,0));
			cd.setColor(25, new Color(222,241,0));
			cd.setColor(30, new Color(255,221,0));
			cd.setColor(35, new Color(255,144,0));
			cd.setColor(40, new Color(255,73,0));
			cd.setColor(Double.MAX_VALUE, new Color(254,0,0));
		}else if(caption.matches("dem.*")) {
			cd.setColor(100, new Color(255,255,128));
			cd.setColor(200, new Color(255,241,116));
			cd.setColor(300, new Color(252,224,98));
			cd.setColor(400, new Color(250,209,85));
			cd.setColor(500, new Color(247,195,73));
			cd.setColor(600, new Color(245,180,60));
			cd.setColor(700, new Color(242,168,47));
			cd.setColor(800, new Color(219,137,37));
			cd.setColor(900, new Color(196,110,27));
			cd.setColor(1000, new Color(173,83,20));
			cd.setColor(1100, new Color(150,58,11));
			cd.setColor(1200, new Color(129,35,7));
			cd.setColor(Double.MAX_VALUE, new Color(108,6,1));
		}else if(caption.matches("aspect.*")) {
			cd.setColor(-1, new Color(175,176,176));
			cd.setColor(22.5, new Color(251,18,23));
			cd.setColor(67.5, new Color(252,166,21));
			cd.setColor(112.5, new Color(252,255,18));
			cd.setColor(157.5, new Color(3,255,0));
			cd.setColor(202.5, new Color(44,254,252));
			cd.setColor(247.5, new Color(44,158,254));
			cd.setColor(292.5, new Color(42,0,247));
			cd.setColor(337.5, new Color(250,0,254));
			cd.setColor(360, new Color(247,20,18));
		}else if(caption.matches("hillshade.*")){
			cd.setColor(0, new Color(0,0,0));
			cd.setColor(8.19354838709677, new Color(8,8,8));
			cd.setColor(16.3870967741935, new Color(16,16,16));
			cd.setColor(24.5806451612903, new Color(25,25,25));
			cd.setColor(32.7741935483871, new Color(33,33,33));
			cd.setColor(40.9677419354839, new Color(41,41,41));
			cd.setColor(49.1612903225806, new Color(49,49,49));
			cd.setColor(57.3548387096774, new Color(58,58,58));
			cd.setColor(65.5483870967742, new Color(66,66,66));
			cd.setColor(73.741935483871, new Color(74,74,74));
			cd.setColor(81.9354838709677, new Color(82,82,82));
			cd.setColor(90.1290322580645, new Color(90,90,90));
			cd.setColor(98.3225806451613, new Color(99,99,99));
			cd.setColor(106.516129032258, new Color(107,107,107));
			cd.setColor(114.709677419355, new Color(115,115,115));
			cd.setColor(122.903225806452, new Color(123,123,123));
			cd.setColor(131.096774193548, new Color(132,132,132));
			cd.setColor(139.290322580645, new Color(140,140,140));
			cd.setColor(147.483870967742, new Color(148,148,148));
			cd.setColor(155.677419354839, new Color(156,156,156));
			cd.setColor(163.870967741935, new Color(165,165,165));
			cd.setColor(172.064516129032, new Color(173,173,173));
			cd.setColor(180.258064516129, new Color(181,181,181));
			cd.setColor(188.451612903226, new Color(189,189,189));
			cd.setColor(196.645161290323, new Color(197,197,197));
			cd.setColor(204.838709677419, new Color(206,206,206));
			cd.setColor(213.032258064516, new Color(214,214,214));
			cd.setColor(221.225806451613, new Color(222,222,222));
			cd.setColor(229.41935483871, new Color(230,230,230));
			cd.setColor(237.612903225806, new Color(239,239,239));
			cd.setColor(245.806451612903, new Color(247,247,247));
			cd.setColor(254, new Color(255,255,255));
		}else if(caption.matches("landslide.*")){
			cd.setColor(1, new Color(254,0,0));
			cd.setColor(2, new Color(255,200,1));
			cd.setColor(3, new Color(182,254,142));
			cd.setColor(4, new Color(51,195,255));
			cd.setColor(5, new Color(0,1,255));
		}else if(caption.matches("sdem.*")) {
			cd.setColor(-4.15472507476807, new Color(255,255,128));
			cd.setColor(58.6317838238132, new Color(255,241,116));
			cd.setColor(121.418292722394, new Color(252,224,98));
			cd.setColor(184.204801620976, new Color(250,209,85));
			cd.setColor(246.991310519557, new Color(247,195,73));
			cd.setColor(309.777819418138, new Color(245,180,60));
			cd.setColor(372.564328316719, new Color(242,168,47));
			cd.setColor(435.350837215301, new Color(219,137,37));
			cd.setColor(498.137346113882, new Color(196,110,27));
			cd.setColor(560.923855012463, new Color(173,83,20));
			cd.setColor(623.710363911044, new Color(150,58,11));
			cd.setColor(686.496872809626, new Color(129,35,7));
			cd.setColor(749.283381708207, new Color(129,35,7));
			cd.setColor(812.069890606788, new Color(129,35,7));
			cd.setColor(874.856399505369, new Color(129,35,7));
			cd.setColor(937.642908403951, new Color(129,35,7));
			cd.setColor(1000.42941730253, new Color(129,35,7));
			cd.setColor(1063.21592620111, new Color(129,35,7));
			cd.setColor(1126.00243509969, new Color(129,35,7));
			cd.setColor(1188.78894399828, new Color(129,35,7));
			cd.setColor(1251.57545289686, new Color(129,35,7));
			cd.setColor(1314.36196179544, new Color(129,35,7));
			cd.setColor(1377.14847069402, new Color(129,35,7));
			cd.setColor(1439.9349795926, new Color(129,35,7));
			cd.setColor(1502.72148849118, new Color(129,35,7));
			cd.setColor(1565.50799738976, new Color(129,35,7));
			cd.setColor(1628.29450628834, new Color(129,35,7));
			cd.setColor(1691.08101518692, new Color(129,35,7));
			cd.setColor(1753.86752408551, new Color(129,35,7));
			cd.setColor(1816.65403298409, new Color(129,35,7));
			cd.setColor(1879.44054188267, new Color(129,35,7));
			cd.setColor(1942.22705078125, new Color(129,35,7));
		}
		return cd;
	}
		
	/**
	 * 임도용 템플릿 레이아웃 설정
	 * @param name
	 * @throws Exception
	 */
	public boolean setFrdMapLayoutControl(String layoutName, String mapName,Rectangle2D rect){
		LOGGER.info("템플릿 레이아웃 설정 시작");
		
		mapLayoutcontrol = new MapLayoutControl();
		mapLayoutcontrol.getMapLayout().setWorkspace(workspace);
		mapLayoutcontrol.getMapLayout().open(layoutName);
		
		try {
			LayoutElements layoutElements = mapLayoutcontrol.getMapLayout().getElements();
			while(!layoutElements.isEOF()) {
				Geometry geometry = layoutElements.getGeometry();
				
				if(geometry instanceof GeoText) {
					
				}
				if(geometry instanceof GeoMap) {
					GeoMap target = (GeoMap)geometry;
					target.setMapName(mapName);
					
					layoutElements.setGeometry(target);
					
					com.supermap.mapping.Map map = new com.supermap.mapping.Map();
					map.setWorkspace(workspace);
					System.out.println(mapName);
					map.open(mapName);
					
					//Rectangle2D rect = datasource.getDatasets().get(this.dataSetNm).getBounds();
					//rect.inflate(100, 100);
					
					mapLayoutcontrol.setMapAction(Action.NULL);
					mapLayoutcontrol.setActiveGeoMapID(layoutElements.getID());
					mapLayoutcontrol.getActiveMap().setViewBounds(rect);
					//mapLayoutcontrol.getActiveMap().setScale(100);
					mapLayoutcontrol.getActiveMap().setCenter(rect.getCenter());
					mapLayoutcontrol.getActiveMap().refresh();
					mapLayoutcontrol.setActiveGeoMapID(-1);
					
				}
				if(geometry instanceof GeoLegend) {
					GeoLegend legend = createFrdGeoLegend(layoutName,geometry, mapName);
					layoutElements.setGeometry(legend);
				}
				
				layoutElements.moveNext();
			}
			layoutElements.refresh();
			mapLayoutcontrol.getMapLayout().refresh();
			LOGGER.info("템플릿 레이아웃 설정 완료");
		} catch (Exception e) {
			LOGGER.error("템플릿 레이아웃 설정 오류 : "+e.getMessage());
		}
		return true;
	}
	/**
	 * 템플릿 레이아웃 설정
	 * @param name
	 * @throws Exception
	 */
	public boolean setMapLayoutControl(String layoutName, String mapName,Rectangle2D rect){
		LOGGER.info("템플릿 레이아웃 설정 시작");
		
		mapLayoutcontrol = new MapLayoutControl();
		mapLayoutcontrol.getMapLayout().setWorkspace(workspace);
		mapLayoutcontrol.getMapLayout().open(layoutName);
		
		try {
			LayoutElements layoutElements = mapLayoutcontrol.getMapLayout().getElements();
			while(!layoutElements.isEOF()) {
				Geometry geometry = layoutElements.getGeometry();
				
				if(geometry instanceof GeoText) {
					
				}
				if(geometry instanceof GeoLegend) {
					GeoLegend legend = createEcbGeoLegend(layoutName,geometry, mapName);
					layoutElements.setGeometry(legend);
				}
				
				if(geometry instanceof GeoMap) {
					GeoMap target = (GeoMap)geometry;
					target.setMapName(mapName);
					
					layoutElements.setGeometry(target);
					
					com.supermap.mapping.Map map = new com.supermap.mapping.Map();
					map.setWorkspace(workspace);
					System.out.println(mapName);
					map.open(mapName);
					
					//Rectangle2D rect = datasource.getDatasets().get(this.dataSetNm).getBounds();
					//rect.inflate(100, 100);
					
					mapLayoutcontrol.setMapAction(Action.NULL);
					mapLayoutcontrol.setActiveGeoMapID(layoutElements.getID());
					mapLayoutcontrol.getActiveMap().setViewBounds(rect);
					//mapLayoutcontrol.getActiveMap().setScale(100);
					mapLayoutcontrol.getActiveMap().setCenter(rect.getCenter());
					mapLayoutcontrol.getActiveMap().refresh();
					mapLayoutcontrol.setActiveGeoMapID(-1);
					
				}
				layoutElements.moveNext();
			}
			layoutElements.refresh();
			mapLayoutcontrol.getMapLayout().refresh();
			LOGGER.info("템플릿 레이아웃 설정 완료");
		} catch (Exception e) {
			LOGGER.error("템플릿 레이아웃 설정 오류 : "+e.getMessage());
		}
		return true;
	}
	/**
	 * 지도템플릿 범례생성
	 * @param geometry
	 * @param mapName
	 * @return
	 * @throws Exception
	 */
	private GeoLegend createEcbGeoLegend(String layoutName, Geometry geometry, String mapName) throws Exception{
		String legendTitle = "범 례";
		GeoLegend target = (GeoLegend)geometry;
		GeoLegend legend = new GeoLegend(mapName, datasource.getWorkspace(), legendTitle);
		
		for(int i=0; i<legend.getItemNames().length; i++) {
			String lyNm = legend.getItemNames()[i];
			if(lyNm.contains("hillshade") || lyNm.contains("VworldSatellite")) {
				legend.setItemVisible(lyNm,false);
			}
		}
		
		legend.setColumnCount(1);	// 범례 컬럼갯수
		legend.setWidth(target.getBounds().getWidth());
		legend.setCenter(new Point2D(target.getInnerPoint().x, target.getInnerPoint().y));
		
		GeoCompound compound = legend.getInnerGeometry();
		legend.setHeight((compound.getPartCount()/2)*65);
		
		int idx = 0;
		double positionX = 88;
		double positionY = 0;
		
		double lineHeight = 0;
		
		int tIdx = 0;
		
		LinkedHashMap<Integer, Double> positionYMap = new LinkedHashMap<Integer, Double>();
		
		int pc = compound.getPartCount();
		
		double gpc = 0;	// 보정값
		
		if(pc > 12){
			gpc = ((compound.getPartCount()/(legend.getHeight()/2))*100)-10;
		}else {
			gpc = ((compound.getPartCount()/(legend.getHeight()/2))*100);
		}
		
		for (int i =0; i < compound.getPartCount(); i++) {
			//System.out.println(compound.getPart(i).getType());
			Geometry typeCheck = (Geometry)compound.getPart(i);
			
			if(typeCheck instanceof GeoRectangle) {
				GeoRectangle rec = (GeoRectangle) typeCheck;
				if(idx == 0) {	
					positionY = rec.getInnerPoint().y;
					positionYMap.put(idx, positionY);
					
					//GeoStyle style = rec.getStyle();
					//style.setFillForeColor(new Color(0,0,0,0));
					//style.setFillBackColor(new Color(0,0,0,0));
					
					//rec.setStyle(style);
				}else {
					if(idx == 1) {
						positionY = positionY + (legend.getHeight()/2)-110;
					}
					
					rec.setWidth(100);
					rec.setHeight(40);
					rec.setCenter(new Point2D(positionX, positionY - ((idx -1) * 60) + gpc));
					
					positionYMap.put(idx,  positionY - ((idx -1) * 60) + gpc);
				}
				idx++;
			}
			
			if((typeCheck instanceof GeoText)) {
				GeoText text = (GeoText) typeCheck;
				
				if(text.getText().matches("범 례")) {
					TextPart part = new TextPart();
					part.setText(text.getText());
					part.setX(positionX-25);
					
					positionY = positionYMap.get(0);
					double legendHeight = positionY + (legend.getHeight()/2)-30;
					part.setY(legendHeight);
					
					//Text Style Set
					TextStyle style = new TextStyle();
					style.setFontWidth(5);
					style.setFontHeight(5);
					style.setSizeFixed(true);
					style.setFontName("Malgun Gothic");
					text.setTextStyle(style);
					text.setPart(0, part);
				}else {
					TextPart part = new TextPart();
					
					if(text.getText().contains("watershed")) {
						part.setText("유역경계");
					}else {
						part.setText(text.getText());
						positionY = positionYMap.get(tIdx+1);
					}
					part.setX(positionX+120);
					part.setY(positionY+10);
					

					TextStyle style = new TextStyle();
					style.setFontWidth(3);
					style.setFontHeight(3);
					style.setSizeFixed(true);
					style.setFontName("Malgun Gothic");
					text.setTextStyle(style);
					text.setPart(0, part);
					
					tIdx++;
					
				}
			}
			
			if(typeCheck instanceof GeoLine) {
				GeoLine line = (GeoLine) typeCheck;
				
				GeoStyle style = new GeoStyle();
				style.setLineColor(new Color(255,255,0));
				style.setLineWidth(0.5);
				line.setStyle(style);
				
				GeoRectangle rec = new GeoRectangle();
				rec.setWidth(100);
				rec.setHeight(40);
				
				positionY = positionYMap.get(0);
				lineHeight = positionY + (legend.getHeight()/2)-120+gpc;
				rec.setCenter(new Point2D(positionX, lineHeight));
				line.resize(rec.getBounds());
				
				idx++;
			}
		}
		legend.setCenter(new Point2D(target.getInnerPoint().x-10, legend.getHeight()/2+20+gpc));
		return legend;
	}
	/**
	 * 지도템플릿 범례생성
	 * @param geometry
	 * @param mapName
	 * @return
	 * @throws Exception
	 */
	private GeoLegend createGeoLegend(String layoutName, Geometry geometry, String mapName) throws Exception{
		String legendTitle = "범례";
		GeoLegend target = (GeoLegend)geometry;
		GeoLegend legend = new GeoLegend(mapName, datasource.getWorkspace(), legendTitle);
		
		legend.setColumnCount(1);
		legend.setWidth(target.getBounds().getWidth());
		//legend.setHeight(target.getBounds().getHeight());
		legend.setCenter(new Point2D(target.getInnerPoint().x, target.getInnerPoint().y));
		
		GeoCompound compound = legend.getInnerGeometry();
		
		legend.setHeight((compound.getPartCount()/2)*65);
		//legend.setCenter(new Point2D(legend.getInnerPoint().x, legend.getHeight()/2+30));
		
		int idx =0, recIdx = 0, lineIdx = 0;
		double positionX = 0, positionY = 0;
		
		LinkedHashMap<Integer, Double> positionYMap = new LinkedHashMap<Integer, Double>();
		for (int i =0; i < compound.getPartCount(); i++) {
			//System.out.println(compound.getPart(i).getType());
			Geometry typeCheck = (Geometry)compound.getPart(i);
			
			if((typeCheck instanceof GeoText)) {
				GeoText text = (GeoText) typeCheck;
				if(idx == 0 ) {
					positionX =  text.getInnerPoint().x;
					//positionY = text.getInnerPoint().y;
					//System.out.println("POSITION X / Y : " + positionX +" / "+ positionY);
					idx++;
				}
				if(text.getText().matches("범례")) {
					//positionY = text.getInnerPoint().y;
					positionY = positionYMap.get(0);
					positionY = positionY + (legend.getHeight()/2)-40;
					
					TextPart part = new TextPart();
					part.setText(text.getText());
					part.setX(positionX);
					part.setY(positionY);
					
					//Text Style Set
					TextStyle style = new TextStyle();
					style.setFontWidth(5);
					style.setFontHeight(5);
					style.setSizeFixed(true);
//					style.setFontScale(10);
					text.setTextStyle(style);
					text.setPart(0, part);
				}else {
					TextPart part = new TextPart();
					if(text.getText().matches("watershed.*")) {
						part.setText("유역경계");
					}else {
						part.setText(text.getText());
					}
					positionY = positionYMap.get(idx);
					//Text position & text Set
					part.setX(positionX+100);
					part.setY(positionY);
					//part.setY((positionY) - ((idx -1) * 60));
					
					//Text Style Set
					TextStyle style = new TextStyle();
					style.setFontWidth(3);
					style.setFontHeight(3);
					style.setSizeFixed(true);
					text.setTextStyle(style);
					text.setPart(0, part);
					
					idx++;
				}
			}
			
			if(typeCheck instanceof GeoLine) {
				GeoLine line = (GeoLine) typeCheck;
				//System.out.println(line.getInnerPoint().x+","+line.getInnerPoint().y);
				if(lineIdx == 0) {
					positionY = line.getInnerPoint().y;
					positionYMap.put(lineIdx, positionY);
				}else {
					if(lineIdx == 1) {
						positionX =  line.getInnerPoint().x+40;
						positionY = positionY + (legend.getHeight()/2)-120;//rec.getInnerPoint().y;
					}
					line.offset(positionX, positionY - ((lineIdx -1) * 60));
					
					positionYMap.put(lineIdx, positionY - ((lineIdx -1) * 60));
				}
				//System.out.println("after ::: "+line.getInnerPoint().x+","+line.getInnerPoint().y);
				lineIdx++;
			}
			
			if(typeCheck instanceof GeoRectangle) {
				GeoRectangle rec = (GeoRectangle) typeCheck;
				//System.out.println(rec.getInnerPoint().x+","+rec.getInnerPoint().y);
				if(recIdx == 0) {
					positionY = rec.getInnerPoint().y;
					positionYMap.put(recIdx, positionY);
				}else {
					if(recIdx == 1) {
						positionX =  rec.getInnerPoint().x+40;
						positionY = positionY + (legend.getHeight()/2)-120;//rec.getInnerPoint().y;
					}
					rec.setWidth(100);
					rec.setHeight(40);
					rec.setCenter(new Point2D(positionX, positionY - ((recIdx -1) * 60)));
					
					positionYMap.put(recIdx, positionY - ((recIdx -1) * 60));
				}
				//System.out.println("after ::: "+rec.getInnerPoint().x+","+rec.getInnerPoint().y);
				recIdx++;
			}
		}
		legend.setCenter(new Point2D(target.getInnerPoint().x, legend.getHeight()/2+30));
		return legend;
	}
	/**
	 * 지도템플릿 범례생성
	 * @param geometry
	 * @param mapName
	 * @return
	 * @throws Exception
	 */
	private GeoLegend createFrdGeoLegend(String layoutName, Geometry geometry, String mapName) throws Exception{
		String legendTitle = "<범 례>";
		GeoLegend target = (GeoLegend)geometry;
		GeoLegend legend = new GeoLegend(mapName, datasource.getWorkspace(), legendTitle);
		
		
		String lineType = null;
		for(int i=0; i<legend.getItemNames().length; i++) {
			String lyNm = legend.getItemNames()[i];
			
			if(lyNm.contains("_y_")) {
				lineType = "타당성평가노선";
	        }else if(lyNm.contains("_blue_")) {
	        	lineType = "수정노선";
	        }
			
			if(lyNm.contains("hillshade") || lyNm.contains("VworldSatellite")) {
				legend.setItemVisible(lyNm,false);
			}
		}
		
		legend.setColumnCount(1);	// 범례 컬럼갯수
		legend.setWidth(target.getBounds().getWidth());
		legend.setCenter(new Point2D(target.getInnerPoint().x, target.getInnerPoint().y));
		
		GeoCompound compound = legend.getInnerGeometry();
		legend.setHeight((compound.getPartCount()/2)*65);
		
		int idx = 0;
		double positionX = 88;
		double positionY = 0;
		
		double lineHeight = 0;
		
		int tIdx = 0;
		
		LinkedHashMap<Integer, Double> positionYMap = new LinkedHashMap<Integer, Double>();
		
		int pc = compound.getPartCount();
		
		double gpc = 0;	// 보정값
		
		if(pc > 12){
			gpc = ((compound.getPartCount()/(legend.getHeight()/2))*100)-10;
		}else {
			gpc = ((compound.getPartCount()/(legend.getHeight()/2))*100);
		}
		
		for (int i =0; i < compound.getPartCount(); i++) {
			//System.out.println(compound.getPart(i).getType());
			Geometry typeCheck = (Geometry)compound.getPart(i);
			
			if(typeCheck instanceof GeoRectangle) {
				GeoRectangle rec = (GeoRectangle) typeCheck;
				
				GeoStyle style = new GeoStyle();
				if(idx == 0) {	
					positionY = rec.getInnerPoint().y;
					positionYMap.put(idx, positionY);
				}else {
					if(idx == 1) {
						positionY = positionY + (legend.getHeight()/2)-170;
					}
					
					rec.setWidth(100);
					rec.setHeight(40);
					
					// 범례 항목에 테두리
					style.setLineColor(new Color(0,0,0));
	                style.setLineWidth(0.01);
	                style.setFillForeColor(rec.getStyle().getFillForeColor());
	                style.setFillBackColor(rec.getStyle().getFillBackColor());
	                
	                
	                rec.setStyle(style);
					
					rec.setCenter(new Point2D(positionX, positionY - ((idx -1) * 60) + gpc));
					
					positionYMap.put(idx,  positionY - ((idx -1) * 60) + gpc);
				}
				idx++;
			}
			
			if((typeCheck instanceof GeoText)) {
				GeoText text = (GeoText) typeCheck;
				
				if(text.getText().matches("<범 례>")) {
					TextPart part = new TextPart();
					part.setText(text.getText());
					part.setX(200);
					
					positionY = positionYMap.get(0);
					double legendHeight = positionY + (legend.getHeight()/2)-30;
					part.setY(legendHeight);
					
					//Text Style Set
					TextStyle style = new TextStyle();
					style.setFontWidth(5);
					style.setFontHeight(5);
					style.setSizeFixed(true);
					style.setFontName("Malgun Gothic");
					text.setTextStyle(style);
					text.setPart(0, part);
				}else {
					TextPart part = new TextPart();
					
					if(text.getText().contains("_y_")) {
						part.setText("타당성평가노선");
						part.setX(positionX+120);
						part.setY(lineHeight+10);
					}else if(text.getText().contains("_blue_")) {
						part.setText("수정노선");
						part.setX(positionX+120);
						part.setY(lineHeight+10);
					}else {
						part.setText(text.getText());
						positionY = positionYMap.get(tIdx);
						part.setX(positionX+120);
						part.setY(positionY+10);
					}

					TextStyle style = new TextStyle();
					style.setFontWidth(3);
					style.setFontHeight(3);
					style.setSizeFixed(true);
					style.setFontName("Malgun Gothic");
					text.setTextStyle(style);
					text.setPart(0, part);
					
					tIdx++;
					
				}
			}
			
			if(typeCheck instanceof GeoLine) {
				GeoLine line = (GeoLine) typeCheck;
				
				GeoStyle style = new GeoStyle();
				
				if(lineType.equals("타당성평가노선")) {
					style.setLineColor(new Color(255,255,0));
					style.setLineWidth(0.5);
					line.setStyle(style);
				}else if(lineType.equals("수정노선")) {
					style.setLineColor(new Color(0,0,255));
					style.setLineWidth(0.5);
					line.setStyle(style);
				}
				
				
				GeoRectangle rec = new GeoRectangle();
				rec.setWidth(100);
				rec.setHeight(40);
				
				positionY = positionYMap.get(0);
				lineHeight = positionY + (legend.getHeight()/2)-120+gpc;
				rec.setCenter(new Point2D(positionX, lineHeight));
				line.resize(rec.getBounds());
				
				idx++;
			}
		}
		legend.setCenter(new Point2D(target.getInnerPoint().x-10, legend.getHeight()/2+20+gpc));
		return legend;
	}
	
	/**
	 * 지도 이미지 저장
	 * @return
	 * @throws Exception
	 */
	public AnalFileVO saveMapImage(AnalFileVO vo) throws Exception{
		LOGGER.info("지도 이미지 저장 시작");
		String saveFileNm = null;
		AnalFileVO fileVo = new AnalFileVO();
		
		BeanUtils.copyProperties(vo,fileVo);
		
		if(mapLayoutcontrol != null) {
			try {
				//fileVo = getSavePath(analId);
				//analisis/img/2022/10/21/
				String strePathString = fileVo.getFileStreCours();
				String streFileNm = fileVo.getStreFileNm();
				String streFullPath = strePathString + File.separator + streFileNm;
				
				boolean status = mapLayoutcontrol.getMapLayout().printToFile(streFullPath, PrintFileType.PNG, 96);
				if(status) {
					saveFileNm = streFullPath.concat(".png");
					fileVo.setFileExtsn("png");//파일확장자
					LOGGER.info("지도 이미지 저장 완료");
				}else {
					LOGGER.error("분석이미지 저장을 실패하였습니다.");
				}
			} catch (Exception e) {
				LOGGER.error("지도 이미지 저장 : "+e.getMessage());
			}
			
		}
		System.out.println(saveFileNm);
		return fileVo;
	}
	/**
	 * 지도 이미지 저장 export JPG, DPI150
	 * @return
	 * @throws Exception
	 */
	public AnalFileVO saveMapImageToJpg(AnalFileVO vo) throws Exception{
		LOGGER.info("지도 이미지 저장 시작");
		String saveFileNm = null;
		AnalFileVO fileVo = new AnalFileVO();
		
		BeanUtils.copyProperties(vo,fileVo);
		
		if(mapLayoutcontrol != null) {
			try {
				//fileVo = getSavePath(analId);
				//analisis/img/2022/10/21/
				String strePathString = fileVo.getFileStreCours();
				String streFileNm = fileVo.getStreFileNm();
				String streFullPath = strePathString + File.separator + streFileNm;
				
				boolean status = mapLayoutcontrol.getMapLayout().printToFile(streFullPath, PrintFileType.JPG, 300);
				if(status) {
					saveFileNm = streFullPath.concat(".jpg");
					fileVo.setFileExtsn("jpg");//파일확장자
					LOGGER.info("지도 이미지 저장 완료");
				}else {
					LOGGER.error("분석이미지 저장을 실패하였습니다.");
				}
			} catch (Exception e) {
				LOGGER.error("지도 이미지 저장 : "+e.getMessage());
			}
			
		}
		System.out.println(saveFileNm);
		return fileVo;
	}
	
	/**
	 * layout 명 조회
	 * @param caption
	 * @return
	 */
	private String getLayoutTemplateNm(String caption) {
		String templateNm = "";
		
		if(caption.matches("agcls|dnst|dmcls|slope|dem|aspect|river|nature|landslide")) {
			templateNm = "tp_vyt_ecb_".concat(caption);
		}else {
			templateNm = "tp_clip";
		}
		
		return templateNm;
	}
	
	/**
	 * 좌표변환
	 * @param dataset
	 * @return
	 */
	private boolean coordSysTranslator(Dataset dataset,int epsg) {
		return CoordSysTranslator.convert(dataset, new PrjCoordSys(epsg), new CoordSysTransParameter(), CoordSysTransMethod.MTH_GEOCENTRIC_TRANSLATION);
	}
	
	/**
	 * 지오메트리 정보 조회
	 * @param items
	 * @return
	 * @throws Exception
	 */
	public Map<String, Object> getGeometryParam(Map<String, Object> items) throws Exception{
		String geomType = null;
		String geomNm = null;
        String geomStr = null;
        Map<String, Object> geomParams = new HashMap<String, Object>();
        
		for(Map.Entry<String, Object> attr : items.entrySet()) {
			String attr_key = attr.getKey();
			Object attr_val = attr.getValue();
					
			if(attr_val != null && Pattern.matches("POINT.*(.*)", attr_val.toString())) {
				geomType = "POINT";
				geomNm = attr_key;
				geomStr = attr_val.toString();
			}else if(attr_val != null && Pattern.matches("MULTIPOLYGON.*(.*)", attr_val.toString())) {
				geomType = "MULTIPOLYGON";
				geomNm = attr_key;
				geomStr = attr_val.toString();
			}
		}
		
		if(geomType != null) {
			geomParams.put("type", geomType);
			geomParams.put("name", geomNm);
			geomParams.put("geometry", geomStr);
		}else {
			returnLog.put("status", "fail");
			returnLog.put("message", "지오메트리 형식이 맞지 않습니다.");
			LOGGER.error("지오메트리 형식이 맞지 않습니다.");
		}
		
		return geomParams;
	}
	
	/**
	 * 지오메트리 생성
	 * @param geomStr
	 * @param geomType
	 * @return
	 * @throws Exception
	 * @Description point 좌표변환 확인해볼것....
	 */
	public Geometry createGeometry(String geomStr,String geomType) throws Exception{
		Geometry geom = null;
		String geom_str = null;
		
		if(geomType.equals("POINT")) {
			geom_str = geomStr.replaceAll("POINT \\(|POINT\\(|\\)", "");
			
			String pt = geom_str;
			
			double x = Double.parseDouble(pt.split(" ")[0]);
			double y = Double.parseDouble(pt.split(" ")[1]);
			
			Point2D pt2d = new Point2D(x,y);
			
			//GeoPoint geoPt = new GeoPoint(pt2d);
			geom = new GeoPoint(pt2d);
		}else if(geomType.equals("POLYGON")) {
			geom_str = geomStr.replaceAll("POLYGON \\(\\(|POLYGON\\(\\(|\\)\\)\\)", "");
		}else if(geomType.equals("MULTIPOLYGON")) {
			geom_str = geomStr.replaceAll("MULTIPOLYGON \\(\\(\\(|MULTIPOLYGON\\(\\(\\(|\\)\\)\\)", "");
			String[] multiPolygons = geom_str.split("\\),\\(|\\), \\(");
			
			GeoRegion geoRegion = new GeoRegion();
			for (int i = 0; i < multiPolygons.length; i++) {
				String polygonStr = multiPolygons[i];//.replaceAll("\\(|\\)","");
				String[] multiPolygon = polygonStr.split(",");
				
				Point2Ds point2ds = new Point2Ds();
				
				for (int j = 0; j < multiPolygon.length; j++) {
					String polygon = multiPolygon[j].trim();
					
					double x = Double.parseDouble(polygon.split(" ")[0]);
					double y = Double.parseDouble(polygon.split(" ")[1]);
					
					point2ds.add(new Point2D(x, y));
				}
				geoRegion.addPart(point2ds);
			}
			
			geom = geoRegion;
		}else if(geomType.equals("POLYLINE")) {
			geom_str = geomStr.replaceAll("LINESTRING \\(|LINESTRING\\(|\\)", "");
			String[] multilines = geom_str.split(",");
			
			GeoLine geoLine = new GeoLine();
			Point2Ds point2ds = new Point2Ds();
			
			for (int i = 0; i < multilines.length; i++) {
				String line = multilines[i].trim();
				
				double x = Double.parseDouble(line.split(" ")[0]);
				double y = Double.parseDouble(line.split(" ")[1]);
				
				point2ds.add(new Point2D(x, y));
			}
			geoLine.addPart(point2ds);
			
			geom = geoLine;
		}
		
//		PrjCoordSys srcPrjCoordSys = PrjCoordSys.fromEPSG(epsg);
//		PrjCoordSys desPrjCoordSys = srcPrjCoordSys.getProjection() != null ? dataset.getPrjCoordSys() : PrjCoordSys.fromEPSG(5186);
//		
//		//printPrjCoordSys(dataset.getPrjCoordSys());
//		//if(!checkPrjCoordSys(desPrjCoordSys,srcPrjCoordSys)) {
//		if(epsg != 5186) {
//			boolean transCheck = CoordSysTranslator.convert(geom, srcPrjCoordSys, desPrjCoordSys, new CoordSysTransParameter(), CoordSysTransMethod.MTH_GEOCENTRIC_TRANSLATION);
//			if(!transCheck) {
//				LOGGER.error("좌표변환에 실패하였습니다.");
//				throw new Exception("좌표변환에 실패하였습니다.");
//			}
//		}
		
		return geom;
	}
	
	/**
	 * 속성정보 생성
	 * @param items
	 * @param geoNm
	 * @param geoType
	 * @return
	 * @throws Exception
	 */
	public Map<String, Object> createAttributes(Map<String, Object> items, String geoNm, String geoType) throws Exception{
		Map<String, Object> prolerties = new HashMap<String, Object>();
		SimpleDateFormat formatter = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
		
		for(Map.Entry<String, Object> attr : items.entrySet()) {
			String attr_key = attr.getKey();
			Object attr_val = attr.getValue();
			
			if(attr_val != null && !attr_key.equals("smid")) {
				boolean dateTypeCheck = Pattern.matches("[0-9][0-9][0-9][0-9]\\/[0-1][0-9]\\/[0-3][0-9]\\s[0-2][0-9]\\:[0-5][0-9]\\:[0-5][0-9].*", attr_val.toString());
				
				if(dateTypeCheck) {
					//prolerties.put(attr_key, "to_date(".concat(attr_val.toString()).concat(")"));
					prolerties.put(attr_key, formatter.parse(attr_val.toString()));
				}else {
					if(!geoNm.equals(attr_key)) {
						prolerties.put(attr_key, attr_val);
					}
				}
			}
		}
		
		return prolerties;
	}
	
	/**
	 * 쉐이프파일 임포트
	 * @param url
	 * @param vectorName
	 * @return
	 * @throws Exception
	 */
	public ImportResult importShpToDb(String url, String vectorName) throws Exception{
		ImportSettingSHP importSettingSHP = new ImportSettingSHP();
        importSettingSHP.setAttributeIgnored(false);
		
        importSettingSHP.setImportMode(ImportMode.APPEND);
        importSettingSHP.setSourceFilePath(url);
        importSettingSHP.setSourceFileCharset(Charset.UTF8);

        importSettingSHP.setTargetDatasource(datasource);
        importSettingSHP.setTargetDatasetName(vectorName);

        DataImport importer = new DataImport();
        importer.getImportSettings().add(importSettingSHP);
        ImportResult result = importer.run();
        
        return result;
	}
	
	/** 
	 * 파일 저장
	 * @param vectorName
	 * @param outputPath
	 * @throws Exception
	 */
	public AnalFileVO exportDbToFile(String datasetName, String query, String[] ignoreFields) throws Exception{
		AnalFileVO vo = null;
		try {
			//getConnectionInfo();
			Dataset ds = null;
			FileType fType = null;
			
			String uniquId = getDatasetUuid();
			getConnectionInfo(uniquId);
			
			if(datasets.contains(datasetName)) {
				ds = datasets.get(datasetName);
				DatasetType datasetType = ds.getType();
				
				if(datasetType.equals(DatasetType.GRID) || datasetType.equals(DatasetType.IMAGE)) {
					fType = FileType.TIF;
				}else {
					fType = FileType.SHP;
					if(query != null && query.length() > 0) {
						DatasetVector queryDsVector = (DatasetVector) ds;
						Recordset rs = queryDsVector.query(query,CursorType.STATIC);
						DatasetVector copyDatastVector = (DatasetVector) mDatasets.createFromTemplate(mDatasets.getAvailableDatasetName(datasetName.concat("_"+uniquId)),queryDsVector);
						copyDatastVector.append(rs);
						copyDatastVector.close();
						
						rs.dispose();
						ds.close();
						
						ds = mDatasets.get(datasetName.concat("_"+uniquId));
					}
				}
				
				vo = getSavePath(uniquId,shpMidDir);
				vo.setOrignlFileNm(datasetName);
				vo.setAnalType("shp");
				//vo.setMstId(Integer.valueOf(mstId));
				//vo.setSldId(sldId);
				
				File file = new File(vo.getFileStreCours()+File.separator+vo.getStreFileNm());
				file.mkdirs();
				
				ExportSetting exportSetting = new ExportSetting();
				
				if(ignoreFields != null) {
					exportSetting.setIgnoreFieldNames(ignoreFields);
				}
				
				exportSetting.setOverwrite(true);
				exportSetting.setTargetFileCharset(Charset.UTF8);
				exportSetting.setTargetFileType(fType);
				exportSetting.setTargetFilePath(vo.getFileStreCours()+File.separator+vo.getStreFileNm()+File.separator+ds.getName().replace("_"+uniquId, "")+".".concat(fType.toString()));
				exportSetting.setSourceData(ds);

				DataExport dataExport = new DataExport();
				dataExport.getExportSettings().add(exportSetting);
				ExportResult exportRslt = dataExport.run();
				
//				if(exportRslt.getSucceedSettings().length > 0) {
//					if(deleted) {
//						if(uDatasets.contains(datasetName.concat("_"+uniquId)))
//						uDatasets.delete(datasetName.concat("_"+uniquId));
//					}
//				}
				
				if(exportRslt.getFailedSettings().length > 0) {
					LOGGER.error("분석결과 파일저장을 실패하였습니다.");
				}
			}else {
				LOGGER.error("요청한 테이블 정보가 존재하지 않습니다.");
				throw new Exception("요청한 테이블 정보가 존재하지 않습니다.");
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			closeConnection();
		}
		
		return vo;
	}
	
	/**
	 * 메모리 udb에서 파일로 내보내기
	 * @param datasetName
	 * @param vo
	 * @param extension
	 * @throws Exception
	 */
	public void mExportUdbToFile(String datasetName, AnalFileVO vo, String extension) throws Exception{
		try {
			Dataset ds = null;
			FileType fType = null;
			if(mDatasets.contains(datasetName)) {
				if(extension.equals("tif")) {
					ds = (DatasetGrid) mDatasets.get(datasetName);
					fType = FileType.TIF;
				}else {
					ds = (DatasetVector) mDatasets.get(datasetName);
					fType = FileType.SHP;
				}
				
				File file = new File(vo.getFileStreCours()+File.separator+vo.getStreFileNm());
				file.mkdirs();
				
				ExportSetting exportSetting = new ExportSetting();
				exportSetting.setOverwrite(true);

				exportSetting.setTargetFileCharset(Charset.UTF8);
				exportSetting.setTargetFileType(fType);
				exportSetting.setTargetFilePath(vo.getFileStreCours()+File.separator+vo.getStreFileNm()+File.separator+ds.getName()+".".concat(extension));
				exportSetting.setSourceData(ds);

				DataExport dataExport = new DataExport();
				dataExport.getExportSettings().add(exportSetting);
				ExportResult exportRslt = dataExport.run();
				
//				if(exportRslt.getSucceedSettings().length > 0) {
//					if(deleted) {
//						uDatasets.delete(datasetName);
//					}
//				}
				
				if(exportRslt.getFailedSettings().length > 0) {
					LOGGER.error("분석결과 파일저장을 실패하였습니다.");
				}
			}else {
				LOGGER.error("요청한 테이블 정보가 존재하지 않습니다.");
				throw new Exception("요청한 테이블 정보가 존재하지 않습니다.");
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		}
	}
	
	/**
	 * udb에서 파일로 내보내기
	 * @param datasetName
	 * @param vo
	 * @param extension
	 * @throws Exception
	 */
	public void uExportUdbToFile(String datasetName, AnalFileVO vo, String extension) throws Exception{
		try {
			Dataset ds = null;
			FileType fType = null;
			if(uDatasets.contains(datasetName)) {
				if(extension.equals("tif")) {
					ds = (DatasetGrid) uDatasets.get(datasetName);
					fType = FileType.TIF;
				}else {
					ds = (DatasetVector) uDatasets.get(datasetName);
					fType = FileType.SHP;
				}
				
				File file = new File(vo.getFileStreCours()+File.separator+vo.getStreFileNm());
				file.mkdirs();
				
				ExportSetting exportSetting = new ExportSetting();
				exportSetting.setOverwrite(true);

				exportSetting.setTargetFileCharset(Charset.UTF8);
				exportSetting.setTargetFileType(fType);
				exportSetting.setTargetFilePath(vo.getFileStreCours()+File.separator+vo.getStreFileNm()+File.separator+ds.getName()+".".concat(extension));
				exportSetting.setSourceData(ds);

				DataExport dataExport = new DataExport();
				dataExport.getExportSettings().add(exportSetting);
				ExportResult exportRslt = dataExport.run();
				
				if(exportRslt.getFailedSettings().length > 0) {
					LOGGER.error("분석결과 파일저장을 실패하였습니다.");
				}
			}else {
				LOGGER.error("요청한 테이블 정보가 존재하지 않습니다.");
				throw new Exception("요청한 테이블 정보가 존재하지 않습니다.");
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		}
	}
	
	/**
	 * 슈퍼맵 연결 닫기
	 * @param type
	 * @throws Exception
	 */
	public void closeConnection() throws Exception{
		if(recordset != null) {
			recordset.close();
			recordset.dispose();
			recordset = null;
		}
		if(dataset != null && !dataset.isDisposed()){
			dataset.close();
		}
		
		if(datasource != null && datasource.isOpened()){
			datasource.close();
			LOGGER.debug("pggis datasource closed.");
		}
		
		
		if(uRecordset != null) {
			uRecordset.close();
			uRecordset.dispose();
			uRecordset = null;
		}
		if(uDataset != null && !uDataset.isDisposed()){
			uDataset.close();
		}
		
		if(uDatasource != null && uDatasource.isOpened()){
			uDatasource.close();
			LOGGER.debug("udb datasource closed.");
		}
		
		if(vRecordset != null) {
			vRecordset.close();
			vRecordset.dispose();
			vRecordset = null;
		}
		if(vDataset != null && !vDataset.isDisposed()){
			vDataset.close();
		}
		
		if(vDatasource != null && vDatasource.isOpened()){
			vDatasource.close();
			LOGGER.debug("vworld datasource closed.");
		}
		
		if(mDatasource != null && mDatasource.isOpened()) {
			mDatasource.close();
			LOGGER.debug("memory udb closed.");
		}
		
		if(workspace != null) {
			//workspace.save();
			//workspace.getDatasources().closeAll();
			workspace.close();
        	workspace.dispose();
		}
	}
	
	/**
	 * ExtFieldBookItemVO -> Map 바꾸기
	 * @param itemVo
	 * @return
	 * @throws Exception
	 */
	public Map<String, Object> changeVoToMap(SysComptVO itemVo) throws Exception{
		Map<String, Object> items = new HashMap<String, Object>();
		
		Field[] fields = itemVo.getClass().getDeclaredFields();
		
		for(Field field : fields) {
			field.setAccessible(true);
			items.put(field.getName(), field.get(itemVo));
		}
		
		return items;
	}
	
	/**
	 * SysFieldInfoVO -> Map 바꾸기
	 * @param itemVo
	 * @return
	 * @throws Exception
	 */
	public Map<String, Object> changeVoToMap(SysFieldInfoVO itemVo) throws Exception{
		Map<String, Object> items = new HashMap<String, Object>();
		
		Field[] fields = itemVo.getClass().getDeclaredFields();
		
		for(Field field : fields) {
			field.setAccessible(true);
			items.put(field.getName(), field.get(itemVo));
		}
		
		return items;
	}
	
	/**
	 * 지오메트리 업데이트 대상 유무 확인
	 * @return
	 * @throws Exception
	 * @Description 포인트는 X,Y 값을 비교, 폴리곤은 바운더리의 상하좌우 좌표와 width,height 그리고 중심좌표 X,Y 값을 비교하여 변경이 되었는지 확인.
	 * 
	 */
	public boolean checkUpdateGeometry(Geometry sourceGeom, Geometry updateGeom) throws Exception{
		boolean updated = false;
		if(sourceGeom.getType() == GeometryType.GEOPOINT) {
			GeoPoint sourcePoint = (GeoPoint) sourceGeom;
			GeoPoint updatePoint = (GeoPoint) updateGeom;
			
			updated = sourcePoint.getX() != updatePoint.getX() || sourcePoint.getX() != updatePoint.getX();
					
			updated = sourceGeom.getInnerPoint().getX() != updateGeom.getInnerPoint().getX() ||
					sourceGeom.getInnerPoint().getY() != updateGeom.getInnerPoint().getY();
		}else if(sourceGeom.getType() == GeometryType.GEOREGION) {
//			updated = sourceGeom.getBounds().getTop() != updateGeom.getBounds().getTop() ||
//					sourceGeom.getBounds().getBottom() != updateGeom.getBounds().getBottom() ||
//					sourceGeom.getBounds().getLeft() != updateGeom.getBounds().getLeft() ||
//					sourceGeom.getBounds().getRight() != updateGeom.getBounds().getRight() ||
//					sourceGeom.getBounds().getWidth() != updateGeom.getBounds().getWidth() ||
//					sourceGeom.getBounds().getHeight() != updateGeom.getBounds().getHeight() ||
//					sourceGeom.getBounds().getCenter().getX() != updateGeom.getBounds().getCenter().getX() ||
//					sourceGeom.getBounds().getCenter().getY() != updateGeom.getBounds().getCenter().getY();
			
			GeoRegion sourceRegion = (GeoRegion)sourceGeom;
			GeoRegion updateRegion = (GeoRegion)updateGeom;
			
			updated = sourceRegion.getArea() != updateRegion.getArea();
		
			//sourceRegion.getArea()
		}
		
		return updated;
	}
	
	/**
	 * 데이터셋 좌표체계와 입력 좌표체계 일치 유무
	 * @param sourceCoordSys
	 * @param targetCoordSys
	 * @return
	 * @throws Exception
	 */
	public boolean checkPrjCoordSys(PrjCoordSys sourceCoordSys,PrjCoordSys targetCoordSys) throws Exception{
		boolean checkPrj = false;
		PrjParameter sPrjParameter = sourceCoordSys.getPrjParameter();
		GeoCoordSys sGeoCoordSys = sourceCoordSys.getGeoCoordSys();
		
		PrjParameter tPrjParameter = targetCoordSys.getPrjParameter();
		GeoCoordSys tGeoCoordSys = targetCoordSys.getGeoCoordSys();
		
		checkPrj = sourceCoordSys.getProjection().getName().toString().equals(targetCoordSys.getProjection().getName().toString()) &&
				sPrjParameter.getCentralMeridian() == tPrjParameter.getCentralMeridian() &&
				sPrjParameter.getCentralParallel() == tPrjParameter.getCentralParallel() &&
				sPrjParameter.getFalseEasting() == tPrjParameter.getFalseEasting() &&
				sPrjParameter.getFalseNorthing() == tPrjParameter.getFalseNorthing() &&
				sPrjParameter.getScaleFactor() == tPrjParameter.getScaleFactor() &&
				sGeoCoordSys.getName().equals(tGeoCoordSys.getName()) &&
				sGeoCoordSys.getGeoDatum().getName().equals(tGeoCoordSys.getGeoDatum().getName()) &&
				sGeoCoordSys.getGeoDatum().getGeoSpheroid().getName().equals(tGeoCoordSys.getGeoDatum().getGeoSpheroid().getName()) &&
				sGeoCoordSys.getGeoDatum().getGeoSpheroid().getAxis() == tGeoCoordSys.getGeoDatum().getGeoSpheroid().getAxis();
		
		return checkPrj;
	}
	
	/**
	 * 구역통계 분석(Zonal Statistics)
	 * @param zonalDataset
	 * @param valueDataset
	 * @return
	 * @throws Exception
	 */
//	public DatasetGrid rasterValueZonalStatistics(Dataset zonalDataset, DatasetGrid valueDataset,String outputDatasetName, String outputTableName) throws Exception{
//		getDatasourceConnectionInfo();
//		//Set the name of the result dataset, and check whether this dataset has already existed in the datasource. If yes, delete this dataset
//		String outputDatasetName = "ta_feis_zonalStats_Result";
//		if (datasets.contains(outputDatasetName))
//		{
//			datasets.delete(outputDatasetName);
//		}
//	
//		//Set the name of the result attribute table, and check whether this dataset has already existed in the datasource. If yes, delete this dataset
//		String outputTableName = "ta_feis_zonalStats_ResultTable";
//		if (datasets.contains(outputTableName))
//		{
//			datasets.delete(outputTableName);
//		}
//	
//		ZonalStatisticsAnalystParameter parameter = new ZonalStatisticsAnalystParameter();
//		parameter.setTargetDatasource(datasource);
//		parameter.setTargetDatasetName(outputDatasetName);
//		parameter.setTargetTableName(outputTableName);
//		parameter.setIgnoreNoValue(false);
//		parameter.setStatisticsMode(GridStatisticsMode.SUM);
//		parameter.setPixelFormat(PixelFormat.DOUBLE);
//		parameter.setValueDataset(valueDataset);
//		parameter.setZonalDataset(zonalDataset);
//		//zonalStatisticsParameter.TargetDatasource = targetDatasource;
//		//zonalStatisticsParameter.TargetDatasetName = targetDatasetName;
//		//zonalStatisticsParameter.TargetDatasource = targetDatasource;
//		//zonalStatisticsParameter.TargetTableName = targetTableName;
//		//zonalStatisticsParameter.IsIgnoreNoValue = false;
//		//zonalStatisticsParameter.StatisticsMode = GridStatisticsMode.Sum;
//		//zonalStatisticsParameter.PixelFormat = PixelFormat.Double;
//		//zonalStatisticsParameter.ValueDataset = ValueDataset;
//		//zonalStatisticsParameter.ZonalDataset = ZoneDataset;
//	
//		//Call the ZonalStatisticsOnRasterValue method, and get the ZonalStatisticsAnalystResult object
//		ZonalStatisticsAnalystResult zonalStatisticResult = StatisticsAnalyst.zonalStatisticsOnRasterValue(parameter);
//		DatasetGrid resultDatasetGrid = zonalStatisticResult.getResultDatasetGrid();
//	
//	return resultDatasetGrid;
//
//	}
	
	
	/**
	 * 좌표체계 출력
	 * @param prjCoordSys
	 * @throws Exception
	 */
	public void printPrjCoordSys(PrjCoordSys prjCoordSys) throws Exception{
		//PrjCoordSys prjCoordSys = dataset.getPrjCoordSys();
		//PrjCoordSys prjCoordSys = PrjCoordSys.fromEPSG(5186);
		PrjParameter prjParameter = prjCoordSys.getPrjParameter();
		GeoCoordSys geoCoordSys = prjCoordSys.getGeoCoordSys();
		
		LOGGER.info(prjCoordSys.getName().toString());
		LOGGER.info(prjCoordSys.getProjection().getName().toString());
		LOGGER.info(String.valueOf(prjParameter.getCentralMeridian()));
		LOGGER.info(String.valueOf(prjParameter.getCentralParallel()));
		LOGGER.info(String.valueOf(prjParameter.getStandardParallel1()));
		LOGGER.info(String.valueOf(prjParameter.getStandardParallel2()));
		LOGGER.info(String.valueOf(prjParameter.getFalseEasting()));
		LOGGER.info(String.valueOf(prjParameter.getFalseNorthing()));
		LOGGER.info(String.valueOf(prjParameter.getScaleFactor()));
		LOGGER.info(String.valueOf(prjParameter.getAzimuth()));
		LOGGER.info(String.valueOf(prjParameter.getFirstPointLongitude()));
		LOGGER.info(String.valueOf(prjParameter.getSecondPointLongitude()));
		
		LOGGER.info(geoCoordSys.getName());
		LOGGER.info(geoCoordSys.getGeoDatum().getName());
		LOGGER.info(geoCoordSys.getGeoDatum().getGeoSpheroid().getName());
		LOGGER.info(String.valueOf(geoCoordSys.getGeoDatum().getGeoSpheroid().getAxis()));
		LOGGER.info(String.valueOf(geoCoordSys.getGeoDatum().getGeoSpheroid().getFlatten()));
		LOGGER.info(String.valueOf(geoCoordSys.getGeoPrimeMeridian().getLongitudeValue()));
	}
	
	/**
	 * 레코드셋 추가
	 * @param geom
	 * @param attr
	 * @param vectorName
	 * @throws Exception
	 */
	public void addRecordset(Geometry geom, Map<String, Object> attr, String vectorName) throws Exception{
		try {
			if(datasets.contains(vectorName)) {
				dataset = (DatasetVector) datasets.get(vectorName);
				
				recordset = dataset.getRecordset(false, CursorType.DYNAMIC);
				recordset.addNew(geom, attr);
				recordset.update();
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			if(geom != null) {
				geom.dispose();
			}
			recordset.dispose();
			recordset.close();
			dataset.close();
		}
		
	}
	
	public void addmRecordset(Geometry geom, Map<String, Object> attr, String vectorName) throws Exception{
		DatasetVector mDataset = null;
		Recordset mRecordset = null;
		try {
			if(mDatasets.contains(vectorName)) {
				mDataset = (DatasetVector) mDatasets.get(vectorName);
				
				mRecordset = mDataset.getRecordset(false, CursorType.DYNAMIC);
				mRecordset.addNew(geom, attr);
				mRecordset.update();
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		} finally {
			if(geom != null) {
				geom.dispose();
			}
			if(mRecordset != null) {
				mRecordset.dispose();
				mRecordset.close();
			}
			
			if(mDataset != null) {
				mDataset.close();				
			}
		}
	}
	
	/**
	 * 데이터셋 이름 확인
	 * @param caption
	 * @return
	 */
	private String getLayerName(String caption) {
		String layerNm = null;
		
		if(caption.equals("ecrtcnl")) {
			layerNm = "tf_feis_ecrtcnl";
		}else if(caption.equals("watershed")) {
			layerNm = "tf_feis_watershed";
		}else if(caption.equals("lgstr")) {
			layerNm = "tf_feis_lgstr";
		}else if(caption.equals("ctrln")) {
			layerNm = "tf_feis_ctrln";
		}else if(caption.equals("river")) {
			layerNm = "tf_feis_river";
		}else if(caption.equals("slope")) {
			layerNm = "tf_feis_slope";
		}else if(caption.equals("aspect")) {
			layerNm = "tf_feis_aspect";
		}else if(caption.equals("dem")) {
			layerNm = "tf_feis_dem";
		}else if(caption.equals("koftr")) {
			layerNm = "tf_feis_im5000";
		}else if(caption.equals("agcls")) {
			layerNm = "tf_feis_im5000";
		}else if(caption.equals("dnst")) {
			layerNm = "tf_feis_im5000";
		}else if(caption.equals("dmcls")) {
			layerNm = "tf_feis_im5000";
		}else if(caption.equals("nature")) {
			layerNm = "tf_feis_eclgy_nature";
		}else if(caption.equals("forestroad")) {
			layerNm = "tf_feis_frd_svysldinfo";
		}else if(caption.equals("geological")) {
			layerNm = "tf_feis_geological_lclas";
		}else if(caption.equals("frtp")) {
			layerNm = "tf_feis_im5000";
		}else if(caption.equals("fror")) {
			layerNm = "tf_feis_im5000";
		}else if(caption.equals("soil")) {
			layerNm = "tf_feis_ij100";
		}else if(caption.equals("geology")) {
			layerNm = "tf_feis_geology_250k_litho";
		}else if(caption.equals("prrck")) {
			layerNm = "tf_feis_ij100";
		}else if(caption.equals("accma")) {
			layerNm = "tf_feis_ij100";
		}else if(caption.equals("rock")) {
			layerNm = "tf_feis_ij100";
		}else if(caption.equals("landslide")) {
			layerNm = "tf_feis_landslide";
		}else if(caption.equals("hillshade")) {
			layerNm = "tf_feis_hillshade";
		}else if(caption.equals("stream3ha")) {
			layerNm = "tf_feis_stream_3ha";
		}else if(caption.equals("stream5ha")) {
			layerNm = "tf_feis_stream_5ha";
		}else if(caption.equals("sido")) {
			layerNm = "tf_feis_ctprvn";
		}else if(caption.equals("signgu")) {
			layerNm = "tf_feis_signgu";
		}else if(caption.equals("road")) {
			layerNm = "tf_feis_road";
		}
		
		return layerNm;
	}
	
	/**
	 * Pggis 데이터셋의 조건값 결과를 Memory Udb에 데이터셋 생성
	 * @param targetDatasetNm
	 * @param resultDatasetNm
	 * @param resultQuery
	 * @throws Exception
	 */
	private void copyPggisToMemoryUdb(String targetDatasetNm, String resultDatasetNm, String resultQuery) throws Exception{
		LOGGER.debug("copyPggisToMemoryUdb 시작");
		if(datasets.contains(targetDatasetNm)) {
			LOGGER.debug("targetDatasetNm 존재 확인");
			dataset = (DatasetVector) datasets.get(targetDatasetNm);
			LOGGER.debug("dataset 체크");
			recordset = dataset.query(resultQuery,CursorType.STATIC);
			LOGGER.debug("recordset 체크");
			DatasetVector copyDatastVector = (DatasetVector) mDatasets.createFromTemplate(mDatasets.getAvailableDatasetName(resultDatasetNm),dataset);
			LOGGER.debug("copyDatastVector 템플릿 생성");
			copyDatastVector.append(recordset);
			LOGGER.debug("recordset append");
			//CoordSysTranslator.convert(copyDatastVector, getCustomPrj5179(5179), new CoordSysTransParameter(), CoordSysTransMethod.MTH_GEOCENTRIC_TRANSLATION);
			
			copyDatastVector.close();
			LOGGER.debug("copyDatastVector closed");
			recordset.dispose();
			LOGGER.debug("recordset dispose");
			dataset.close();
			LOGGER.debug("dataset close");
		}
	}
	
	/**
	 * Pggis 데이터셋의 조건값 결과를 Udb에 데이터셋 생성
	 * @param targetDatasetNm
	 * @param resultDatasetNm
	 * @param resultQuery
	 * @throws Exception
	 */
	private void copyPggisToUdb(String targetDatasetNm, String resultDatasetNm, String resultQuery) throws Exception{
		if(datasets.contains(targetDatasetNm)) {
			dataset = (DatasetVector) datasets.get(targetDatasetNm);
			recordset = dataset.query(resultQuery,CursorType.STATIC);

			DatasetVector copyDatastVector = (DatasetVector) uDatasets.createFromTemplate(uDatasets.getAvailableDatasetName(resultDatasetNm),dataset);
			
			copyDatastVector.append(recordset);
			
			//CoordSysTranslator.convert(copyDatastVector, getCustomPrj5179(5179), new CoordSysTransParameter(), CoordSysTransMethod.MTH_GEOCENTRIC_TRANSLATION);
			
			copyDatastVector.close();
			
			recordset.dispose();
			dataset.close();
		}
	}
	
	/**
	 * 결과 레코드셋를 db 테이블로 복사
	 * @param udbDatasetName
	 * @param pggisDatasetName
	 * @throws Exception
	 */
	public void copyUdbToPggisRcordset(Recordset resultRecordSet ,String saveDatasetName, Map<String, Object> saveAttr) throws Exception{
		try {
			if(datasets.contains(saveDatasetName)) {
				
				if(resultRecordSet.getRecordCount() > 0) {
					
					dataset = (DatasetVector) datasets.get(saveDatasetName);
					recordset = dataset.getRecordset(false, CursorType.DYNAMIC);
					
					recordset.addNew(resultRecordSet.getGeometry(), saveAttr);
					recordset.update();
					//dataset.append(uRecordset);
					//dataset.close();
				}else {
					LOGGER.error("udb의 ".concat(resultRecordSet.getDataset().getName()).concat(" 레코드셋 정보가 없습니다."));
				}
				
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		}
	}
	
	/**
	 * 커스텀좌표계 불러오기
	 * @return
	 * @Descrition 
	 * 슈퍼맵의 5179좌표계의 버그로 export 시 중심좌오선의 값이 127.5도가 아닌 127.833333...으로 저장됨.
	 * iobject로 데이터셋이 copy될 경우 (createFromTemplate) 127.3도로 저장됨.
	 * 슈퍼맵의 기본설정된 5179의 경우 중심좌오선 값이 127.3도
	 */
//	private PrjCoordSys getCustomPrj5179(int epsg) {
//		 PrjCoordSys pcs = new PrjCoordSys();
//		 if(epsg == 5179) {
//			 String path = fileStoragePath + superMapMidDir + File.separator + customPcsNm;
//			 pcs.fromFile(path, PrjFileType.SUPERMAP);
//		 }else {
//			 pcs.setEPSGCode(epsg);
//		 }
//		
//		return pcs;
//	}
	
	/**
	 * 분석결과 고유 데이터셋명 생성
	 * @return
	 * @throws Exception
	 */
	public String getDatasetUuid() throws Exception{
		return String.valueOf((new Date().getTime()));
		//return UUID.randomUUID().toString().replaceAll("-", "");
	}
	
	/**
	 * 파일저장 경로 생성
	 * @return
	 * @throws Exception
	 */
	private AnalFileVO getSavePath(String analId, String midPath) throws Exception{
		AnalFileVO vo = new AnalFileVO();
		
		Date date = new Date();
		String year = (new SimpleDateFormat("yyyy").format(date)); 
		String month = (new SimpleDateFormat("MM").format(date)); 
		String day = (new SimpleDateFormat("dd").format(date));
		
		//analisis/img/2022/10/21/
		String midDatePath = year + File.separator + month + File.separator + day;
		String strePathString = fileStoragePath.concat(midPath) + File.separator + midDatePath + File.separator + analId;
		String streFileNm = EgovFileUploadUtil.getPhysicalFileName();
		//String streFullPath = strePathString + File.separator + streFileNm;
		
		File saveFolder = new File(EgovWebUtil.filePathBlackList(strePathString));
		
		if (!saveFolder.exists() || saveFolder.isFile()) {
			if (saveFolder.mkdirs()){
				LOGGER.debug("[file.mkdirs] saveFolder : Creation Success ");
			}else{
				LOGGER.error("[file.mkdirs] saveFolder : Creation Fail ");
			}
		}
		
		vo.setAnalId(analId);
		vo.setFileStreCours(strePathString);
		vo.setStreFileNm(streFileNm);
		
		return vo;
	}
	
	//사용안함////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	/**
	 * or.sabang.sys.service.SysComptVO -> com.supermap.data.Recordset 저장
	 * @param itemVo
	 * @param vectorName
	 * @param query
	 * @param epsgNum
	 * @return
	 * @throws Exception
	 * @see upsertRecordSet(조사정보저장테이블 VO, 테이블명, 조건절, 입력된 좌표체계코드)(사용안함)
	 * 
	 * {
	 *	"MST_ID":400,
	 *	"LOGIN_ID":"김포도",
	 *	"_FID":888,
	 *	"_LON":258146.32280701745,
	 *	"_LAT":436616.8263157895,
	 *	"_KEYWORD":"1",
	 *	"_LABEL":"1",
	 *	"_STYLE":"BRUSH(bc:#f6402c8f,fc:#f6402cff);SYMBOL(c:#f6402cff,o:#f6402cff,s:8)",
	 *	"_MEMO":{"토양특성.토심판정값":"10이하","암석노출도":"5~20","땅밀림현황.지하수용출":[{"시점_경도":208389.54928607607,"발생위치":"7부 능선","시점_고도":"76","시점_위도":208389.54928607607,"발생정도":"적다"}],"능선":"4","지형특성.최대높이":"0","완료":"완료","조치사항":"없음","PNU":"0000000000000000000","땅밀림.지질특성.조사3.종류":"절리","판정점수_균열":22,"지질특성.조사1.종류":"엽리","부번":"0000","점검자":"test","땅밀림현황.균열":[{"발생방향":"수직방향","높이":"18","시점_경도":208402.8564821757,"시점_고도":"77","시점_위도":208402.8564821757,"종점_경도":208385.8710675667,"유형":"수직방향","연장":"13","종점_위도":208385.8710675667,"깊이":"13","종점_고도":"77"}],"시군구":"부천시","LON":208401.95743984176,"지형특성.경사_최소":"13","지질특성.조사2.주향":"1","판정점수_단차":22,"지질특성.조사4.종류":"편리","산림특성.임상":"상록활엽수","지질특성.주구성암석":"화성암(심성암류)","토양특성.암석노출도":"5~20","수리특성.하부계류":"무","지질특성.조사1.경사":"1","조사유형":"땅밀림","판정점수_수목생장이상":14,"지형특성.조사위치":"산복","_LON":208401.95743984176,"너덜":"무","지형구분":"구릉지","지질특성.조사5.주향":"1","지질특성.모암":"화강암류","지질특성.암석풍화":"보통암","지질특성.조사4.경사":"1","토양수분":"약습","최종점검결과":"양호","국가지점번호":"다사 6415 3482","땅밀림.지질특성.조사1.종류":"엽리","지질특성.지질구조_단층":"유","지형특성.경사도":"10~20","땅밀림현황.수목이상생장":[{"수고":"18","이상생장_방향":"산정방향","발생범위_세로":"49","임상":"활엽수","수종":"떡갈,오리나무,개서어나무,활엽수","발생범위_가로":"16","시점_경도":208392.94880248944,"지표높이":"134","시점_고도":"75","흉고직경":"46","시점_위도":208392.94880248944,"유형":"떡갈,오리나무,개서어나무,활엽수"}],"산림특성.주요수종":"개가시,녹나무,사스레피나무","지형특성.사면길이":"0","수리특성.저수지":"유","토양형":"적윤성 산림토양","시도":"경기도","토양구조":"벽상","기타특성.임지이용상태":"민가","토양특성.토양형":"적윤성 산림토양","지형특성.평면형":"凸형(미근형)","판정점수_지하수용출":14,"땅밀림현황.단차":[{"발생방향":"수직방향","높이":"79","시점_경도":208395.19521305585,"시점_고도":"77","시점_위도":208395.19521305585,"종점_경도":208359.81842914008,"연장":"13","종점_위도":208359.81842914008,"깊이":"48","종점_고도":"81"}],"지질특성.조사2.종류":"절리","LAT":534729.0567405795,"기타특성.민가":"13","사진":["gimg:///한국치산기술협회-땅밀림-테스트.ncx/QWER.0001.jpg"],"지형특성.능선":"4","지정해제":"해제가능","본번":"0000","지질특성.조사3.주향":"1","토성":"사질양토(SL SIL)","사진태그":[],"지질특성.조사5.종류":"층리","토양특성.토양수분":"약습","지형특성.경사_평균":"18","지질특성.조사2.경사":"1","토양특성.토양구조":"벽상","속칭":"ㅅ디딛ㅅ디디ㅡ","평면형":"凸형(미근형)","지형특성.지형구분":"구릉지","컬러":-638932,"판정점수_지형특성":11,"토양특성.토성":"사질양토(SL SIL)","수리특성.상부지하수유입":"유","땅밀림현황.구조물이상":[{"구조물크기_세로":"49","구조물종류":"석재류","구조물크기_높이":"13","시점_경도":208388.72638998658,"구조물크기_가로":"13","발생위치":"중","이상정도":"부분 파손","시점_고도":"76","시점_위도":208388.72638998658}],"지형특성.경사_최대":"15","조사ID":"QWER","리":"상동","지질특성.조사5.경사":"1","지질특성.블연속면간격":"넓음(60이상)","종단면형":"凸형(미근형)","땅밀림.지질특성.조사4.종류":"편리","판정점수_구조물이상":14,"지질특성.지질구조_습곡":"무","지형특성.종단면형":"凸형(미근형)","점검일시":"2022-07-04","지질특성.타지층관입암":"유","땅밀림.패스사유":"사유지 및 사유시설","지질특성.불연속면방향수":"2","판정점수_지질특성":10,"지번":"13","신규추가":"신규추가","지질특성.조사1.주향":"1","조사지역위치":"산복","토양특성.토심":"13","땅밀림.지질특성.조사5.종류":"층리","위치정보_Y":208389.1281968704,"조사자":"test","위치정보_X":208389.1281968704,"지질특성.조사3.종류":"절리","FID":2109,"판정점수_토양특성":9,"FILE_NCX":"/storage/emulated/0/가온지도/도면/한국치산기술협회-땅밀림-테스트.ncx","지질특성.불연속면방향성":"수평방향","지질특성.조사4.주향":"1","종합의견2":"지형특성","종합의견3":"보호시설","종합의견1":"대상지현황","_LAT":534729.0567405795,"종합의견4":"기타1","종합의견5":"기타2","지목":"","읍면동":"원미구","고도":"76","토양특성.너덜유무":"무","지질특성.조사3.경사":"1","기타특성.하부이용상태":"농경지","TITLE":"조사야장","땅밀림.지질특성.조사2.종류":"절리"},
	 *	"_TAG1":null,
	 *	"_TAG2":null,
	 *	"_REG_DATE":"2022\/05\/31 11:42:11",
	 *	"_UPD_DATE":"2022\/06\/30 11:42:11",
	 *	"ATTR":[{"VALUE":"97207","NAME":"조사ID"},{"VALUE":"땅밀림 실태조사","NAME":"조사유형"},{"VALUE":"2022","NAME":"조사연도"},{"VALUE":"부산광역시","NAME":"시도"},{"VALUE":"기장군","NAME":"시군구"},{"VALUE":"정관읍","NAME":"읍면동"},{"VALUE":"두명리","NAME":"리"},{"VALUE":"355도","NAME":"지번"},{"VALUE":"35° 21'' 21.082376880010543\"","NAME":"위도"},{"VALUE":"129° 8'' 52.75872599998593\"","NAME":"경도"}],
	 *	"_DATA":"MULTIPOLYGON (((234694.69999999984 234258.80000000016, 234689.70000000024 234258.80000000086, 234689.69999999943 234253.80000000028, 234679.6999999993 234253.79999999952, 234679.70000000007 234243.80000000045, 234674.69999999943 234243.80000000045, 234674.6999999994 234208.80000000057, 234679.70000000083 234208.80000000057, 234679.6999999994 234203.80000000139, 234684.7000000007 234203.8, 234684.69999999972 234208.80000000057, 234689.70000000074 234208.80000000127, 234689.69999999984 234213.79999999976, 234694.70000000056 234213.79999999976, 234694.69999999975 234218.79999999964, 234709.7000000006 234218.80000000034, 234709.69999999885 234228.8000000001, 234699.6999999989 234228.8000000008, 234699.70000000086 234233.8, 234694.70000000074 234233.8000000007, 234694.70000000065 234238.80000000057, 234689.70000000048 234238.79999999917, 234689.70000000115 234248.8000000004, 234694.70000000106 234248.79999999894, 234694.69999999984 234258.80000000016, 234699.69999999928 234258.80000000016, 234699.70000000112 234253.80000000028, 234704.7000000005 234253.79999999952, 234704.70000000033 234248.79999999894, 234719.7000000003 234248.79999999964, 234719.7000000007 234243.80000000045, 234729.70000000094 234243.79999999976, 234729.69999999943 234238.80000000057, 234734.70000000065 234238.80000000203, 234734.70000000106 234218.80000000034, 234739.70000000027 234218.80000000034, 234739.69999999966 234213.80000000045, 234744.70000000118 234213.79999999906, 234744.70000000033 234193.80000000016, 234739.70000000083 234193.80000000016, 234739.700000001 234183.8000000011, 234734.6999999989 234183.8000000004, 234734.69999999914 234178.79999999912, 234729.69999999917 234178.79999999912, 234729.6999999995 234173.79999999923, 234724.69999999934 234173.80000000133, 234724.69999999896 234183.8000000004, 234719.7000000011 234183.7999999997, 234719.69999999908 234193.80000000016, 234709.70000000083 234193.80000000016, 234709.69999999905 234198.80000000005, 234699.70000000024 234198.80000000005, 234699.69999999958 234193.80000000092, 234684.700000001 234193.80000000092, 234684.70000000024 234188.80000000173, 234674.6999999993 234188.80000000028, 234674.70000000097 234183.799999999, 234654.70000000094 234183.799999999, 234654.69999999955 234188.80000000028, 234634.7000000007 234188.79999999888, 234634.69999999984 234193.79999999877, 234614.69999999952 234193.80000000092, 234614.69999999914 234203.8000000007, 234609.69999999914 234203.79999999853, 234609.69999999943 234208.80000000057, 234604.69999999923 234208.80000000057, 234604.69999999917 234228.8000000001, 234614.7000000008 234228.8000000001, 234614.69999999972 234238.79999999847, 234594.70000000088 234238.80000000133, 234594.7000000008 234233.7999999993, 234584.69999999934 234233.80000000144, 234584.6999999997 234238.80000000057, 234579.70000000094 234238.79999999987, 234579.6999999994 234243.8000000012, 234574.70000000048 234243.79999999976, 234574.70000000097 234253.80000000168, 234579.69999999963 234253.80000000028, 234579.69999999905 234258.79999999946, 234584.69999999955 234258.80000000016, 234584.70000000065 234283.80000000028, 234589.7 234283.80000000028, 234589.700000001 234288.80000000162, 234594.69999999984 234288.80000000016, 234594.70000000094 234293.80000000005, 234599.6999999993 234293.8000000008, 234599.7000000005 234298.79999999993, 234619.69999999958 234298.79999999993, 234619.69999999917 234293.8000000008, 234624.70000000077 234293.8000000008, 234624.70000000115 234283.79999999958, 234629.7000000005 234283.80000000098, 234629.69999999893 234268.79999999993, 234634.7000000009 234268.80000000063, 234634.69999999992 234258.80000000016, 234644.69999999908 234258.80000000086, 234644.69999999925 234253.79999999952, 234649.70000000094 234253.80000000098, 234649.6999999992 234248.79999999894, 234659.69999999984 234248.79999999964, 234659.69999999896 234253.79999999952, 234664.69999999995 234253.80000000028, 234664.69999999917 234258.80000000016, 234669.69999999978 234258.80000000086, 234669.69999999908 234263.80000000075, 234674.6999999993 234263.80000000144, 234674.700000001 234268.79999999923, 234684.70000000056 234268.79999999993, 234684.69999999923 234263.80000000005, 234694.70000000068 234263.80000000005, 234694.69999999984 234258.80000000016), (234609.6999999998 234258.80000000086, 234609.69999999943 234273.79999999912, 234604.7000000009 234273.79999999912, 234604.70000000083 234258.79999999946, 234609.6999999998 234258.80000000086)))"
	 *	}
	 */
	public JSONObject upsertRecordSet(SysComptVO itemVo, String vectorName, String query, int epsgNum) throws Exception{
		returnLog = new JSONObject();
		try {
			getConnectionInfo();
			
			epsg = epsgNum;
			//테이블 존재여부 확인
			if(datasets.contains(vectorName)) {
				dataset = (DatasetVector) datasets.get(vectorName);
				//dataset.truncate();
				Map<String, Object> items = changeVoToMap(itemVo);
				Map<String, Object> geomParams = getGeometryParam(items);
				
				String geomType = geomParams.get("type").toString();
				String geomNm = geomParams.get("name").toString();
		        String geomStr = geomParams.get("geometry").toString();
		        
				Geometry geom = null;
				
				recordset = dataset.query(query,CursorType.DYNAMIC);
				//recordset = dataset.getRecordset(false, CursorType.DYNAMIC);
				
				geom = createGeometry(geomStr, geomType);
				attributes = createAttributes(items, geomNm, geomType);
				
				if(recordset.getRecordCount() == 0) {
					recordset.addNew(geom, attributes);
				}else {
					Geometry orginGeom = recordset.getGeometry();
					
					if(orginGeom.getType() != geom.getType()) {
						LOGGER.error("지오메트리 타입이 일치하지 않습니다.");
						throw new Exception("지오메트리 타입이 일치하지 않습니다.");
					}
					
					recordset.edit();
					
					for (Map.Entry<String, Object> entry : attributes.entrySet()) {
				        String entryKey = entry.getKey();
				        Object entryVal = entry.getValue();
				        
 				        Object recordVal = recordset.getFieldValue(entryKey);
 				       
				        if(recordVal != null) {
				        	if(!entryVal.toString().equals(recordVal.toString())) {
				        		recordset.setFieldValue(entryKey,entryVal);
				        	}
				        }
				    }
					
					if(checkUpdateGeometry(orginGeom,geom)) {
						recordset.setGeometry(geom);
					}
					
					orginGeom.dispose();
				}
				recordset.update();
				
				if(geom != null) {
					geom.dispose();
				}
				
				returnLog.put("status", "success");
				returnLog.put("message", "저장되었습니다.");
			}else {
				returnLog.put("status", "fail");
				returnLog.put("message", "테이블을 찾을 수 없습니다\n관리자에게 문의하세요.");
			}
		} catch (Exception e) {
			returnLog.put("error", e.getLocalizedMessage());
			LOGGER.error(e.getLocalizedMessage());
		} finally {
			closeConnection();
		}
		
		return returnLog;
	}
	
	/**
	 * 조사정보 목록 수퍼맵 저장
	 * @param list
	 * @param vectorName
	 * @param query
	 * @param epsgNum
	 * @return
	 * @throws Exception
	 * @see upsertBulkRecordSet(조사정보저장테이블 List, 테이블명, 조건절, 입력된 좌표체계코드)(사용안함)
	 */
	public JSONObject upsertBulkRecordSet(List<SysFieldInfoVO> list, String vectorName, String query, int epsgNum) throws Exception{
		returnLog = new JSONObject();
		
		try {
			getConnectionInfo();
			
			epsg = epsgNum;
			//테이블 존재여부 확인
			if(datasets.contains(vectorName)) {
				dataset = (DatasetVector) datasets.get(vectorName);
				
				for(SysFieldInfoVO itemVo : list) {
					Map<String, Object> items = changeVoToMap(itemVo);
					Map<String, Object> geomParams = getGeometryParam(items);
					
					String geomType = geomParams.get("type").toString();
					String geomNm = geomParams.get("name").toString();
			        String geomStr = geomParams.get("geometry").toString();
			        
					Geometry geom = null;
					
					query = query.replace("{1}",String.valueOf(itemVo.getMST_ID()));
					query = query.replace("{2}",itemVo.get_LABEL());
					
					recordset = dataset.query(query,CursorType.DYNAMIC);
					//recordset = dataset.getRecordset(false, CursorType.DYNAMIC);
					
					geom = createGeometry(geomStr, geomType);
					attributes = createAttributes(items, geomNm, geomType);
					
					if(recordset.getRecordCount() == 0) {
						recordset.addNew(geom, attributes);
					}else {
						Geometry orginGeom = recordset.getGeometry();
						
						if(orginGeom.getType() != geom.getType()) {
							LOGGER.error("지오메트리 타입이 일치하지 않습니다.");
							throw new Exception("지오메트리 타입이 일치하지 않습니다.");
						}
						
						recordset.edit();
						
						for (Map.Entry<String, Object> entry : attributes.entrySet()) {
					        String entryKey = entry.getKey();
					        Object entryVal = entry.getValue();
					        
	 				        Object recordVal = recordset.getFieldValue(entryKey);
	 				       
					        if(recordVal != null) {
					        	if(!entryVal.toString().equals(recordVal.toString())) {
					        		recordset.setFieldValue(entryKey,entryVal);
					        	}
					        }
					    }
						
						if(checkUpdateGeometry(orginGeom,geom)) {
							recordset.setGeometry(geom);
						}
						
						orginGeom.dispose();
					}
					recordset.update();
					
					if(geom != null) {
						geom.dispose();
					}
					
					returnLog.put("status", "success");
					returnLog.put("message", "저장되었습니다.");
				}
				
				
			}else {
				returnLog.put("status", "fail");
				returnLog.put("message", "테이블을 찾을 수 없습니다\n관리자에게 문의하세요.");
			}
		}catch (Exception e) {
			returnLog.put("error", e.getLocalizedMessage());
			LOGGER.error(e.getLocalizedMessage());
		}finally {
			closeConnection();
		}
		
		return returnLog;
	}
	
	
	/**
	 * or.sabang.sys.service.SysFieldInfoVO -> com.supermap.data.Recordset 저장
	 * @param itemVo
	 * @param vectorName
	 * @param epsgNum
	 * @return
	 * @throws Exception
	 * @see upsertRecordSet(공유방대상지저장장테이블 VO, 테이블명, 입력된 좌표체계코드)(사용안함)
	 */
	public JSONObject upsertRecordSet(SysFieldInfoVO itemVo, String vectorName, String query, int epsgNum) throws Exception{
		returnLog = new JSONObject();
		try {
			getConnectionInfo();
			
			epsg = epsgNum;
			//테이블 존재여부 확인
			if(datasets.contains(vectorName)) {
				dataset = (DatasetVector) datasets.get(vectorName);
				//dataset.truncate();
				Map<String, Object> items = changeVoToMap(itemVo);
				Map<String, Object> geomParams = getGeometryParam(items);
				
				String geomType = geomParams.get("type").toString();
				String geomNm = geomParams.get("name").toString();
		        String geomStr = geomParams.get("geometry").toString();
		        
				Geometry geom = null;
				
				recordset = dataset.query(query,CursorType.DYNAMIC);
				//recordset = dataset.getRecordset(false, CursorType.DYNAMIC);
				
				geom = createGeometry(geomStr, geomType);
				attributes = createAttributes(items, geomNm, geomType);
				
				if(recordset.getRecordCount() == 0) {
					recordset.addNew(geom, attributes);
				}else {
					Geometry orginGeom = recordset.getGeometry();
					
					if(orginGeom.getType() != geom.getType()) {
						LOGGER.error("지오메트리 타입이 일치하지 않습니다.");
						throw new Exception("지오메트리 타입이 일치하지 않습니다.");
					}
					
					if(recordset.edit()) {
						for (Map.Entry<String, Object> entry : attributes.entrySet()) {
					        String entryKey = entry.getKey();
					        Object entryVal = entry.getValue();
					        
	 				        Object recordVal = recordset.getFieldValue(entryKey);
	 				       
					        if(recordVal != null) {
					        	if(!entryVal.toString().equals(recordVal.toString())) {
					        		recordset.setFieldValue(entryKey,entryVal);
					        	}
					        }
					    }
						
						if(checkUpdateGeometry(orginGeom,geom)) {
							recordset.setGeometry(geom);
						}
						
						orginGeom.dispose();
					}else {
						returnLog.put("status", "fail");
						returnLog.put("message", "레코드셋 상태를 수정을 변경하지 못했습니다.");
					}
				}
				if(recordset.update()) {
					returnLog.put("status", "success");
					returnLog.put("message", "저장되었습니다.");
				}else {
					returnLog.put("status", "fail");
					returnLog.put("message", "저장을 실패하였습니다.");
				}
				
				if(geom != null) {
					geom.dispose();
				}
				
				
			}else {
				returnLog.put("status", "fail");
				returnLog.put("message", "테이블을 찾을 수 없습니다\n관리자에게 문의하세요.");
			}
		} catch (Exception e) {
			returnLog.put("error", e.getLocalizedMessage());
			LOGGER.error(e.getLocalizedMessage());
		} finally {
			closeConnection();
		}
		
		return returnLog;
	}
	
	/**
	 * 레코드셋 삭제(사용안함)
	 * @return
	 * @throws Exception
	 */
	public JSONObject deleteRecordSet(String vectorName, String query) throws Exception{
		returnLog = new JSONObject();
		try {
			getConnectionInfo();
			
			if(datasets.contains(vectorName)) {
				dataset = (DatasetVector) datasets.get(vectorName);
				
				recordset = dataset.query(query,CursorType.DYNAMIC);
				
				boolean deleted = recordset.deleteAll();
				recordset.update();
				if(deleted) {
					returnLog.put("status", "success");
					returnLog.put("message", "삭제되었습니다.");
				}else {
					returnLog.put("status", "fail");
					returnLog.put("message", "레코드셋 삭제를 실패하였습니다.");
				}
				
			}else {
				returnLog.put("status", "fail");
				returnLog.put("message", "테이블을 찾을 수 없습니다\n관리자에게 문의하세요.");
			}
			
			
		} catch (Exception e) {
			returnLog.put("status", "fail");
			returnLog.put("message", "레코드셋 삭제를 실패하였습니다.");
		} finally {
			closeConnection();
		}
		
		return returnLog;
	}
	
	/**
	 * 데이터셋 생성
	 * @param datasetType
	 * @param name
	 */
	private void createDataset(String datasetType,String name) {
		if(!mDatasets.isAvailableDatasetName(name)) {
			mDatasets.delete(name);
		}
		
		if(datasetType.equals("Image")) {
			DatasetImageInfo datasetImageInfo = new DatasetImageInfo();
			datasetImageInfo.setName(name);
			datasetImageInfo.setBlockSizeOption(BlockSizeOption.BS_128);
			datasetImageInfo.setHeight(200);
			datasetImageInfo.setWidth(200);
			datasetImageInfo.setEncodeType(EncodeType.NONE);
			
			mDatasets.create(datasetImageInfo);
		}else if(datasetType.equals("Grid")) {
			DatasetGridInfo datasetGridInfo = new DatasetGridInfo();
			datasetGridInfo.setName(name);
			datasetGridInfo.setBlockSizeOption(BlockSizeOption.BS_128);
			datasetGridInfo.setHeight(200);
			datasetGridInfo.setWidth(200);
			datasetGridInfo.setNoValue(1.0);
			datasetGridInfo.setPixelFormat(PixelFormat.SINGLE);
			datasetGridInfo.setEncodeType(EncodeType.LZW);
			
			mDatasets.create(datasetGridInfo);
		}else {
			DatasetVectorInfo datasetVectorInfo = new DatasetVectorInfo();
			
			if(datasetType.equals("Point")) {
				datasetVectorInfo.setType(DatasetType.POINT);
				datasetVectorInfo.setName(name);
			}else if(datasetType.equals("Line")) {
				datasetVectorInfo.setType(DatasetType.LINE);
				datasetVectorInfo.setName(name);
			}else if(datasetType.equals("Region")) {
				datasetVectorInfo.setType(DatasetType.REGION);
				datasetVectorInfo.setName(name);
			}else if(datasetType.equals("Text")) {
				datasetVectorInfo.setType(DatasetType.TEXT);
				datasetVectorInfo.setName(name);
			}else if(datasetType.equals("Cad")) {
				datasetVectorInfo.setType(DatasetType.CAD);
				datasetVectorInfo.setName(name);
			}else if(datasetType.equals("Tabular")) {
				datasetVectorInfo.setType(DatasetType.TABULAR);
				datasetVectorInfo.setName(name);
			}
			
			mDatasets.create(datasetVectorInfo);
		}
	}

	List<Double> slopeCdInterval = new ArrayList<>(Arrays.asList(10.0,20.0,30.0,40.0,50.0,60.0,70.0,80.0,Double.MAX_VALUE));
	List<Double> aspectCdInterval = new ArrayList<>(Arrays.asList(0.0,22.5,67.5,112.5,157.5,202.5,247.5,292.5,337.5,360.0));
	List<Double> demCdInterval = new ArrayList<>(Arrays.asList(100.0,200.0,300.0,400.0,500.0,600.0,700.0,800.0,900.0,1000.0,1100.0,1200.0,Double.MAX_VALUE));
	List<Double> lndCdInterval = new ArrayList<>(Arrays.asList(1.1,2.1,3.1,4.1,5.1));
	
	//경사
	List<String> slopeCdIntervalLabel = new ArrayList<>(Arrays.asList("10도 미만","10-20도","20-30도","30-40도","40-50도","50-60도","60-70도","70-80도","80도 이상"));
	//향
	List<String> aspectCdIntervalLabel = new ArrayList<>(Arrays.asList("평지","북","북동","동","남동","남","남서","서","북서","북"));
	//표고
	List<String> demCdIntervalLabel = new ArrayList<>(Arrays.asList("0-100m","100-200m","200-300m","300-400m","400-500m","500-600m","600-700m","700-800m","800-900m","900-1000m","1000-1100m","1100-1200m","1200m 이상"));
	//산사태위험지도
	List<String> lndCdIntervalLabel = new ArrayList<>(Arrays.asList("1등급","2등급","3등급","4등급","5등급"));//사방사업타평에 해당없음 항목이 있는데 체크.
	//임도(수종), 사방(임상)
	List<String> koftrCdIntervalLabel = new ArrayList<>(Arrays.asList("기타침엽수","소나무","잣나무","낙엽송","리기다소나무","곰솔","전나무","편백나무","삼나무","가분비나무","비자나무","은행나무","기타활엽수","상수리나무","신갈나무","굴참나무","기타참나무류","오리나무","고로쇠나무","자작나무","박달나무","밤나무","물푸레나무","서어나무","때죽나무","호두나무","백합나무","포플러","벚나무","느티나무","층층나무","아까시나무","기타상록활엽수","가시나무","구실잣밤나무","녹나무","굴거리나무","황칠나무","사스레피나무","후박나무","새덕이","침활혼효림","죽림","미립목지","제지","관목덤불","주거지","초지","경작지","수체","과수원","기타"));
	//임도(임상)
	List<String> frtpCdIntervalLabel = new ArrayList<>(Arrays.asList("무립지/비산림","침엽수림","활엽수림","혼효림","죽림"));
	//임종
	List<String> frorCdIntervalLabel = new ArrayList<>(Arrays.asList("무립지/비산림","임공림","천연림"));
	//영급
	List<String> agclsCdIntervalLabel = new ArrayList<>(Arrays.asList("1영급","2영급","3영급","4영급","5영급","6영급","7영급","8영급","9영급"));
	//경급
	List<String> dmclsCdIntervalLabel = new ArrayList<>(Arrays.asList("치수","소경목","중경목","대경목"));
	//밀도
	List<String> dnstCdIntervalLabel = new ArrayList<>(Arrays.asList("소","중","밀"));
	//토성
	List<String> soilCdIntervalLabel = new ArrayList<>(Arrays.asList("사양토","양토","미사질양토","미사질식양토","사질식양토","미사질식토","식양토","미사","양질사토","사토","점토","기타"));
	//지질
	List<String> geologyCdIntervalLabel = new ArrayList<>(Arrays.asList("각섬석화강암","각섬암","갈두층","격포리층","고성층","규암","길왕리층","낙동층","달길층","덕용산규암","두무진층","두원층","류문암,류문암질응회암","마이산층","만덕산층","매립지","맥암","면수산규암","문수산층","미고결 퇴적층","미그마타이트질 편마암","미그마타이트질편마암","박달령화강편마암","반려암","반상변성질편마암","반상변성질편편마암","반상변정질편마암","반상화강암","반송층군","반송층군 대동층군","반암류","반휘암","방림층군","방이리층","변성사질암","변성사질암대","변성사질암류","변성석영반암","변성화산암류","부산반상질화강편마암","북평층군","분천 화강편마암","사문암","사암 및 이암","사암및셰일","사암및응회암","사암및이암","산성맥암류","산성반암","산성암","산성암맥","산성화강암류","산성화산암","산성화산암류","산수동층","상부남포층군(성주리층)","상부대석회암층군","상부연일층군","상부천매암","상부천매암대","상부평안층군","서귀포층","석문층","석영반암","석회암","석회암대","선소층","설옥리층","섬록암","섬장암","세립질화강암","신라력암","신라역암","신성리층","안구장편마암","안산암","안산암,안산암질응회암","안산암및안산암질응회암","양덕층군","양평화성복합체","어일층군","역암","역암 및 사암","역질사암","염기성화산암","엽리상화강암","엽리상화강암류","영월형 조선누층군","용암산층","우백질편마암","우백질화강암","우항리층","원남층군","유문암및유문암질응회암","유치역암","율리층군","응회암","장기층군","장동층","장목리층","장촌층","장평리층","적상산층","적성층","정선형 조선누층군","조면안산암","조면안산암 분석구","조면암","조면암 및 조면안산암","조면암 및 현무암","조면암 분석구","조면현무암(I)","조면현무암(I) 응회암","조면현무암(II)","조면현무암(II) 분석구","조면현무암(III)","조면현무암(III) 분석구","조면현무암(IV)","조면현무암(V)","조면현무암(V) 분석구","조면현무암(VI)","조면현무암(VI) 분석구","조면현무암(VII)","조면현무암(VII) 분석구","조면현무암(VIII)","조면현무암(VIII) 분석구","조면현무암(VIII) 응회암","중봉산 화강편마암","중부공주층군","중부남포층군(백운사층,초계리층)","중부대석회암층군","중부연일층군","중부초평층군","중부평안층군","중성,염기성반암","중성및염기성화산암","중성및염기성화산암류","중성암","중성암맥","중화동층","진동층","진주층","청산화강암","충적층","칠곡층","태안층군","통진층","퇴적암","퇴적암 및 화산암","퇴적층","편마암류","편암","편암류","평창형 조선누층군","평해층군","하부공주층군","하부남포층군(아미산층,하조층)","하부대석회암층군","하부연일층군","하부천매암","하부천매암대","하부초평층군","하부평안층군","하산동층","함력천매암","함력천매암대","함석류석 화강편마암","함석류석화강편마암","함안층","함역천매암대","현무암","현무암(I)","현무암(I) 응회암","현무암(II)","현무암(II) 분석구","현무암(III)","현무암(III) 분석구","호상편마암","홍도층","홍제사 화강암","화강반암","화강섬록암","화강암","화강암류","화강암질편마암","화강편마암","화산암류","회장암","휘록암","흑운모편마암","흑운모화강암","흙,모래,자갈"));
	//모암
	List<String> prrckCdIntervalLabel = new ArrayList<>(Arrays.asList("화성암","퇴적암","변성암"));
	//퇴적양식
	List<String> accmaCdIntervalLabel = new ArrayList<>(Arrays.asList("잔적토","보행토(포행토)","봉적토"));
	//암석노출도
	List<String> rockCdIntervalLabel = new ArrayList<>(Arrays.asList("10% 이하","10~30%","30~50%","50~75%"));
	//생태자연도
	List<String> natureCdIntervalLabel = new ArrayList<>(Arrays.asList("1등급","2등급","3등급"));
	
	/**
	 * 그리드 데이터셋 통계생성
	 * @param ds
	 * @return
	 * @throws Exception
	 */
	private JSONObject caculateStatisticsGrid(Dataset ds,String caption,Double dsArea) throws Exception{
		//HashMap<String, String> map = new HashMap<String, String>();
		JSONObject results = new JSONObject();
		JSONObject ratioResult = new JSONObject();
		JSONObject areaResult = new JSONObject();
		JSONObject originAreaResult = new JSONObject();
		DatasetType dt = ds.getType();
//		BigDecimal maxValue = new BigDecimal("0");
		
		//String dsNm = ds.getName();
		
		if(dt == DatasetType.GRID) {
			DatasetGrid grid = (DatasetGrid)ds;
			
			StatisticsResult statisticsResult = grid.buildStatistics();
			results.put("종류", "grid");
			results.put("평균", statisticsResult.getAverage());
			results.put("최고", statisticsResult.getMaxValue());
			results.put("최소", statisticsResult.getMinValue());
			results.put("표준편차", statisticsResult.getStdDeviation());
			
			Map<Integer,Integer> caculateGridMapRatio = caculateGridInterval(grid,caption);
			
			int intevalSum = caculateGridMapRatio.get(100);
			
			for( Map.Entry<Integer,Integer> entry : caculateGridMapRatio.entrySet() ){
				int strKey = entry.getKey();
				int strValue = entry.getValue();
//			    System.out.println( strKey +":"+ strValue );
			    
			    if(strKey != 100) {
			    	String keyLabel = getCaculateIntervalValue(strKey,caption);
			    	
			    	// 기존 BigDecimal 계산버전
//			    	BigDecimal ratioValue = new BigDecimal(Double.toString((double)strValue/(double)intevalSum*100.0));
//			    	BigDecimal areaValue = new BigDecimal(Double.toString(dsArea*((double)strValue/(double)intevalSum)/10000.0));
//			    	ratioResult.put(keyLabel, ratioValue.setScale(1, RoundingMode.HALF_UP)+"%");
//			    	areaResult.put(keyLabel, areaValue.setScale(1, RoundingMode.HALF_UP)+"ha");
			    	
			    	// 신규 double 계산버전
			    	double ratioValue =  Math.round((((double)strValue/(double)intevalSum)*100.0)*10)/10.0;
			    	double areaValue =  Math.round(dsArea*(((double)strValue/(double)intevalSum)/10000.0)*10)/10.0;
					
					ratioResult.put(keyLabel, Double.toString(ratioValue)+"%");
					areaResult.put(keyLabel, Double.toString(areaValue)+"ha");
			    	
			    	originAreaResult.put(keyLabel,dsArea*((double)strValue/(double)intevalSum));
			    }
			}
			results.put("비율", ratioResult);
			results.put("면적", areaResult);
			results.put("면적(m2)", originAreaResult);
//			Map<Integer,Double> caculateGridMapArea = caculateGridToVectorInterval(grid,caption);
//			
//			for( Map.Entry<Integer,Double> entry : caculateGridMapArea.entrySet() ){
//				int strKey = entry.getKey();
//				double strValue = entry.getValue();
//			    
//				String keyLabel = getCaculateIntervalValue(strKey,caption);
//		    	BigDecimal areaValue = new BigDecimal(Double.toString(strValue/10000.0));
//		    	areaResult.put(keyLabel, areaValue.setScale(1, RoundingMode.HALF_UP)+"ha");
//			}
//			results.put("면적", areaResult);
			
			System.out.println(results.toString());
			
			
		}
		
		return results;
	}
	
	/**
	 * 벡터데이터셋 통계생성
	 * @param ds
	 * @param fieldName
	 * @return
	 * @throws Exception
	 */
	private JSONObject caculateStatisticsVector(Dataset ds, String captionNm) throws Exception{
		JSONObject results = new JSONObject();
		DatasetType dt = ds.getType();
		String fieldName = getUniqueExprNm(captionNm);
		double maxValue = 0.0;
		
		if((dt == DatasetType.POINT || dt == DatasetType.LINE || dt == DatasetType.REGION) && fieldName != null) {
			results.put("종류", "vector");
			HashMap<String, String> ratioResult = new HashMap<String, String>();//비율
			HashMap<String, String> areaResult = new HashMap<String, String>();//면적
			JSONObject originAreaResult = new JSONObject();//면적(m2)
			HashMap<String, Double> map = new HashMap<String, Double>();
			 
			DatasetVector vector = (DatasetVector)ds;
			Recordset recordset = vector.getRecordset(false, CursorType.STATIC);
			
			recordset.moveFirst();
			
			double totalArea = 0;
			
			while(!recordset.isEOF()) {
				String nm = recordset.getString(fieldName);
				if(nm != null) {
					GeoRegion region = (GeoRegion) recordset.getGeometry();				
					double area = region.getArea();
					totalArea+=area;
					if(map.get(nm) == null) {
						map.put(nm, area);
					}else {
						double val = Double.valueOf(map.get(nm));
						map.put(nm, val+area);
					}
					//System.out.println(nm+" : "+area);
				}
				recordset.moveNext();
			}
			recordset.close();
			vector.close();
			
			Iterator<String> keys = map.keySet().iterator();
			while( keys.hasNext() ){
				String strKey = keys.next();
				double strValue = map.get(strKey);
				
				//기존 BigDecimal 계산버전
				//BigDecimal chkValue = new BigDecimal(Double.toString(strValue/totalArea*100.0));
				//BigDecimal areaValue = new BigDecimal(Double.toString(strValue/10000.0));
				
				// 신규 double 계산버전
				double chkValue = strValue/totalArea*100.0;
				double areaValue = strValue/10000.0;
				
				if(fieldName.equals("생태자연도")) {
					strKey = strKey+"등급";
				}else if(fieldName.equals("sibflr_scs")) {
					if(strKey.equals("01")) {
						strKey = "사양토";
					}else if(strKey.equals("02")) {
						strKey = "양토";
					}else if(strKey.equals("03")) {
						strKey = "미사질양토";
					}else if(strKey.equals("04")) {
						strKey = "미사질식양토";
					}else if(strKey.equals("05")) {
						strKey = "사질식양토";
					}else if(strKey.equals("06")) {
						strKey = "미사질식토";
					}else if(strKey.equals("07")) {
						strKey = "식양토";
					}else if(strKey.equals("08")) {
						strKey = "미사";
					}else if(strKey.equals("09")) {
						strKey = "양질사토";
					}else if(strKey.equals("10")) {
						strKey = "사토";
					}else if(strKey.equals("11")) {
						strKey = "점토";
					}else if(strKey.equals("99")) {
						strKey = "기타";
					}
				}else if(fieldName.equals("prrck_larg")) {
					if(strKey.equals("1")) {
						strKey = "화성암";
					}else if(strKey.equals("2")) {
						strKey = "퇴적암";
					}else if(strKey.equals("3")) {
						strKey = "변성암";
					}
				}else if(fieldName.equals("accma_for")) {
					if(strKey.equals("1")) {
						strKey = "잔적토";
					}else if(strKey.equals("2")) {
						strKey = "보행토(포행토)";
					}else if(strKey.equals("3")) {
						strKey = "봉적토";
					}
				}else if(fieldName.equals("rock_exdgr")) {
					if(strKey.equals("1")) {
						strKey = "10% 이하";
					}else if(strKey.equals("2")) {
						strKey = "10~30%";
					}else if(strKey.equals("3")) {
						strKey = "30~50%";
					}else if(strKey.equals("4")) {
						strKey = "50~75%";
					}
				}
				
				//기존 BigDecimal 계산버전
//				ratioResult.put(strKey, chkValue.setScale(1, RoundingMode.HALF_UP)+"%");
//				areaResult.put(strKey, areaValue.setScale(1, RoundingMode.HALF_UP)+"ha");
				
				// 신규 double 계산버전
				double convertChkValue = Math.round(chkValue*10)/10.0;
				double convertAreaValue = Math.round(areaValue*10)/10.0;
				
				ratioResult.put(strKey, Double.toString(convertChkValue)+"%");
				areaResult.put(strKey, Double.toString(convertAreaValue)+"ha");
				
				originAreaResult.put(strKey, strValue);
				
				if(maxValue < strValue) {
					results.put("최고", strKey);
					maxValue = strValue;
				}
				
			}
 			JSONObject ratioJsonObject = new JSONObject(ratioResult);
			JSONObject areaJsonObject = new JSONObject(areaResult);
			
			results.put("비율", ratioJsonObject);
			results.put("면적", areaJsonObject);
			results.put("면적(m2)", originAreaResult);
			//System.out.println(map.toString());
			//System.out.println(ratioJsonObject.toString());
			System.out.println(results.toString());
		}
		return results;
	}
	
	/**
	 * rasterToVector 변환 후 면적통계생성(미사용)
	 * @param grid
	 * @param caption
	 * @return
	 * @throws Exception
	 */
	private Map<Integer,Double> caculateGridToVectorInterval(DatasetGrid grid, String caption) throws Exception{
		Map<Integer,Double> results = new HashMap<Integer, Double>();
		double noValue = grid.getNoValue();
		String convertRegionNm = "cvrt".concat(grid.getName());
		HashMap<String, String> areaResult = new HashMap<String, String>();//면적
		
		ConversionAnalystParameter parameter = new ConversionAnalystParameter();
		parameter.setSourceDataset(grid);
		parameter.setTargetDatasource(uDatasource);
		parameter.setTargetDatasetName(convertRegionNm);
		parameter.setSmoothDegree(40);
		parameter.setNoValue(noValue);
		//parameter.setSpecifiedValue(1);
		parameter.setSmoothMethod(SmoothMethod.BSPLINE);
		parameter.setTargetDatasetType(DatasetType.REGION);
		parameter.setValueFieldName("value");
		
		DatasetVector mDataset = ConversionAnalyst.rasterToVector(parameter);
		mDataset.smooth(40, false);
		
		Recordset recordset = mDataset.getRecordset(false, CursorType.STATIC);
		
		recordset.moveFirst();
		
		double totalArea = 0;
		
		while(!recordset.isEOF()) {
			double cellValue = recordset.getDouble("value");
			if(cellValue != noValue) {
				List<Double> selectInterval = null;
            	if(caption.equals("slope")) {
            		selectInterval = slopeCdInterval;
            	}else if(caption.equals("aspect")) {
            		selectInterval = aspectCdInterval;
            	}else if(caption.equals("dem")) {
            		selectInterval = demCdInterval;
            	}else if(caption.equals("landslide")) {
            		selectInterval = lndCdInterval;
            	}
				
				GeoRegion region = (GeoRegion) recordset.getGeometry();				
				double area = region.getArea();
				totalArea+=area;
				
				for (int loop = 0; loop < selectInterval.size(); loop++) {
					double interval = selectInterval.get(loop);
					if(loop == 0) {
        				if(cellValue < interval) {
        					if(results.get(loop) == null) {
        						results.put(loop, area);
        					}else {
        						results.put(loop, results.get(loop)+area);
        					}
        				}
        			}else {
        				if(cellValue >= selectInterval.get(loop-1) && cellValue < interval) {
        					if(results.get(loop) == null) {
        						results.put(loop, area);
        					}else {
        						results.put(loop, results.get(loop)+area);
        					}
        				}
        			}
				}
			}
			recordset.moveNext();
		}
		recordset.close();
		mDataset.close();
		
		return results;
	}
	
	/**
	 * 그리드 데이터셋 통계분류
	 * @param grid
	 * @param caption
	 * @return
	 * @throws Exception
	 */
	private Map<Integer,Integer> caculateGridInterval(DatasetGrid grid,String caption) throws Exception{
		Map<Integer,Integer> results = new HashMap<Integer, Integer>();
		double noValue = grid.getNoValue();
		int checkValueCnt = 0;
		for (int row = 0; row < grid.getHeight(); row++) {
            for (int col = 0; col < grid.getWidth(); col++) {
                double cellValue = grid.getValue(col, row); // Note the order of col and row
                //list.add(cellValue);
                if(cellValue != noValue) {
                	List<Double> selectInterval = null;
                	if(caption.equals("slope")) {
                		selectInterval = slopeCdInterval;
                	}else if(caption.equals("aspect")) {
                		selectInterval = aspectCdInterval;
                	}else if(caption.equals("dem")) {
                		selectInterval = demCdInterval;
                	}else if(caption.equals("landslide")) {
                		selectInterval = lndCdInterval;
                	}
                	
                	for (int loop = 0; loop < selectInterval.size(); loop++) {
            			double interval = selectInterval.get(loop);
            			if(loop == 0) {
            				if(cellValue < interval) {
            					if(results.get(loop) == null) {
            						results.put(loop, 1);
            					}else {
            						results.put(loop, results.get(loop)+1);
            					}
            				}
            			}else {
            				if(cellValue >= selectInterval.get(loop-1) && cellValue < interval) {
            					if(results.get(loop) == null) {
            						results.put(loop, 1);
            					}else {
            						results.put(loop, results.get(loop)+1);
            					}
            				}
            			}
        		    }
                	checkValueCnt++;
                }
            }
        }
		results.put(100, checkValueCnt);
		
		if(caption.equals("aspect")) {
			if(results.get(1) != null && results.get(9) != null) {
				results.put(1,results.get(1)+results.get(9));
				results.remove(9);
			}
		}
		
		System.out.println("caculateGridInterval" + results.toString());
		return results;
	}
	
	/**
	 * 분석통계 단계별 명칭
	 * @param caption
	 * @return
	 * @throws Exception
	 */
	private String getCaculateIntervalValue(Integer indx, String caption) throws Exception{
		String intervalValue = "-";
		if(caption.equals("slope")) {
			intervalValue = slopeCdIntervalLabel.get(indx);
		}else if(caption.equals("aspect")) {
			intervalValue = aspectCdIntervalLabel.get(indx);
		}else if(caption.equals("dem")) {
			intervalValue = demCdIntervalLabel.get(indx);
		}else if(caption.equals("landslide")) {
			intervalValue = lndCdIntervalLabel.get(indx);
		}
		return intervalValue;
	}
	
	/**
	 * 벡터데이터셋 통계 컬럼
	 * @param caption
	 * @return
	 */
	private String getUniqueExprNm(String caption) {
		String expr = null;
		if(caption.matches("koftr.*")) {
			expr = "koftr_nm";
		}else if(caption.matches("agcls.*")) {
			expr = "agcls_nm";
		}else if(caption.matches("dnst.*")) {
			expr = "dnst_nm";
		}else if(caption.matches("dmcls.*")) {
			expr = "dmcls_nm";
		}else if(caption.matches("nature.*")) {
			expr = "생태자연도";
		}else if(caption.matches("geological.*")) {
			expr = "구분";
		}else if(caption.matches("frtp.*")) {
			expr = "frtp_nm";
		}else if(caption.matches("fror.*")) {
			expr = "fror_nm";
		}else if(caption.matches("soil.*")) {
			expr = "sibflr_scs";
		}else if(caption.matches("geology.*")) {
			expr = "refrock";
		}else if(caption.matches("prrck.*")) {
			expr = "prrck_larg";
		}else if(caption.matches("accma.*")) {
			expr = "accma_for";
		}else if(caption.matches("rock.*")) {
			expr = "rock_exdgr";
		}
		
		return expr;
	}
	
	/**
	 * Json 정렬
	 * @param results
	 * @param caption
	 * @return
	 * @throws Exception
	 */
	private JSONArray getSortIntervalValue(JSONObject results,String caption) throws Exception{
		JSONArray sortValueArray = new JSONArray();
		
		List<String> sortLabelList = null;
    	if(caption.equals("slope")) {
    		sortLabelList = slopeCdIntervalLabel;
    	}else if(caption.equals("aspect")) {
    		sortLabelList = aspectCdIntervalLabel;
    	}else if(caption.equals("dem")) {
    		sortLabelList = demCdIntervalLabel;
    	}else if(caption.equals("landslide")) {
    		sortLabelList = lndCdIntervalLabel;
    	}else if(caption.equals("koftr")) {
    		sortLabelList = koftrCdIntervalLabel ;
    	}else if(caption.equals("frtp")) {
    		sortLabelList = frtpCdIntervalLabel  ;
    	}else if(caption.equals("fror")) {
    		sortLabelList = frorCdIntervalLabel  ;
    	}else if(caption.equals("agcls")) {
    		sortLabelList = agclsCdIntervalLabel  ;
    	}else if(caption.equals("dmcls")) {
    		sortLabelList = dmclsCdIntervalLabel  ;
    	}else if(caption.equals("dnst")) {
    		sortLabelList = dnstCdIntervalLabel  ;
    	}else if(caption.equals("soil")) {
    		sortLabelList = soilCdIntervalLabel  ;
    	}else if(caption.equals("geology")) {
    		sortLabelList = geologyCdIntervalLabel  ;
    	}else if(caption.equals("prrck")) {
    		sortLabelList = prrckCdIntervalLabel  ;
    	}else if(caption.equals("accma")) {
    		sortLabelList = accmaCdIntervalLabel  ;
    	}else if(caption.equals("nature")) {
    		sortLabelList = natureCdIntervalLabel  ;
    	}
    	
    	for (int i = 0; i < sortLabelList.size(); i++) {
    		String sortKey = sortLabelList.get(i).toString();
    		if(results.has(sortKey)) {
    			JSONObject sortValues = new JSONObject();
    			sortValues.put(sortKey, results.get(sortKey));
    			sortValueArray.add(sortValues);
    			results.remove(sortKey);
    		}
		}
    	
    	if(results.length() > 0) {
    		Iterator<String> keys = results.keySet().iterator();
			while( keys.hasNext() ){
				JSONObject sortValues = new JSONObject();
				String strKey = keys.next();
//				String strValue = results.get(strKey).toString();
				sortValues.put(strKey, results.get(strKey));
				sortValueArray.add(sortValues);
			}
    	}
    	
    	
		return sortValueArray;
	}
	
	private void createUDataset(String datasetType,String name) {
		if(!uDatasets.isAvailableDatasetName(name)) {
			uDatasets.delete(name);
		}
		
		if(datasetType.equals("Image")) {
			DatasetImageInfo datasetImageInfo = new DatasetImageInfo();
			datasetImageInfo.setName(name);
			datasetImageInfo.setBlockSizeOption(BlockSizeOption.BS_128);
			datasetImageInfo.setHeight(200);
			datasetImageInfo.setWidth(200);
			datasetImageInfo.setEncodeType(EncodeType.NONE);
			
			uDatasets.create(datasetImageInfo);
		}else if(datasetType.equals("Grid")) {
			DatasetGridInfo datasetGridInfo = new DatasetGridInfo();
			datasetGridInfo.setName(name);
			datasetGridInfo.setBlockSizeOption(BlockSizeOption.BS_128);
			datasetGridInfo.setHeight(200);
			datasetGridInfo.setWidth(200);
			datasetGridInfo.setNoValue(1.0);
			datasetGridInfo.setPixelFormat(PixelFormat.SINGLE);
			datasetGridInfo.setEncodeType(EncodeType.LZW);
			
			uDatasets.create(datasetGridInfo);
		}else {
			DatasetVectorInfo datasetVectorInfo = new DatasetVectorInfo();
			
			if(datasetType.equals("Point")) {
				datasetVectorInfo.setType(DatasetType.POINT);
				datasetVectorInfo.setName(name);
			}else if(datasetType.equals("Line")) {
				datasetVectorInfo.setType(DatasetType.LINE);
				datasetVectorInfo.setName(name);
			}else if(datasetType.equals("Region")) {
				datasetVectorInfo.setType(DatasetType.REGION);
				datasetVectorInfo.setName(name);
			}else if(datasetType.equals("Text")) {
				datasetVectorInfo.setType(DatasetType.TEXT);
				datasetVectorInfo.setName(name);
			}else if(datasetType.equals("Cad")) {
				datasetVectorInfo.setType(DatasetType.CAD);
				datasetVectorInfo.setName(name);
			}else if(datasetType.equals("Tabular")) {
				datasetVectorInfo.setType(DatasetType.TABULAR);
				datasetVectorInfo.setName(name);
			}
			
			uDatasets.create(datasetVectorInfo);
		}
	}
	
	private AnalFileVO createXYChartToImage(String type, XYDataset dataset,int upperBound, AnalFileVO vo) throws Exception{
		JFreeChart chart = null;
		
		AnalFileVO fileVo = new AnalFileVO();
		BeanUtils.copyProperties(vo,fileVo);
		
		String title = "";
		String xAxisLabel = "";
		String yAxisLabel = "";
		
		String strePathString = fileVo.getFileStreCours();
		String streFileNm = fileVo.getStreFileNm();
		String streFullPath = strePathString + File.separator + streFileNm;
		String saveFileNm = streFullPath.concat(".jpg");
		
		if(type.equals("line")) {
			chart = ChartFactory.createXYLineChart(title, xAxisLabel, yAxisLabel, dataset);
		}else if(type.equals("area")) {
			chart = ChartFactory.createXYAreaChart(title, xAxisLabel, yAxisLabel, dataset);
		}else if(type.equals("bar")) {
			//chart = ChartFactory.createXYBarChart(title, xAxisLabel,false, yAxisLabel, dataset);
		}else if(type.equals("steparea")) {
			chart = ChartFactory.createXYStepAreaChart(title, xAxisLabel, yAxisLabel, dataset);
		}else if(type.equals("step")) {
			chart = ChartFactory.createXYStepChart(title, xAxisLabel, yAxisLabel, dataset);
		}else if(type.equals("stackxyarea")) {
			//chart = ChartFactory.createStackedXYAreaChart(title, xAxisLabel, yAxisLabel, dataset);
		}
		
		if(chart != null) {
			/* 한글 처리 문제 */
			//차트 제목
			Font labelFont = chart.getTitle().getFont();
			chart.getTitle().setFont(new Font("굴림",labelFont.getStyle(),labelFont.getSize()));
			//CategoryPlot categoryPlot = chart.getCategoryPlot();
			XYPlot xyPlot = chart.getXYPlot();
			
			//렌더러
			XYLineAndShapeRenderer renderer = new XYLineAndShapeRenderer();
			renderer.setSeriesPaint(0,new Color(0,176,240));
			renderer.setSeriesStroke(0,new BasicStroke(2.0f));
			xyPlot.setRenderer(renderer); 
			
			//X축 제목
			labelFont = xyPlot.getDomainAxis().getLabelFont();
			xyPlot.getDomainAxis().setLabelFont(new Font("돋움",labelFont.getStyle(),labelFont.getSize()));
			//X축 값에 대한 레이블
			labelFont = xyPlot.getDomainAxis().getTickLabelFont();
			xyPlot.getDomainAxis().setTickLabelFont(new Font("돋움",labelFont.getStyle(),labelFont.getSize()));
			//Y축 제목
			labelFont = xyPlot.getDomainAxis().getLabelFont();
			xyPlot.getRangeAxis().setLabelFont(new Font("돋움",labelFont.getStyle(),labelFont.getSize()));
			//Y축  값에 대한 레이블
			labelFont = xyPlot.getRangeAxis().getTickLabelFont();
			xyPlot.getRangeAxis().setTickLabelFont(new Font("돋움",labelFont.getStyle(),labelFont.getSize()));
			//범례
			chart.removeLegend();
			//chart.getLegend().setItemFont(new Font("돋움",Font.PLAIN,10));
			//x축 시작 값
			xyPlot.getDomainAxis().setLowerBound(0); // 0부터 시작
			xyPlot.getDomainAxis().setUpperBound(upperBound); // 종료값
			//String outputPath = "D://home/LineChartOutput_".concat(analId).concat(".jpg");
			
			try {
	            ChartUtils.saveChartAsJPEG(new File(saveFileNm), chart, 800, 600);
	            
				fileVo.setFileExtsn("jpg");//파일확장자
	        } catch (IOException e) {
	            e.printStackTrace();
	        }
		}
		System.out.println(saveFileNm);
		return fileVo;
	}
}